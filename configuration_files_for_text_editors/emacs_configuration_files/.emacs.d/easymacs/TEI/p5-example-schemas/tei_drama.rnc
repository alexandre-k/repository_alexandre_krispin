default namespace = "http://www.tei-c.org/ns/1.0"
namespace a1 = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace teix = "http://www.tei-c.org/ns/Examples"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2007-03-13T16:04:56Z.

# 
# This template file is freely available and you are hereby
#             authorised to copy, modify, and redistribute it in any way without
#             further reference or permissions.
# When making such modifications, you are strongly recommended to
#             change the present text to include an accurate statement of the
#             licencing conditions applicable to your modified text.
data.certainty = "high" | "medium" | "low" | "unknown"
data.probability = xsd:double { minInclusive = "0" maxInclusive = "1" }
data.numeric = xsd:double | xsd:decimal
data.count = xsd:nonNegativeInteger
data.temporal =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
  | xsd:token {
      pattern =
        "(-?[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T)?([01][0-9]|2[0-3])(:[0-5][0-9])?(Z|[+\-]((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
    }
data.duration = xsd:duration
data.truthValue = xsd:boolean
data.xTruthValue = xsd:boolean | "unknown" | "inapplicable"
data.language = xsd:language
data.sex = "0" | "1" | "2" | "9"
data.namespace = xsd:anyURI
data.outputMeasurement =
  xsd:token {
    pattern =
      "[\-+]?\d+(\.\d+)?(%|cm|mm|in|pt|pc|px|em|ex|gd|rem|vw|vh|vm)"
  }
data.pattern = xsd:token
data.pointer = xsd:anyURI
data.code = xsd:anyURI
data.enumerated = xsd:token
data.key = xsd:string
data.word = xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
data.name = xsd:Name
macro.component = model.common | mix.drama
macro.componentSeq = (macro.component | model.global)*
macro.paraContent =
  (text | model.gLike | model.phrase | model.inter | model.global)*
macro.phraseSeq = (text | model.gLike | model.phrase | model.global)*
macro.specialPara =
  (text
   | model.gLike
   | model.phrase
   | model.inter
   | model.divPart
   | model.global)*
macro.xtext = (text | model.gLike)*
macro.fileDescPart =
  titleStmt,
  editionStmt?,
  extent?,
  publicationStmt,
  seriesStmt?,
  notesStmt?
macro.glossSeq = altIdent?, equiv*, gloss*, desc*
mix.drama = model.divPart.stage
att.ascribed.attributes = att.ascribed.attribute.who, empty
att.ascribed.attribute.who =
  
  ## indicates the person, or group of
  ##	people, to whom the element content is ascribed.
  attribute who {
    list { data.pointer+ }
  }?
att.authorialIntervention.attributes =
  att.authorialIntervention.attribute.hand,
  att.authorialIntervention.attribute.status,
  att.authorialIntervention.attribute.type,
  empty
att.authorialIntervention.attribute.hand =
  
  ## signifies the hand of the agent which made the addition or
  ##       performed the deletion.
  attribute hand { data.pointer }?
att.authorialIntervention.attribute.status =
  
  ## may be used to indicate faulty deletions, e.g. strikeouts
  ##       which include too much or too little text, or erroneous
  ##       additions, e.g., an insertion which duplicates some of the text
  ##       already present.
  ## Sample values include: 1] duplicate (all of the text indicated as an addition duplicates
  ##	  some text that is in the original, whether the duplication
  ##	  is word-for-word or less exact.); 2] duplicate-partial (part of the text indicated as an addition duplicates
  ##	  some text that is in the original); 3] excessStart (some text at the beginning of the deletion is marked
  ##           as deleted even though it clearly should not be
  ##           deleted.); 4] excessEnd (some text at the end of the deletion is marked as
  ##           deleted even though it clearly should not be
  ##           deleted.); 5] shortStart (some text at the beginning of the deletion is not
  ##           marked as deleted even though it clearly should be.); 6] shortEnd (some text at the end of the deletion is not marked as
  ##           deleted even though it clearly should be.); 7] unremarkable (the deletion is not faulty.)
  [ a1:defaultValue = "unremarkable" ]
  attribute status { data.enumerated }?
att.authorialIntervention.attribute.type =
  
  ## classifies the type of addition or deletion using any convenient typology.
  attribute type { data.enumerated }?
att.datable.attributes =
  att.datable.attribute.notBefore,
  att.datable.attribute.notAfter,
  att.datable.attribute.from,
  att.datable.attribute.to,
  empty
att.datable.attribute.notBefore =
  
  ## specifies the earliest possible date for the event in
  ##	standard form, e.g. yyyy-mm-dd.
  attribute notBefore { data.temporal }?
att.datable.attribute.notAfter =
  
  ## specifies the latest possible date for the event in
  ##	standard form, e.g. yyyy-mm-dd.
  attribute notAfter { data.temporal }?
att.datable.attribute.from =
  
  ## indicates the starting point of the period in standard form.
  attribute from { data.temporal }?
att.datable.attribute.to =
  
  ## indicates the ending point of the period in standard form.
  attribute to { data.temporal }?
att.datePart.attributes =
  att.datePart.attribute.value, att.datePart.attribute.dur, empty
att.datePart.attribute.value =
  
  ## supplies the value of a date or time in a standard form.
  attribute value { data.temporal }?
att.datePart.attribute.dur =
  
  ## (duration) indicates the length of this element in time.
  attribute dur { xsd:duration }?
att.declarable.attributes = att.declarable.attribute.default, empty
att.declarable.attribute.default =
  
  ## indicates whether or not this element is selected by default when
  ## its parent is selected.
  [ a1:defaultValue = "false" ]
  attribute default {
    
    ## (This element is selected if its parent is selected) 
    "true"
    | 
      ## (This element can only be selected explicitly, unless it is the
      ## only one of its kind, in which case it is selected if its parent is selected.) 
      "false"
  }?
att.declaring.attributes = att.declaring.attribute.decls, empty
att.declaring.attribute.decls =
  
  ## identifies one or more declarable elements within the
  ## header, which are understood to apply to the element bearing this
  ## attribute and its content.
  attribute decls {
    list { data.pointer+ }
  }?
att.divLike.attributes =
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  empty
att.divLike.attribute.type =
  
  ## specifies a name conventionally used for this level of
  ##		subdivision, e.g. act, volume, book,
  ##		section, canto, etc.
  attribute type { data.enumerated }?
att.divLike.attribute.org =
  
  ## specifies how the content of the division is organized.
  [ a1:defaultValue = "uniform" ]
  attribute org {
    
    ## (composite content: i.e. no claim is made about the
    ##		  sequence in which the immediate contents of this division
    ##		  are to be processed, or their inter-relationships.) 
    "composite"
    | 
      ## (uniform content: i.e. the immediate contents of this
      ##		  element are regarded as forming a logical unit, to be
      ##		  processed in sequence.) 
      "uniform"
  }?
att.divLike.attribute.sample =
  
  ## indicates whether this division is a sample of the
  ##		original source and if so, from which part.
  [ a1:defaultValue = "complete" ]
  attribute sample {
    
    ## (division lacks material present at end in source.) 
    "initial"
    | 
      ## (division lacks material at start and end.) 
      "medial"
    | 
      ## (division lacks material at start.) 
      "final"
    | 
      ## (position of sampled material within original unknown.) 
      "unknown"
    | 
      ## (division is not a sample.) 
      "complete"
  }?
att.divLike.attribute.part =
  
  ## specifies whether or not the division is fragmented by
  ##		some other structural element, for example a speech which is
  ##		divided between two or more verse stanzas.
  [ a1:defaultValue = "N" ]
  attribute part {
    
    ## (the division is incomplete in some respect) 
    "Y"
    | 
      ## (either the division is complete, or no claim is made as to its completeness.) 
      "N"
    | 
      ## (the initial part of an incomplete division) 
      "I"
    | 
      ## (a medial part of an incomplete division) 
      "M"
    | 
      ## (the final part of an incomplete division) 
      "F"
  }?
att.interpLike.attributes =
  att.interpLike.attribute.resp,
  att.interpLike.attribute.type,
  att.interpLike.attribute.inst,
  empty
att.interpLike.attribute.resp =
  
  ## indicates who is responsible for the interpretation.
  attribute resp { data.pointer }?
att.interpLike.attribute.type =
  
  ## indicates what kind of phenomenon is being noted in the passage.
  ## Sample values include: 1] image (identifies an image in the passage.
  ##    ); 2] character (identifies a character associated with the passage.
  ##    ); 3] theme (identifies a theme in the passage.
  ##    ); 4] allusion (identifies an allusion to another text.
  ##    )
  attribute type { data.enumerated }?
att.interpLike.attribute.inst =
  
  ## points to instances of the analysis or interpretation represented
  ## by the current element.
  attribute inst {
    list { data.pointer+ }
  }?
att.editLike.attributes =
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
att.editLike.attribute.cert =
  
  ## signifies the degree of certainty associated with the
  ##	intervention or interpretation.
  attribute cert { data.enumerated }?
att.editLike.attribute.resp =
  
  ## indicates the agency responsible for the
  ##	intervention or interpretation, for example an editor or transcriber.
  attribute resp { data.pointer }?
att.editLike.attribute.evidence =
  
  ## indicates the nature of the evidence supporting the reliability or
  ##   accuracy of the intervention or interpretation.
  ## Sample values include: 1] internal (there is internal evidence to support the intervention.); 2] external (there is external evidence to support the intervention.); 3] conjecture (the intervention or interpretation has been made by
  ##	  the editor, cataloguer, or scholar on the basis of their expertise.)
  attribute evidence { data.enumerated }?
att.global.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  empty
att.global.attribute.xmlid =
  
  ## provides a unique identifier for the element bearing the
  ##       attribute.
  attribute xml:id { xsd:ID }?
att.global.attribute.n =
  
  ## gives a number (or other label) for an element, which is
  ##       not necessarily unique within the document.
  attribute n {
    list { data.word+ }
  }?
att.global.attribute.xmllang =
  
  ## indicates the language of the element content using the
  ##       codes from RFC
  ##       3066
  attribute xml:lang { data.language }?
att.global.attribute.rend =
  
  ## indicates how the element in question was rendered or
  ##	presented in the source text.
  attribute rend {
    list { data.word+ }
  }?
att.measured.attributes =
  att.measured.attribute.unit, att.measured.attribute.scope, empty
att.measured.attribute.unit =
  
  ## names the units used for the measurement.
  ## Suggested values include: 1] cm (centimetres); 2] mm (millimetres); 3] in (inches)
  attribute unit { data.enumerated }?
att.measured.attribute.scope =
  
  ## specifies the applicability of this measurement, where
  ##    more than one object is being measured.
  ## Sample values include: 1] all (measurement applies to all instances.); 2] most (measurement applies to most of the instances inspected.); 3] range (measurement applies to only the specified range of instances.)
  attribute scope { data.enumerated }?
att.measurement.attributes =
  att.measurement.attribute.unit,
  att.measurement.attribute.quantity,
  att.measurement.attribute.commodity,
  empty
att.measurement.attribute.unit =
  
  ## indicates the units used for the measurement, usually
  ##       using the standard symbol for the desired units.
  ## Suggested values include: 1] m (metre); 2] kg (kilogram); 3] s (second); 4] Hz (hertz); 5] Pa (pascal); 6] Ω (ohm); 7] L (litre); 8] t (tonne); 9] ha (hectare); 10] Å (ångström); 11] mL (millilitre); 12] cm (centimetre); 13] dB (decibel); 14] kbit (kilobit); 15] Kibit (kibibit); 16] kB (kilobyte); 17] KiB (kibibyte); 18] MB (megabyte); 19] MiB (mebibyte)
  attribute unit { data.enumerated }?
att.measurement.attribute.quantity =
  
  ## specifies the number of the specified units that
  ##       comprise the measurement
  attribute quantity { data.numeric }?
att.measurement.attribute.commodity =
  
  ## indicates the substance that is being measured
  attribute commodity {
    list { data.word+ }
  }?
att.naming.attributes = att.naming.attribute.key, empty
att.naming.attribute.key =
  
  ## provides a means of locating a full definition for the
  ##       entity being named such as a database record key or a
  ##       URI.
  attribute key { data.key }?
att.placement.attributes = att.placement.attribute.place, empty
att.placement.attribute.place =
  
  ## 
  ## Suggested values include: 1] infralinear (below the line); 2] margin-bot (in bottom margin); 3] margin-left (in left margin); 4] margin-right (in right margin); 5] margin-top (in top margin); 6] opposite (on opposite page); 7] overleaf (on the other side of the leaf); 8] supralinear (above the line); 9] verso (on verso of sheet); 10] app (note appears in the apparatus at the foot of the page.); 11] end (note appears at end of chapter or volume.); 12] foot (note appears at foot of page.); 13] inline (note appears as a marked paragraph in the body of the text.); 14] interlinear (note appears between lines of the text; a less precise form of either infralinear or supralinear.); 15] inline (addition is made in a space left in the witness by an earlier scribe.); 16] mixed (one or more of the other values)
  attribute place { data.enumerated }?
att.segLike.attributes =
  att.segLike.attribute.type,
  att.segLike.attribute.function,
  att.segLike.attribute.part,
  empty
att.segLike.attribute.type =
  
  ## characterizes the type of segment.
  attribute type { data.enumerated }?
att.segLike.attribute.function =
  
  ## characterizes the function of the segment.
  attribute function { data.enumerated }?
att.segLike.attribute.part =
  
  ## specifies whether or not the segment is fragmented by some other
  ## structural element, for example a clause which is divided between two
  ## or more sentences.
  [ a1:defaultValue = "N" ]
  attribute part {
    
    ## (the segment is incomplete in some respect) 
    "Y"
    | 
      ## (either the segment is complete, or no claim is made as to
      ## its completeness) 
      "N"
    | 
      ## (the initial part of an incomplete segment) 
      "I"
    | 
      ## (a medial part of an incomplete segment) 
      "M"
    | 
      ## (the final part of an incomplete segment) 
      "F"
  }?
att.spanning.attributes = att.spanning.attribute.spanTo, empty
att.spanning.attribute.spanTo =
  
  ## indicates the end of a span initiated by the element
  ##	bearing this attribute.
  attribute spanTo { data.pointer }?
att.tableDecoration.attributes =
  att.tableDecoration.attribute.role,
  att.tableDecoration.attribute.rows,
  att.tableDecoration.attribute.cols,
  empty
att.tableDecoration.attribute.role =
  
  ## indicates the kind of information held in this cell or
  ## in each cell of this row.
  ## Suggested values include: 1] label (labelling or descriptive information only.); 2] data (data values.)
  [ a1:defaultValue = "data" ] attribute role { data.enumerated }?
att.tableDecoration.attribute.rows =
  
  ## indicates the number of rows occupied by this cell or row.
  [ a1:defaultValue = "1" ] attribute rows { data.count }?
att.tableDecoration.attribute.cols =
  
  ## indicates the number of columns occupied by this cell or
  ##	row.
  [ a1:defaultValue = "1" ] attribute cols { data.count }?
att.timed.attributes =
  att.timed.attribute.start,
  att.timed.attribute.end,
  att.timed.attribute.dur,
  empty
att.timed.attribute.start =
  
  ## indicates the location within a temporal alignment
  ##       at which this element begins.
  attribute start { data.pointer }?
att.timed.attribute.end =
  
  ## indicates the location within a temporal alignment at which
  ##    this element ends.
  attribute end { data.pointer }?
att.timed.attribute.dur =
  
  ## (duration) indicates the length of this element in time
  attribute dur { xsd:duration }?
att.translatable.attributes = att.translatable.attribute.version, empty
att.translatable.attribute.version =
  
  ## specifies the version name or number of the source from
  ##	which the translated version was derived
  attribute version { data.word }?
att.typed.attributes =
  att.typed.attribute.type, att.typed.attribute.subtype, empty
att.typed.attribute.type =
  
  ## characterizes the element in some sense, using any convenient
  ##  classification scheme or typology.
  attribute type { data.word }?
att.typed.attribute.subtype =
  
  ## provides a sub-categorization of the element, if needed
  attribute subtype { data.word }?
model.nameLike.agent = name
model.nameLike.agent_sequence = name
model.nameLike.agent_sequenceOptional = name?
model.nameLike.agent_sequenceOptionalRepeatable = name*
model.nameLike.agent_sequenceRepeatable = name+
model.segLike = seg
model.segLike_sequence = seg
model.segLike_sequenceOptional = seg?
model.segLike_sequenceOptionalRepeatable = seg*
model.segLike_sequenceRepeatable = seg+
model.hiLike =
  foreign
  | emph
  | hi
  | distinct
  | mentioned
  | soCalled
  | gloss
  | term
  | title
model.hiLike_sequence =
  foreign, emph, hi, distinct, mentioned, soCalled, gloss, term, title
model.hiLike_sequenceOptional =
  foreign?,
  emph?,
  hi?,
  distinct?,
  mentioned?,
  soCalled?,
  gloss?,
  term?,
  title?
model.hiLike_sequenceOptionalRepeatable =
  foreign*,
  emph*,
  hi*,
  distinct*,
  mentioned*,
  soCalled*,
  gloss*,
  term*,
  title*
model.hiLike_sequenceRepeatable =
  foreign+,
  emph+,
  hi+,
  distinct+,
  mentioned+,
  soCalled+,
  gloss+,
  term+,
  title+
model.dateLike = date | time
model.dateLike_sequence = date, time
model.dateLike_sequenceOptional = date?, time?
model.dateLike_sequenceOptionalRepeatable = date*, time*
model.dateLike_sequenceRepeatable = date+, time+
model.measureLike = num | measure
model.measureLike_sequence = num, measure
model.measureLike_sequenceOptional = num?, measure?
model.measureLike_sequenceOptionalRepeatable = num*, measure*
model.measureLike_sequenceRepeatable = num+, measure+
model.graphicLike = graphic | binaryObject
model.graphicLike_sequence = graphic, binaryObject
model.graphicLike_sequenceOptional = graphic?, binaryObject?
model.graphicLike_sequenceOptionalRepeatable = graphic*, binaryObject*
model.graphicLike_sequenceRepeatable = graphic+, binaryObject+
model.pPart.msdesc = notAllowed
model.pPart.msdesc_sequence = empty
model.pPart.msdesc_sequenceOptional = empty
model.pPart.msdesc_sequenceOptionalRepeatable = empty
model.pPart.msdesc_sequenceRepeatable = notAllowed
model.pPart.edit =
  sic | corr | choice | reg | orig | add | del | unclear | abbr | expan
model.pPart.edit_sequence =
  sic, corr, choice, reg, orig, add, del, unclear, abbr, expan
model.pPart.edit_sequenceOptional =
  sic?, corr?, choice?, reg?, orig?, add?, del?, unclear?, abbr?, expan?
model.pPart.edit_sequenceOptionalRepeatable =
  sic*, corr*, choice*, reg*, orig*, add*, del*, unclear*, abbr*, expan*
model.pPart.edit_sequenceRepeatable =
  sic+, corr+, choice+, reg+, orig+, add+, del+, unclear+, abbr+, expan+
model.ptrLike = ptr | ref
model.ptrLike_sequence = ptr, ref
model.ptrLike_sequenceOptional = ptr?, ref?
model.ptrLike_sequenceOptionalRepeatable = ptr*, ref*
model.ptrLike_sequenceRepeatable = ptr+, ref+
model.lPart = notAllowed
model.lPart_sequence = empty
model.lPart_sequenceOptional = empty
model.lPart_sequenceOptionalRepeatable = empty
model.lPart_sequenceRepeatable = notAllowed
model.global.meta =
  index | link | linkGrp | timeline | join | joinGrp | alt | altGrp
model.global.meta_sequence =
  index, link, linkGrp, timeline, join, joinGrp, alt, altGrp
model.global.meta_sequenceOptional =
  index?, link?, linkGrp?, timeline?, join?, joinGrp?, alt?, altGrp?
model.global.meta_sequenceOptionalRepeatable =
  index*, link*, linkGrp*, timeline*, join*, joinGrp*, alt*, altGrp*
model.global.meta_sequenceRepeatable =
  index+, link+, linkGrp+, timeline+, join+, joinGrp+, alt+, altGrp+
model.milestoneLike = milestone | pb | lb | cb
model.milestoneLike_sequence = milestone, pb, lb, cb
model.milestoneLike_sequenceOptional = milestone?, pb?, lb?, cb?
model.milestoneLike_sequenceOptionalRepeatable =
  milestone*, pb*, lb*, cb*
model.milestoneLike_sequenceRepeatable = milestone+, pb+, lb+, cb+
model.gLike = notAllowed
model.gLike_sequence = empty
model.gLike_sequenceOptional = empty
model.gLike_sequenceOptionalRepeatable = empty
model.gLike_sequenceRepeatable = notAllowed
model.oddDecl = notAllowed
model.oddDecl_sequence = empty
model.oddDecl_sequenceOptional = empty
model.oddDecl_sequenceOptionalRepeatable = empty
model.oddDecl_sequenceRepeatable = notAllowed
model.oddRef = notAllowed
model.oddRef_sequence = empty
model.oddRef_sequenceOptional = empty
model.oddRef_sequenceOptionalRepeatable = empty
model.oddRef_sequenceRepeatable = notAllowed
model.oddPhr = notAllowed
model.oddPhr_sequence = empty
model.oddPhr_sequenceOptional = empty
model.oddPhr_sequenceOptionalRepeatable = empty
model.oddPhr_sequenceRepeatable = notAllowed
model.qLike = q | quote | cit
model.qLike_sequence = q, quote, cit
model.qLike_sequenceOptional = q?, quote?, cit?
model.qLike_sequenceOptionalRepeatable = q*, quote*, cit*
model.qLike_sequenceRepeatable = q+, quote+, cit+
model.biblLike = bibl | biblItem | biblStruct | biblFull
model.biblLike_sequence = bibl, biblItem, biblStruct, biblFull
model.biblLike_sequenceOptional =
  bibl?, biblItem?, biblStruct?, biblFull?
model.biblLike_sequenceOptionalRepeatable =
  bibl*, biblItem*, biblStruct*, biblFull*
model.biblLike_sequenceRepeatable =
  bibl+, biblItem+, biblStruct+, biblFull+
model.listLike = \list | listBibl
model.listLike_sequence = \list, listBibl
model.listLike_sequenceOptional = \list?, listBibl?
model.listLike_sequenceOptionalRepeatable = \list*, listBibl*
model.listLike_sequenceRepeatable = \list+, listBibl+
model.noteLike = note
model.noteLike_sequence = note
model.noteLike_sequenceOptional = note?
model.noteLike_sequenceOptionalRepeatable = note*
model.noteLike_sequenceRepeatable = note+
model.stageLike = stage | move | view | camera | sound | caption | tech
model.stageLike_sequence =
  stage, move, view, camera, sound, caption, tech
model.stageLike_sequenceOptional =
  stage?, move?, view?, camera?, sound?, caption?, tech?
model.stageLike_sequenceOptionalRepeatable =
  stage*, move*, view*, camera*, sound*, caption*, tech*
model.stageLike_sequenceRepeatable =
  stage+, move+, view+, camera+, sound+, caption+, tech+
model.complexVal = notAllowed
model.complexVal_sequence = empty
model.complexVal_sequenceOptional = empty
model.complexVal_sequenceOptionalRepeatable = empty
model.complexVal_sequenceRepeatable = notAllowed
model.singleVal = notAllowed
model.singleVal_sequence = empty
model.singleVal_sequenceOptional = empty
model.singleVal_sequenceOptionalRepeatable = empty
model.singleVal_sequenceRepeatable = notAllowed
model.entryParts.top = notAllowed
model.entryParts.top_sequence = empty
model.entryParts.top_sequenceOptional = empty
model.entryParts.top_sequenceOptionalRepeatable = empty
model.entryParts.top_sequenceRepeatable = notAllowed
model.global.edit = gap
model.global.edit_sequence = gap
model.global.edit_sequenceOptional = gap?
model.global.edit_sequenceOptionalRepeatable = gap*
model.global.edit_sequenceRepeatable = gap+
model.divPart = p | l | lg | sp | ab
model.divPart_sequence = p, l, lg, sp, ab
model.divPart_sequenceOptional = p?, l?, lg?, sp?, ab?
model.divPart_sequenceOptionalRepeatable = p*, l*, lg*, sp*, ab*
model.divPart_sequenceRepeatable = p+, l+, lg+, sp+, ab+
model.blockLike = seg
model.blockLike_sequence = seg
model.blockLike_sequenceOptional = seg?
model.blockLike_sequenceOptionalRepeatable = seg*
model.blockLike_sequenceRepeatable = seg+
model.pLike = p | ab
model.pLike_sequence = p, ab
model.pLike_sequenceOptional = p?, ab?
model.pLike_sequenceOptionalRepeatable = p*, ab*
model.pLike_sequenceRepeatable = p+, ab+
model.persTraitLike = notAllowed
model.persTraitLike_sequence = empty
model.persTraitLike_sequenceOptional = empty
model.persTraitLike_sequenceOptionalRepeatable = empty
model.persTraitLike_sequenceRepeatable = notAllowed
model.persStateLike = notAllowed
model.persStateLike_sequence = empty
model.persStateLike_sequenceOptional = empty
model.persStateLike_sequenceOptionalRepeatable = empty
model.persStateLike_sequenceRepeatable = notAllowed
model.persEventLike = notAllowed
model.persEventLike_sequence = empty
model.persEventLike_sequenceOptional = empty
model.persEventLike_sequenceOptionalRepeatable = empty
model.persEventLike_sequenceRepeatable = notAllowed
model.assertLike =
  model.persTraitLike | model.persStateLike | model.persEventLike
model.assertLike_sequence =
  model.persTraitLike, model.persStateLike, model.persEventLike
model.assertLike_sequenceOptional =
  model.persTraitLike?, model.persStateLike?, model.persEventLike?
model.assertLike_sequenceOptionalRepeatable =
  model.persTraitLike*, model.persStateLike*, model.persEventLike*
model.assertLike_sequenceRepeatable =
  model.persTraitLike+, model.persStateLike+, model.persEventLike+
model.personLike = notAllowed
model.personLike_sequence = empty
model.personLike_sequenceOptional = empty
model.personLike_sequenceOptionalRepeatable = empty
model.personLike_sequenceRepeatable = notAllowed
model.personPart = model.assertLike | bibl
model.personPart_sequence = model.assertLike, bibl
model.personPart_sequenceOptional = model.assertLike?, bibl?
model.personPart_sequenceOptionalRepeatable = model.assertLike*, bibl*
model.personPart_sequenceRepeatable = model.assertLike+, bibl+
model.publicationStmtPart =
  address
  | date
  | publisher
  | pubPlace
  | distributor
  | authority
  | idno
  | availability
model.publicationStmtPart_sequence =
  address,
  date,
  publisher,
  pubPlace,
  distributor,
  authority,
  idno,
  availability
model.publicationStmtPart_sequenceOptional =
  address?,
  date?,
  publisher?,
  pubPlace?,
  distributor?,
  authority?,
  idno?,
  availability?
model.publicationStmtPart_sequenceOptionalRepeatable =
  address*,
  date*,
  publisher*,
  pubPlace*,
  distributor*,
  authority*,
  idno*,
  availability*
model.publicationStmtPart_sequenceRepeatable =
  address+,
  date+,
  publisher+,
  pubPlace+,
  distributor+,
  authority+,
  idno+,
  availability+
model.glossLike = altIdent | desc | equiv | gloss
model.glossLike_sequence = altIdent, desc, equiv, gloss
model.glossLike_sequenceOptional = altIdent?, desc?, equiv?, gloss?
model.glossLike_sequenceOptionalRepeatable =
  altIdent*, desc*, equiv*, gloss*
model.glossLike_sequenceRepeatable = altIdent+, desc+, equiv+, gloss+
model.quoteLike = quote
model.quoteLike_sequence = quote
model.quoteLike_sequenceOptional = quote?
model.quoteLike_sequenceOptionalRepeatable = quote*
model.quoteLike_sequenceRepeatable = quote+
model.respLike = author | editor | respStmt
model.respLike_sequence = author, editor, respStmt
model.respLike_sequenceOptional = author?, editor?, respStmt?
model.respLike_sequenceOptionalRepeatable = author*, editor*, respStmt*
model.respLike_sequenceRepeatable = author+, editor+, respStmt+
model.divWrapper.bottom = trailer | closer | signed
model.divWrapper.bottom_sequence = trailer, closer, signed
model.divWrapper.bottom_sequenceOptional = trailer?, closer?, signed?
model.divWrapper.bottom_sequenceOptionalRepeatable =
  trailer*, closer*, signed*
model.divWrapper.bottom_sequenceRepeatable = trailer+, closer+, signed+
model.divWrapper =
  head
  | byline
  | dateline
  | argument
  | epigraph
  | opener
  | salute
  | docAuthor
  | docDate
model.divWrapper_sequence =
  head,
  byline,
  dateline,
  argument,
  epigraph,
  opener,
  salute,
  docAuthor,
  docDate
model.divWrapper_sequenceOptional =
  head?,
  byline?,
  dateline?,
  argument?,
  epigraph?,
  opener?,
  salute?,
  docAuthor?,
  docDate?
model.divWrapper_sequenceOptionalRepeatable =
  head*,
  byline*,
  dateline*,
  argument*,
  epigraph*,
  opener*,
  salute*,
  docAuthor*,
  docDate*
model.divWrapper_sequenceRepeatable =
  head+,
  byline+,
  dateline+,
  argument+,
  epigraph+,
  opener+,
  salute+,
  docAuthor+,
  docDate+
model.frontPart.drama =
  set | prologue | epilogue | performance | castList
model.frontPart.drama_sequence =
  set, prologue, epilogue, performance, castList
model.frontPart.drama_sequenceOptional =
  set?, prologue?, epilogue?, performance?, castList?
model.frontPart.drama_sequenceOptionalRepeatable =
  set*, prologue*, epilogue*, performance*, castList*
model.frontPart.drama_sequenceRepeatable =
  set+, prologue+, epilogue+, performance+, castList+
model.pLike.front =
  head
  | byline
  | argument
  | epigraph
  | docTitle
  | titlePart
  | docAuthor
  | docEdition
  | docImprint
  | docDate
model.pLike.front_sequence =
  head,
  byline,
  argument,
  epigraph,
  docTitle,
  titlePart,
  docAuthor,
  docEdition,
  docImprint,
  docDate
model.pLike.front_sequenceOptional =
  head?,
  byline?,
  argument?,
  epigraph?,
  docTitle?,
  titlePart?,
  docAuthor?,
  docEdition?,
  docImprint?,
  docDate?
model.pLike.front_sequenceOptionalRepeatable =
  head*,
  byline*,
  argument*,
  epigraph*,
  docTitle*,
  titlePart*,
  docAuthor*,
  docEdition*,
  docImprint*,
  docDate*
model.pLike.front_sequenceRepeatable =
  head+,
  byline+,
  argument+,
  epigraph+,
  docTitle+,
  titlePart+,
  docAuthor+,
  docEdition+,
  docImprint+,
  docDate+
model.titlepagePart =
  graphic
  | binaryObject
  | byline
  | epigraph
  | docTitle
  | titlePart
  | docAuthor
  | imprimatur
  | docEdition
  | docImprint
  | docDate
model.titlepagePart_sequence =
  graphic,
  binaryObject,
  byline,
  epigraph,
  docTitle,
  titlePart,
  docAuthor,
  imprimatur,
  docEdition,
  docImprint,
  docDate
model.titlepagePart_sequenceOptional =
  graphic?,
  binaryObject?,
  byline?,
  epigraph?,
  docTitle?,
  titlePart?,
  docAuthor?,
  imprimatur?,
  docEdition?,
  docImprint?,
  docDate?
model.titlepagePart_sequenceOptionalRepeatable =
  graphic*,
  binaryObject*,
  byline*,
  epigraph*,
  docTitle*,
  titlePart*,
  docAuthor*,
  imprimatur*,
  docEdition*,
  docImprint*,
  docDate*
model.titlepagePart_sequenceRepeatable =
  graphic+,
  binaryObject+,
  byline+,
  epigraph+,
  docTitle+,
  titlePart+,
  docAuthor+,
  imprimatur+,
  docEdition+,
  docImprint+,
  docDate+
model.msItemPart =
  model.quoteLike | model.respLike | bibl | listBibl | title
model.msItemPart_sequence =
  model.quoteLike, model.respLike, bibl, listBibl, title
model.msItemPart_sequenceOptional =
  model.quoteLike?, model.respLike?, bibl?, listBibl?, title?
model.msItemPart_sequenceOptionalRepeatable =
  model.quoteLike*, model.respLike*, bibl*, listBibl*, title*
model.msItemPart_sequenceRepeatable =
  model.quoteLike+, model.respLike+, bibl+, listBibl+, title+
model.choicePart =
  sic | corr | reg | orig | unclear | abbr | expan | seg
model.choicePart_sequence =
  sic, corr, reg, orig, unclear, abbr, expan, seg
model.choicePart_sequenceOptional =
  sic?, corr?, reg?, orig?, unclear?, abbr?, expan?, seg?
model.choicePart_sequenceOptionalRepeatable =
  sic*, corr*, reg*, orig*, unclear*, abbr*, expan*, seg*
model.choicePart_sequenceRepeatable =
  sic+, corr+, reg+, orig+, unclear+, abbr+, expan+, seg+
model.lLike = l
model.lLike_sequence = l
model.lLike_sequenceOptional = l?
model.lLike_sequenceOptionalRepeatable = l*
model.lLike_sequenceRepeatable = l+
model.recordingPart = model.dateLike | respStmt | equipment | broadcast
model.recordingPart_sequence =
  model.dateLike, respStmt, equipment, broadcast
model.recordingPart_sequenceOptional =
  model.dateLike?, respStmt?, equipment?, broadcast?
model.recordingPart_sequenceOptionalRepeatable =
  model.dateLike*, respStmt*, equipment*, broadcast*
model.recordingPart_sequenceRepeatable =
  model.dateLike+, respStmt+, equipment+, broadcast+
model.imprintPart = publisher | biblScope | pubPlace
model.imprintPart_sequence = publisher, biblScope, pubPlace
model.imprintPart_sequenceOptional = publisher?, biblScope?, pubPlace?
model.imprintPart_sequenceOptionalRepeatable =
  publisher*, biblScope*, pubPlace*
model.imprintPart_sequenceRepeatable = publisher+, biblScope+, pubPlace+
model.catDescPart = notAllowed
model.catDescPart_sequence = empty
model.catDescPart_sequenceOptional = empty
model.catDescPart_sequenceOptionalRepeatable = empty
model.catDescPart_sequenceRepeatable = notAllowed
model.settingPart = notAllowed
model.settingPart_sequence = empty
model.settingPart_sequenceOptional = empty
model.settingPart_sequenceOptionalRepeatable = empty
model.settingPart_sequenceRepeatable = notAllowed
model.textDescPart_sequence = empty
model.castItemPart = role | roleDesc | actor
model.castItemPart_sequence = role, roleDesc, actor
model.castItemPart_sequenceOptional = role?, roleDesc?, actor?
model.castItemPart_sequenceOptionalRepeatable = role*, roleDesc*, actor*
model.castItemPart_sequenceRepeatable = role+, roleDesc+, actor+
model.physDescPart_sequenceOptional = empty
model.addressLike = email | address
model.addressLike_sequence = email, address
model.addressLike_sequenceOptional = email?, address?
model.addressLike_sequenceOptionalRepeatable = email*, address*
model.addressLike_sequenceRepeatable = email+, address+
model.nameLike = model.nameLike.agent | rs
model.nameLike_sequence = model.nameLike.agent, rs
model.nameLike_sequenceOptional = model.nameLike.agent?, rs?
model.nameLike_sequenceOptionalRepeatable = model.nameLike.agent*, rs*
model.nameLike_sequenceRepeatable = model.nameLike.agent+, rs+
model.global =
  model.global.meta
  | model.milestoneLike
  | model.noteLike
  | model.global.edit
  | anchor
model.global_sequence =
  model.global.meta,
  model.milestoneLike,
  model.noteLike,
  model.global.edit,
  anchor
model.global_sequenceOptional =
  model.global.meta?,
  model.milestoneLike?,
  model.noteLike?,
  model.global.edit?,
  anchor?
model.global_sequenceOptionalRepeatable =
  model.global.meta*,
  model.milestoneLike*,
  model.noteLike*,
  model.global.edit*,
  anchor*
model.global_sequenceRepeatable =
  model.global.meta+,
  model.milestoneLike+,
  model.noteLike+,
  model.global.edit+,
  anchor+
model.featureVal = model.complexVal | model.singleVal
model.featureVal_sequence = model.complexVal, model.singleVal
model.featureVal_sequenceOptional = model.complexVal?, model.singleVal?
model.featureVal_sequenceOptionalRepeatable =
  model.complexVal*, model.singleVal*
model.featureVal_sequenceRepeatable =
  model.complexVal+, model.singleVal+
model.common =
  model.oddDecl
  | model.oddRef
  | model.qLike
  | model.biblLike
  | model.listLike
  | model.divPart
  | label
model.common_sequence =
  model.oddDecl,
  model.oddRef,
  model.qLike,
  model.biblLike,
  model.listLike,
  model.divPart,
  label
model.common_sequenceOptional =
  model.oddDecl?,
  model.oddRef?,
  model.qLike?,
  model.biblLike?,
  model.listLike?,
  model.divPart?,
  label?
model.common_sequenceOptionalRepeatable =
  model.oddDecl*,
  model.oddRef*,
  model.qLike*,
  model.biblLike*,
  model.listLike*,
  model.divPart*,
  label*
model.common_sequenceRepeatable =
  model.oddDecl+,
  model.oddRef+,
  model.qLike+,
  model.biblLike+,
  model.listLike+,
  model.divPart+,
  label+
model.biblPart =
  model.respLike
  | model.imprintPart
  | series
  | edition
  | extent
  | distributor
  | idno
model.biblPart_sequence =
  model.respLike,
  model.imprintPart,
  series,
  edition,
  extent,
  distributor,
  idno
model.biblPart_sequenceOptional =
  model.respLike?,
  model.imprintPart?,
  series?,
  edition?,
  extent?,
  distributor?,
  idno?
model.biblPart_sequenceOptionalRepeatable =
  model.respLike*,
  model.imprintPart*,
  series*,
  edition*,
  extent*,
  distributor*,
  idno*
model.biblPart_sequenceRepeatable =
  model.respLike+,
  model.imprintPart+,
  series+,
  edition+,
  extent+,
  distributor+,
  idno+
model.datePart = notAllowed
model.datePart_sequence = empty
model.datePart_sequenceOptional = empty
model.datePart_sequenceOptionalRepeatable = empty
model.datePart_sequenceRepeatable = notAllowed
model.frontPart = model.frontPart.drama | divGen | titlePage
model.frontPart_sequence = model.frontPart.drama, divGen, titlePage
model.frontPart_sequenceOptional =
  model.frontPart.drama?, divGen?, titlePage?
model.frontPart_sequenceOptionalRepeatable =
  model.frontPart.drama*, divGen*, titlePage*
model.frontPart_sequenceRepeatable =
  model.frontPart.drama+, divGen+, titlePage+
model.addrPart = model.nameLike | addrLine | street | postCode | postBox
model.addrPart_sequence =
  model.nameLike, addrLine, street, postCode, postBox
model.addrPart_sequenceOptional =
  model.nameLike?, addrLine?, street?, postCode?, postBox?
model.addrPart_sequenceOptionalRepeatable =
  model.nameLike*, addrLine*, street*, postCode*, postBox*
model.addrPart_sequenceRepeatable =
  model.nameLike+, addrLine+, street+, postCode+, postBox+
model.pPart.data =
  model.dateLike
  | model.measureLike
  | model.addressLike
  | model.nameLike
model.pPart.data_sequence =
  model.dateLike, model.measureLike, model.addressLike, model.nameLike
model.pPart.data_sequenceOptional =
  model.dateLike?,
  model.measureLike?,
  model.addressLike?,
  model.nameLike?
model.pPart.data_sequenceOptionalRepeatable =
  model.dateLike*,
  model.measureLike*,
  model.addressLike*,
  model.nameLike*
model.pPart.data_sequenceRepeatable =
  model.dateLike+,
  model.measureLike+,
  model.addressLike+,
  model.nameLike+
model.inter =
  model.oddDecl
  | model.oddRef
  | model.qLike
  | model.biblLike
  | model.listLike
  | model.stageLike
  | label
  | \text
  | castList
model.inter_sequence =
  model.oddDecl,
  model.oddRef,
  model.qLike,
  model.biblLike,
  model.listLike,
  model.stageLike,
  label,
  \text,
  castList
model.inter_sequenceOptional =
  model.oddDecl?,
  model.oddRef?,
  model.qLike?,
  model.biblLike?,
  model.listLike?,
  model.stageLike?,
  label?,
  \text?,
  castList?
model.inter_sequenceOptionalRepeatable =
  model.oddDecl*,
  model.oddRef*,
  model.qLike*,
  model.biblLike*,
  model.listLike*,
  model.stageLike*,
  label*,
  \text*,
  castList*
model.inter_sequenceRepeatable =
  model.oddDecl+,
  model.oddRef+,
  model.qLike+,
  model.biblLike+,
  model.listLike+,
  model.stageLike+,
  label+,
  \text+,
  castList+
model.phrase =
  model.segLike
  | model.hiLike
  | model.graphicLike
  | model.pPart.msdesc
  | model.pPart.edit
  | model.ptrLike
  | model.lPart
  | model.oddPhr
  | model.pPart.data
model.phrase_sequence =
  model.segLike,
  model.hiLike,
  model.graphicLike,
  model.pPart.msdesc,
  model.pPart.edit,
  model.ptrLike,
  model.lPart,
  model.oddPhr,
  model.pPart.data
model.phrase_sequenceOptional =
  model.segLike?,
  model.hiLike?,
  model.graphicLike?,
  model.pPart.msdesc?,
  model.pPart.edit?,
  model.ptrLike?,
  model.lPart?,
  model.oddPhr?,
  model.pPart.data?
model.phrase_sequenceOptionalRepeatable =
  model.segLike*,
  model.hiLike*,
  model.graphicLike*,
  model.pPart.msdesc*,
  model.pPart.edit*,
  model.ptrLike*,
  model.lPart*,
  model.oddPhr*,
  model.pPart.data*
model.phrase_sequenceRepeatable =
  model.segLike+,
  model.hiLike+,
  model.graphicLike+,
  model.pPart.msdesc+,
  model.pPart.edit+,
  model.ptrLike+,
  model.lPart+,
  model.oddPhr+,
  model.pPart.data+
model.divLike = \div
model.divLike_sequence = \div
model.divLike_sequenceOptional = \div?
model.divLike_sequenceOptionalRepeatable = \div*
model.divLike_sequenceRepeatable = \div+
model.divGenLike = divGen
model.divGenLike_sequence = divGen
model.divGenLike_sequenceOptional = divGen?
model.divGenLike_sequenceOptionalRepeatable = divGen*
model.divGenLike_sequenceRepeatable = divGen+
model.div1Like = div1
model.div1Like_sequence = div1
model.div1Like_sequenceOptional = div1?
model.div1Like_sequenceOptionalRepeatable = div1*
model.div1Like_sequenceRepeatable = div1+
model.div2Like = div2
model.div2Like_sequence = div2
model.div2Like_sequenceOptional = div2?
model.div2Like_sequenceOptionalRepeatable = div2*
model.div2Like_sequenceRepeatable = div2+
model.div3Like = div3
model.div3Like_sequence = div3
model.div3Like_sequenceOptional = div3?
model.div3Like_sequenceOptionalRepeatable = div3*
model.div3Like_sequenceRepeatable = div3+
model.div4Like = div4
model.div4Like_sequence = div4
model.div4Like_sequenceOptional = div4?
model.div4Like_sequenceOptionalRepeatable = div4*
model.div4Like_sequenceRepeatable = div4+
model.div5Like = div5
model.div5Like_sequence = div5
model.div5Like_sequenceOptional = div5?
model.div5Like_sequenceOptionalRepeatable = div5*
model.div5Like_sequenceRepeatable = div5+
model.div6Like = div6
model.div6Like_sequence = div6
model.div6Like_sequenceOptional = div6?
model.div6Like_sequenceOptionalRepeatable = div6*
model.div6Like_sequenceRepeatable = div6+
model.div7Like = div7
model.div7Like_sequence = div7
model.div7Like_sequenceOptional = div7?
model.div7Like_sequenceOptionalRepeatable = div7*
model.div7Like_sequenceRepeatable = div7+
model.placeNamePart = notAllowed
model.placeNamePart_sequence = empty
model.placeNamePart_sequenceOptional = empty
model.placeNamePart_sequenceOptionalRepeatable = empty
model.placeNamePart_sequenceRepeatable = notAllowed
p =
  
  ## (paragraph) marks paragraphs in prose.
  element p { p.content, p.attributes }
p.content = macro.paraContent
p.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
foreign =
  
  ## (foreign) identifies a word or phrase as belonging to some language other
  ## than that of the surrounding text. 
  element foreign { foreign.content, foreign.attributes }
foreign.content = macro.phraseSeq
foreign.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
emph =
  
  ## (emphasized) marks words or phrases which are stressed or emphasized for
  ## linguistic or rhetorical effect.
  element emph { emph.content, emph.attributes }
emph.content = macro.paraContent
emph.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
hi =
  
  ## (highlighted) marks a word or phrase as graphically distinct from the
  ## surrounding text, for reasons concerning which no claim is
  ## made. 
  element hi { hi.content, hi.attributes }
hi.content = macro.paraContent
hi.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
distinct =
  
  ## (distinct) identifies any word or phrase which is regarded as linguistically
  ## distinct, for example as archaic, technical, dialectal, non-preferred,
  ## etc., or as forming part of a sublanguage. 
  element distinct { distinct.content, distinct.attributes }
distinct.content = macro.phraseSeq
distinct.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## specifies the sublanguage or register to which the word or phrase
  ## is being assigned
  attribute type { data.enumerated }?,
  
  ## specifies how the phrase is distinct diachronically
  attribute time { data.code }?,
  
  ## specifies how the phrase is distinct diatopically
  attribute space { data.code }?,
  
  ## specifies how the phrase is distinct diastatically
  attribute social { data.code }?,
  empty
q =
  
  ## (quoted speech, thought, or writing) contains material which is
  ## marked as (ostensibly) quoted from elsewhere; in narrative, this element is used to mark direct or
  ## indirect speech; in dictionaries, it ay be used to mark
  ## real or contrived examples of usage; in manuscript descriptions or
  ## other metadata, to mark extracts quoted from the source being documented.
  element q { q.content, q.attributes }
q.content = macro.specialPara
q.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.ascribed.attribute.who,
  
  ## may be used to indicate whether the quoted matter is spoken
  ## or thought, or to characterize it more finely.
  ## Sample values include: 1] spoken (representation of direct speech, usually
  ## marked by quotation marks.); 2] thought (representation of thought, e.g. internal monologue.); 3] written (quotation from a written source.)
  attribute type { data.enumerated }?,
  
  ## may be used to indicate whether the quoted matter is regarded
  ## as direct or indirect speech.
  [ a1:defaultValue = "unknown" ]
  attribute direct {
    
    ## (speech or thought is represented directly.) 
    "true"
    | 
      ## (speech or thought is represented indirectly,
      ## e.g. by use of a marked verbal aspect.) 
      "false"
    | 
      ## (no claim is made.) 
      "unknown"
  }?,
  empty
quote =
  
  ## (quotation) contains a phrase or passage attributed by the narrator or
  ##   author to some agency external to the text.
  element quote { quote.content, quote.attributes }
quote.content = macro.specialPara
quote.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
cit =
  
  ## A quotation from some other document, together with a
  ##   bibliographic reference to its source.
  element cit { cit.content, cit.attributes }
cit.content =
  (model.quoteLike | model.biblLike | model.ptrLike | model.global)+
cit.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
mentioned =
  
  ## marks words or phrases mentioned, not used.
  element mentioned { mentioned.content, mentioned.attributes }
mentioned.content = macro.phraseSeq
mentioned.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
soCalled =
  
  ## (so called) contains a word or phrase for which the author or narrator
  ## indicates a disclaiming of responsibility, for example by the use
  ## of scare quotes or italics.
  element soCalled { soCalled.content, soCalled.attributes }
soCalled.content = macro.phraseSeq
soCalled.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
altIdent =
  
  ## supplies the recommended XML name for an element, class,
  ##   attribute, etc. in some language.
  element altIdent { altIdent.content, altIdent.attributes }
altIdent.content = macro.xtext
altIdent.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  empty
desc =
  
  ## (description) contains a brief description of the purpose and application for
  ## an element, attribute, or attribute value.
  element desc { desc.content, desc.attributes }
desc.content = macro.paraContent
desc.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.translatable.attribute.version,
  empty
equiv =
  
  ## specifies a component which is considered equivalent to the
  ##   parent element, either by co-reference, or by external link.
  element equiv { equiv.content, equiv.attributes }
equiv.content = empty
equiv.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## names the underlying concept of which the parent is a
  ##   representation
  attribute name { data.name }?,
  
  ## references the underlying concept of which the parent is a
  ##   representation by means of some external identifier
  attribute uri { data.pointer }?,
  
  ## references an external script which contains a method to
  ## transform instances of this element to canonical TEI
  ##	
  attribute filter { xsd:anyURI }?,
  
  ## MIME type of external filter script
  attribute mimeType { data.word }?,
  empty
gloss =
  
  ## identifies a phrase or word used to provide a gloss or
  ##   definition for some other word or phrase.
  element gloss { gloss.content, gloss.attributes }
gloss.content = macro.phraseSeq
gloss.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declaring.attribute.decls,
  att.translatable.attribute.version,
  (
   ## identifies the associated term element by an
   ##       absolute or relative URI reference
   attribute target { data.pointer }
   | 
     ## identifies the associated term element using a canonical
     ##       reference from a scheme defined in a refsDecl element
     ##       in the TEI header
     attribute cRef { data.pointer })?,
  empty
term =
  
  ## contains a single-word, multi-word, or symbolic designation
  ##   which is regarded as a technical term.
  element term { term.content, term.attributes }
term.content = macro.phraseSeq
term.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declaring.attribute.decls,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  
  ## supplies the sort key for this term in an index.
  attribute sortKey { data.word }?,
  (
   ## identifies the associated gloss element by an
   ##	absolute or relative URI reference
   attribute target { data.pointer }
   | 
     ## identifies the associated gloss element using a
     ##	canonical reference from a scheme defined in a
     ##	refsDecl element in the TEI header
     attribute cRef { data.pointer })?,
  empty
sic =
  
  ## contains text reproduced although apparently incorrect or inaccurate.
  element sic { sic.content, sic.attributes }
sic.content = macro.paraContent
sic.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
corr =
  
  ## (correction) contains the correct form of a passage apparently erroneous in the copy text.
  element corr { corr.content, corr.attributes }
corr.content = macro.paraContent
corr.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
choice =
  
  ## groups a number of alternative encodings for the same point in
  ##   a text.
  element choice { choice.content, choice.attributes }
choice.content = (model.choicePart | choice)*
choice.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
reg =
  
  ## (regularization) contains a reading which has been regularized or normalized
  ## in some sense.
  element reg { reg.content, reg.attributes }
reg.content = macro.paraContent
reg.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
orig =
  
  ## (original form) contains  a reading which is marked as following  the original,
  ## rather than being normalized or corrected.
  element orig { orig.content, orig.attributes }
orig.content = macro.paraContent
orig.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
gap =
  
  ## (omitted material) indicates a point where material has been omitted in a
  ## transcription, whether for editorial reasons described in the TEI
  ## header, as part of sampling practice, or because the material is
  ## illegible or inaudible.
  element gap { gap.content, gap.attributes }
gap.content = macro.glossSeq
gap.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  
  ## gives the reason for omission.  Sample values include
  ## sampling, illegible, inaudible,
  ## irrelevant, cancelled, cancelled and illegible.
  attribute reason {
    list { data.word+ }
  }?,
  
  ## in the case of text omitted from the transcription because of
  ## deliberate deletion by an identifiable hand, signifies the hand which
  ## made the deletion.
  attribute hand { data.pointer }?,
  
  ## In the case of text omitted because of damage, categorizes the cause of the damage, if it can be identified.
  ## Sample values include: 1] rubbing (damage results from rubbing of the
  ##   leaf edges); 2] mildew (damage results from mildew on the leaf surface); 3] smoke (damage results from smoke)
  attribute agent { data.enumerated }?,
  
  ## indicates approximately how much text has been omitted from the
  ## transcription, in letters, minims, inches, or any appropriate unit,
  ## either because of editorial policy or because a deletion, damage, or
  ## other cause has rendered transcription impossible.
  attribute extent {
    list { data.word+ }
  }?,
  empty
add =
  
  ## (addition) contains letters, words, or phrases inserted in the text by an
  ## author, scribe, annotator, or corrector.
  element add { add.content, add.attributes }
add.content = macro.paraContent
add.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.authorialIntervention.attribute.hand,
  att.authorialIntervention.attribute.status,
  att.authorialIntervention.attribute.type,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.placement.attribute.place,
  empty
del =
  
  ## (deletion) contains a letter, word or passage deleted, marked as deleted,
  ## or otherwise indicated as superfluous or spurious in the copy text by an
  ## author, scribe, annotator, or corrector.
  element del { del.content, del.attributes }
del.content = macro.paraContent
del.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.authorialIntervention.attribute.hand,
  att.authorialIntervention.attribute.status,
  att.authorialIntervention.attribute.type,
  empty
unclear =
  
  ## contains a word, phrase, or passage which cannot be transcribed
  ## with certainty because it is illegible or inaudible in the source.
  element unclear { unclear.content, unclear.attributes }
unclear.content = macro.paraContent
unclear.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  
  ## indicates why the material is hard to transcribe.
  attribute reason {
    list { data.word+ }
  }?,
  
  ## Where the difficulty in transcription arises from action
  ## (partial deletion, etc.) assignable to an identifiable hand, signifies
  ## the hand responsible for the action.
  attribute hand { data.pointer }?,
  
  ## Where the difficulty in transcription arises from
  ##  damage, categorizes the cause of the damage, if it can be identified.
  ## Sample values include: 1] rubbing (damage results from rubbing of the
  ##   leaf edges); 2] mildew (damage results from mildew on the leaf surface); 3] smoke (damage results from smoke)
  attribute agent { data.enumerated }?,
  empty
name =
  
  ## (name, proper noun) contains a proper noun or noun phrase.
  element name { name.content, name.attributes }
name.content = macro.phraseSeq
name.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.naming.attribute.key,
  
  ## indicates the type of the object which is being named by the
  ##       phrase.
  attribute type { data.enumerated }?,
  empty
rs =
  
  ## (referencing string) contains a general purpose name or referring string.
  element rs { rs.content, rs.attributes }
rs.content = macro.phraseSeq
rs.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.naming.attribute.key,
  
  ## indicates more specifically the object referred to by the
  ##       referencing string. Values might include person,
  ##       place, ship, element etc.
  attribute type { data.enumerated }?,
  empty
email =
  
  ## contains an e-mail address identifying a location to which
  ## e-mail messages can be delivered.
  ##		
  element email { email.content, email.attributes }
email.content = macro.phraseSeq
email.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
address =
  
  ## contains a postal  address, for example of a
  ## publisher, an organization, or an individual.
  element address { address.content, address.attributes }
address.content = model.global*, (model.addrPart, model.global*)+
address.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
addrLine =
  
  ## contains one line of a postal address.
  element addrLine { addrLine.content, addrLine.attributes }
addrLine.content = macro.phraseSeq
addrLine.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
street =
  
  ## (street) a full street address including any name or number identifying a
  ## building as well as the name of the street or route on which it is
  ## located.
  element street { street.content, street.attributes }
street.content = macro.phraseSeq
street.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
postCode =
  
  ## (postCode) contains a numerical or alphanumeric code used as part of a
  ## postal address to simplify sorting or delivery of mail. 
  element postCode { postCode.content, postCode.attributes }
postCode.content = text
postCode.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
postBox =
  
  ## (postBox) contains a number or other identifier for some postal delivery
  ## point other than a street address. 
  element postBox { postBox.content, postBox.attributes }
postBox.content = text
postBox.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
num =
  
  ## (number) contains a number, written in any form.
  element num { num.content, num.attributes }
num.content = macro.phraseSeq
num.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## indicates the type of numeric value.
  ## Suggested values include: 1] cardinal (absolute number, e.g. 21, 21.5); 2] ordinal (ordinal number, e.g. 21st); 3] fraction (fraction, e.g. one half or three-quarters); 4] percentage (a percentage)
  attribute type { data.enumerated }?,
  
  ## supplies the value of the number in standard form.
  attribute value { data.numeric }?,
  empty
measure =
  
  ## contains a word or phrase referring to some quantity of
  ## an object or commodity, usually comprising a number, a unit, and a
  ## commodity name.
  element measure { measure.content, measure.attributes }
measure.content = macro.phraseSeq
measure.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.measurement.attribute.unit,
  att.measurement.attribute.quantity,
  att.measurement.attribute.commodity,
  
  ## specifies the type of measurement in any convenient typology.
  attribute type { data.enumerated }?,
  empty
date =
  
  ## contains a date in any format.
  element date { date.content, date.attributes }
date.content =
  (text | model.gLike | model.datePart | model.phrase | model.global)*
date.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.datePart.attribute.value,
  att.datePart.attribute.dur,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.datable.attribute.notBefore,
  att.datable.attribute.notAfter,
  att.datable.attribute.from,
  att.datable.attribute.to,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  
  ## indicates the system or calendar to which the date belongs.
  ## Suggested values include: 1] Gregorian; 2] Julian; 3] Islamic; 4] Hebrew; 5] Revolutionary; 6] Iranian; 7] Coptic; 8] Chinese
  attribute calendar { data.enumerated }?,
  
  ## indicates the degree of precision associated with the date.
  attribute precision { data.certainty }?,
  empty
time =
  
  ## contains a phrase defining a time of day in any format.
  element time { time.content, time.attributes }
time.content =
  (text | model.gLike | model.datePart | model.phrase | model.global)*
time.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.datePart.attribute.value,
  att.datePart.attribute.dur,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.datable.attribute.notBefore,
  att.datable.attribute.notAfter,
  att.datable.attribute.from,
  att.datable.attribute.to,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  empty
abbr =
  
  ## (abbreviation) contains an abbreviation of any sort.
  element abbr { abbr.content, abbr.attributes }
abbr.content = macro.phraseSeq
abbr.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## allows the encoder to classify the abbreviation according to
  ## some convenient typology.
  ## Sample values include: 1] suspension (the abbreviation provides the first
  ##        letter(s) of the word or phrase, omitting the remainder.); 2] contraction (the abbreviation omits some letter(s) in the middle.); 3] brevigraph (the abbreviation comprises a special symbol or mark.); 4] superscription (the abbreviation includes writing above the line.); 5] acronym (the abbreviation comprises the initial letters of
  ##	  the words of a phrase.); 6] title (the abbreviation is for a title of address (Dr, Ms, Mr, …)); 7] organization (the abbreviation is for the name of an organization.); 8] geographic (the abbreviation is for a geographic name.)
  attribute type { data.enumerated }?,
  empty
expan =
  
  ## (expansion) contains the expansion of an abbreviation.
  element expan { expan.content, expan.attributes }
expan.content = macro.phraseSeq
expan.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
ptr =
  
  ## defines a pointer to another location.
  element ptr { ptr.content, ptr.attributes }
ptr.content = empty
ptr.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.pointing.attribute.type,
  att.pointing.attribute.evaluate,
  att.declaring.attribute.decls,
  (
   ## specifies the destination of the pointer by supplying one or
   ##       more URI References
   attribute target {
     list { data.pointer+ }
   }
   | 
     ## specifies the destination of the pointer by supplying a
     ##       canonical reference from a scheme defined in a refsDecl
     ##       element in the TEI header
     attribute cRef {
       list { data.word+ }
     })?,
  empty
ref =
  
  ## defines a reference to another location, possibly
  ##   modified by additional text or comment.
  element ref { ref.content, ref.attributes }
ref.content = macro.paraContent
ref.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.pointing.attribute.type,
  att.pointing.attribute.evaluate,
  att.declaring.attribute.decls,
  (
   ## specifies the destination of the reference by supplying one
   ##     or more URI References
   attribute target {
     list { data.pointer+ }
   }
   | 
     ## specifies the destination of the reference by supplying a
     ##       canonical reference from a scheme defined in a refsDecl
     ##       element in the TEI header
     attribute cRef {
       list { data.word+ }
     })?,
  empty
\list =
  
  ## contains any sequence of items organized as a list.
  element list { list.content, list.attributes }
list.content =
  (model.divWrapper | model.global)*,
  ((item, model.global*)+
   | (headLabel?,
      headItem?,
      (label, model.global*, item, model.global*)+)),
  (model.divWrapper.bottom, model.global*)*
list.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## describes the form of the list.
  ## Suggested values include: 1] ordered (list items are numbered or lettered.
  ##     ); 2] bulleted (list items are marked with a
  ## bullet or other typographic device.
  ##     ); 3] simple (list items are not numbered or bulleted.
  ##     ); 4] gloss (each list item glosses some term or
  ## concept, which is given by a label element preceding
  ## the list item.)
  [ a1:defaultValue = "simple" ] attribute type { data.enumerated }?,
  empty
item =
  
  ## contains one
  ## component of a list.
  element item { item.content, item.attributes }
item.content = macro.specialPara
item.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
label =
  
  ## contains the label associated with an item in a list; in
  ## glossaries, marks the term being defined.
  element label { label.content, label.attributes }
label.content = macro.phraseSeq
label.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
head =
  
  ## (heading) contains any type of heading, for example the title of a section,
  ## or the heading of a list, glossary, manuscript description, etc.
  element head { head.content, head.attributes }
head.content = macro.paraContent
head.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## categorizes the heading in any way meaningful 
  ##          to the encoder. 
  attribute type { data.enumerated }?,
  empty
headLabel =
  
  ## (heading for list labels) contains the heading for the label or term column in a
  ## glossary list or similar structured list.
  element headLabel { headLabel.content, headLabel.attributes }
headLabel.content = macro.phraseSeq
headLabel.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
headItem =
  
  ## (heading for list items) contains the heading for the item or gloss column in a
  ## glossary list or similar structured list.
  element headItem { headItem.content, headItem.attributes }
headItem.content = macro.phraseSeq
headItem.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
note =
  
  ## contains a note or annotation.
  element note { note.content, note.attributes }
note.content = macro.specialPara
note.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.placement.attribute.place,
  
  ## describes the type of note.
  attribute type { data.enumerated }?,
  
  ## indicates who is responsible for the annotation: author,
  ##	editor, translator, etc.
  attribute resp { data.pointer }?,
  
  ## indicates whether the copy text shows the exact place of reference
  ## for the note.
  [ a1:defaultValue = "true" ]
  attribute anchored {
    
    ## (copy text indicates the place of attachment for the note.
    ##     ) 
    "true"
    | 
      ## (copy text indicates no place of attachment for the note.) 
      "false"
  }?,
  
  ## indicates the point (or points) of attachment for a note, or the beginning of
  ## the span to which the note is attached.
  attribute target {
    list { data.pointer+ }
  }?,
  
  ## points to the end of the span to which the note is attached, if
  ## the note is not embedded in the text at that point.
  attribute targetEnd {
    list { data.pointer+ }
  }?,
  empty
index =
  
  ## (index entry) marks a location to be indexed for whatever purpose.
  element index { index.content, index.attributes }
index.content = (term, index?)*
index.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.spanning.attribute.spanTo,
  
  ## supplies a name to specify which index (of several) the index entry belongs to.
  attribute indexName { data.name }?,
  empty
divGen =
  
  ## (automatically generated text division) indicates the location at which a textual division generated
  ## automatically by a text-processing application is to appear.
  element divGen { divGen.content, divGen.attributes }
divGen.content = model.divWrapper*
divGen.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## specifies what type of generated text division (e.g. index,
  ## table of contents, etc.) is to appear.
  ## Sample values include: 1] index (an index is to be generated and inserted at this point.); 2] toc (a table of contents); 3] figlist (a list of figures); 4] tablist (a list of tables)
  attribute type { data.enumerated }?,
  empty
graphic =
  
  ## indicates the location of an inline graphic, illustration, or figure.
  element graphic { graphic.content, graphic.attributes }
graphic.content = empty
graphic.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## The display width of the image
  attribute width { data.outputMeasurement }?,
  
  ## The display height of the image
  attribute height { data.outputMeasurement }?,
  
  ## A scale factor to be applied to the image to make it the desired display size
  attribute scale { data.numeric }?,
  
  ## The target URL
  attribute url { data.pointer }?,
  
  ## The MIME type
  attribute mimeType { data.word }?,
  empty
binaryObject =
  
  ## provides encoded binary data representing an inline graphic or other object.
  element binaryObject { binaryObject.content, binaryObject.attributes }
binaryObject.content = text
binaryObject.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## The display width of the object
  attribute width { data.outputMeasurement }?,
  
  ## The display height of the object
  attribute height { data.outputMeasurement }?,
  
  ## A scale factor to be applied to the object to make it the desired display size
  attribute scale { data.numeric }?,
  
  ## The MIME type
  attribute mimeType { data.word }?,
  
  ## The encoding used to encode the binary data. If not
  ##       specified, this is assumed to be Base64
  attribute encoding {
    list { data.word+ }
  }?,
  empty
milestone =
  
  ## marks a boundary point separating  any kind of section of a text, as indicated by
  ## changes in a standard reference system, where the section is not
  ## represented by a structural element.
  element milestone { milestone.content, milestone.attributes }
milestone.content = empty
milestone.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## indicates the edition or version to which the milestone applies.
  attribute ed { data.code }?,
  
  ## provides a conventional name for the kind of section changing at this milestone.
  ## Suggested values include: 1] page (physical page breaks (synonymous with the pb
  ##	  element).); 2] column (column breaks.); 3] line (line breaks (synonymous with the lb element).); 4] book (any units termed book, liber, etc.); 5] poem (individual poems in a collection.); 6] canto (cantos or other major sections of a poem.); 7] stanza (stanzas within a poem, book, or canto.); 8] act (acts within a play.); 9] scene (scenes within a play or act.); 10] section (sections of any kind.); 11] absent (passages not present in the reference edition.)
  attribute unit { data.enumerated },
  empty
pb =
  
  ## (page break) marks the boundary between one page of a text and the next
  ## in a standard reference system.
  element pb { pb.content, pb.attributes }
pb.content = empty
pb.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## indicates the edition or version in which the page break is located
  ## at this point
  attribute ed { data.code }?,
  empty
lb =
  
  ## (line break) marks the start of a new (typographic) line in some
  ## edition or version of a text.
  element lb { lb.content, lb.attributes }
lb.content = empty
lb.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## indicates the edition or version in which the line break is located
  ## at this point
  attribute ed { data.code }?,
  empty
cb =
  
  ## (column break) marks the boundary between one column of a text and the next
  ## in a standard reference system.
  element cb { cb.content, cb.attributes }
cb.content = empty
cb.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## indicates the edition or version in which the column break is located
  ## at this point
  attribute ed { data.code }?,
  empty
bibl =
  
  ## (bibliographic citation) contains a loosely-structured bibliographic citation of which
  ## the sub-components may or may not be explicitly tagged. 
  element bibl { bibl.content, bibl.attributes }
bibl.content =
  (text
   | model.gLike
   | model.hiLike
   | model.pPart.data
   | model.pPart.edit
   | model.segLike
   | model.ptrLike
   | model.biblPart
   | model.global)*
bibl.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
biblItem =
  
  ## (bibliographic citation) contains a bibliographic citation in which only bibliographic
  ##   subelements appear.
  element biblItem { biblItem.content, biblItem.attributes }
biblItem.content =
  (title
   | biblItem
   | imprint
   | model.nameLike
   | model.biblPart
   | model.dateLike)+
biblItem.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  
  ## indicates the physical form of the object of this bibliographic entry.
  ## Sample values include: 1] book.hardcover (); 2] book.paperback (); 3] video.VHS (); 4] video.DVD (); 5] audio.casette (); 6] audio.CD ()
  attribute form { data.word }?,
  
  ## indicates the publication status of the object of this bibliographic entry.
  ## Sample values include: 1] manuscript (the item is a manuscript); 2] forthcoming (the item is being published, but has not been released yet); 3] inPrint (the item is currently being published)
  attribute status { text }?,
  
  ## indicates the relationship of this bibliographic entry to
  ##       that of its parent bibl or biblItem.
  ## Sample values include: 1] host (this bibliographic item has a host relationship to
  ##	  the item encoded in the parent bibl or biblItem; e.g., this item is the
  ##	  magazine in which the article described by the parent bibl or biblItem
  ##	  appeared.); 2] original (the item is original source); 3] workReviewed (this bibliographic item was reviewed in the ancestor work); 4] edition (indicates that this entry contains separate
  ##	  information for a particular edition of the parent bibl or biblItem); 5] basedOn (indicates that the parent bibl or biblItem is the base work from which this one was
  ##	  derived); 6] referencedBy (indicates that the element is a reference for the work in question); 7] copyOf (indicates that this entry is for a facsimile of that
  ##	  which is referred to by the parent bibl or biblItem)
  attribute role { text }?,
  empty
biblStruct =
  
  ## (structured bibliographic citation) contains a structured bibliographic citation, in which only
  ## bibliographic subelements appear and in a specified order. 
  element biblStruct { biblStruct.content, biblStruct.attributes }
biblStruct.content =
  analytic*, (monogr, series*)+, (model.noteLike | idno)*
biblStruct.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
biblFull =
  
  ## contains a fully-structured bibliographic citation, in which all
  ## components of the TEI file description
  ## are present.
  element biblFull { biblFull.content, biblFull.attributes }
biblFull.content = macro.fileDescPart, sourceDesc*
biblFull.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
listBibl =
  
  ## (citation list) contains a list of bibliographic citations of any kind. 
  element listBibl { listBibl.content, listBibl.attributes }
listBibl.content =
  (model.divWrapper | model.global)*,
  (model.biblLike, model.global*)+,
  (model.divWrapper.bottom, model.global*)*
listBibl.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
analytic =
  
  ## (analytic level) contains bibliographic elements describing an item (e.g. an
  ## article or poem) published within a monograph or journal and not as an
  ## independent publication.
  element analytic { analytic.content, analytic.attributes }
analytic.content = (author | editor | respStmt | title)*
analytic.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
monogr =
  
  ## (monographic level) contains bibliographic elements describing an item (e.g. a book
  ## or journal) published as an independent item (i.e. as a separate
  ## physical object).
  element monogr { monogr.content, monogr.attributes }
monogr.content =
  (((author | editor | respStmt),
    (author | editor | respStmt)*,
    title+,
    (editor | respStmt)*)
   | (title+, (author | editor | respStmt)*))?,
  (model.noteLike | meeting)*,
  (edition, (editor | respStmt)*)*,
  imprint,
  (imprint | extent | biblScope)*
monogr.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
series =
  
  ## (series information) contains information about the series in which a book or other
  ## bibliographic item has appeared.
  element series { series.content, series.attributes }
series.content =
  (text
   | model.gLike
   | title
   | editor
   | respStmt
   | biblScope
   | model.global)*
series.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
author =
  
  ## in a bibliographic reference, contains the name of the author(s),
  ## personal or corporate,
  ## of a work; the primary statement of responsibility for any
  ## bibliographic item. 
  element author { author.content, author.attributes }
author.content = macro.phraseSeq
author.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
editor =
  
  ## secondary statement of responsibility for a
  ## bibliographic item, for example the name of an individual, institution
  ## or organization, (or of several such) acting as editor, compiler,
  ## translator, etc. 
  element editor { editor.content, editor.attributes }
editor.content = macro.phraseSeq
editor.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## specifies the nature of the intellectual responsibility
  [ a1:defaultValue = "editor" ] attribute role { data.enumerated }?,
  empty
respStmt =
  
  ## (statement of responsibility) supplies a statement of responsibility for someone responsible
  ##   for the intellectual content of a text, edition, recording, or
  ##   series, where the specialized elements for authors, editors, etc. do
  ##   not suffice or do not apply.
  element respStmt { respStmt.content, respStmt.attributes }
respStmt.content =
  (resp+, model.nameLike.agent+) | (model.nameLike.agent+, resp+)
respStmt.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
resp =
  
  ## contains a phrase describing the nature of a person's
  ##   intellectual responsibility.
  element resp { resp.content, resp.attributes }
resp.content = macro.phraseSeq
resp.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
title =
  
  ## contains the full title of a work of any kind.
  element title { title.content, title.attributes }
title.content = macro.paraContent
title.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## indicates the bibliographic level for a title, that is,
  ##	whether it identifies  an article, book, journal,
  ## series, or unpublished material.
  attribute level {
    
    ## (analytic title (article, poem, or other item published as
    ##           part of a larger item)
    ##     ) 
    "a"
    | 
      ## (monographic title (book, collection, or other item published
      ##           as a distinct item, including single volumes of multi-volume
      ##           works)
      ##     ) 
      "m"
    | 
      ## (journal title
      ##     ) 
      "j"
    | 
      ## (series title
      ##     ) 
      "s"
    | 
      ## (title of unpublished material (including theses and
      ##           dissertations unless published by a commercial press)) 
      "u"
  }?,
  
  ## classifies the title according to some convenient typology.
  ## Sample values include: 1] main (main title
  ##     ); 2] sub (subtitle, title of part
  ##     ); 3] alt (alternate title, often in another language,
  ##                            by which the work is also known
  ##     ); 4] short (abbreviated form of title); 5] desc (descriptive paraphrase of the work functioning as a title)
  attribute type { data.enumerated }?,
  empty
meeting =
  
  ## in bibliographic references,
  ## contains a description of the meeting or conference from which
  ## the bibliographic item derives.
  element meeting { meeting.content, meeting.attributes }
meeting.content = macro.paraContent
meeting.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
imprint =
  
  ## groups information relating to the publication or distribution
  ##   of a bibliographic item.
  element imprint { imprint.content, imprint.attributes }
imprint.content = ((model.imprintPart | model.dateLike), model.global*)+
imprint.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
publisher =
  
  ## provides the name of the organization responsible for
  ## the publication or distribution of a bibliographic item.
  element publisher { publisher.content, publisher.attributes }
publisher.content = macro.phraseSeq
publisher.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
biblScope =
  
  ## (scope of citation) defines the scope of a bibliographic reference, for example as a
  ## list of pagenumbers, or a named subdivision of a larger work.
  element biblScope { biblScope.content, biblScope.attributes }
biblScope.content = macro.phraseSeq
biblScope.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## identifies the type of information conveyed by the element, e.g.
  ## pages, volume.
  ## Suggested values include: 1] vol (the element contains a volume number.); 2] issue (the element contains an issue number, or volume and
  ## issue numbers.); 3] pp (the element contains a page number or page range.); 4] cap (the element contains a chapter indication (number
  ## and/or title)); 5] part (the element identifies a part of a book or collection.)
  attribute type { data.enumerated }?,
  empty
pubPlace =
  
  ## contains the name of the place where a bibliographic item was
  ## published.
  element pubPlace { pubPlace.content, pubPlace.attributes }
pubPlace.content = macro.phraseSeq
pubPlace.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.naming.attribute.key,
  empty
l =
  
  ## (verse line) contains a single, possibly incomplete, line of verse.
  element l { l.content, l.attributes }
l.content = macro.paraContent
l.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## specifies whether or not the line is metrically complete. 
  [ a1:defaultValue = "N" ]
  attribute part {
    
    ## (the line is metrically incomplete) 
    "Y"
    | 
      ## (either the line is complete, or no claim is made as to its
      ## completeness) 
      "N"
    | 
      ## (the initial part of an incomplete line) 
      "I"
    | 
      ## (a medial part of an incomplete line) 
      "M"
    | 
      ## (the final part of an incomplete line) 
      "F"
  }?,
  empty
lg =
  
  ## (line group) contains a group of verse lines functioning as a formal unit,
  ## e.g. a stanza, refrain, verse paragraph, etc.
  element lg { lg.content, lg.attributes }
lg.content =
  (model.divWrapper | model.global)*,
  (model.lLike | lg),
  (model.lLike | lg | model.global)*,
  (model.divWrapper.bottom, model.global*)*
lg.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  empty
sp =
  
  ## (speech) An individual speech in a performance text, or a passage
  ##	  presented as such in a prose or verse text.
  element sp { sp.content, sp.attributes }
sp.content =
  model.global*,
  (speaker, model.global*)?,
  ((model.lLike | lg | model.pLike | model.blockLike | model.stageLike),
   model.global*)+
sp.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.ascribed.attribute.who,
  empty
speaker =
  
  ## A specialized form of heading or label, giving the name of
  ## one or more speakers in a dramatic text or fragment.
  element speaker { speaker.content, speaker.attributes }
speaker.content = macro.phraseSeq
speaker.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
stage =
  
  ## (stage direction) contains any kind of stage direction within a dramatic text or
  ## fragment.
  element stage { stage.content, stage.attributes }
stage.content = macro.specialPara
stage.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## indicates the kind of stage direction.
  ## Suggested values include: 1] setting (describes a setting.); 2] entrance (describes an entrance.); 3] exit (describes an exit.); 4] business (describes stage business.); 5] novelistic (is a narrative, motivating stage direction.); 6] delivery (describes how a character speaks.); 7] modifier (gives some detail about a character.); 8] location (describes a location.); 9] mixed (more than one of the above)
  attribute type { data.enumerated }?,
  empty
teiCorpus =
  
  ## (TEI corpus) contains the whole of a TEI encoded corpus, comprising a
  ## single corpus header and one or more TEI elements, each containing
  ## a single text header and a text.
  element teiCorpus { teiCorpus.content, teiCorpus.attributes }
teiCorpus.content = teiHeader, (TEI | teiCorpus)+
teiCorpus.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## The version of the TEI scheme
  [ a1:defaultValue = "5.0" ] attribute version { xsd:decimal }?,
  empty
teiHeader =
  
  ## (TEI Header) supplies the descriptive and declarative information making
  ##	up an electronic title page prefixed to every TEI-conformant
  ##	text.
  element teiHeader { teiHeader.content, teiHeader.attributes }
teiHeader.content = fileDesc, model.headerPart*, revisionDesc?
teiHeader.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## specifies the kind of document to which the header is attached.
  ## Sample values include: 1] text (the header is attached to a single text.); 2] corpus (the header is attached to a corpus.)
  [ a1:defaultValue = "text" ] attribute type { data.enumerated }?,
  empty
fileDesc =
  
  ## (File Description) contains a full bibliographic description of an electronic
  ## file.
  element fileDesc { fileDesc.content, fileDesc.attributes }
fileDesc.content = macro.fileDescPart, sourceDesc+
fileDesc.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
titleStmt =
  
  ## (title statement) groups information about the title of a work and those
  ## responsible for its intellectual content.
  element titleStmt { titleStmt.content, titleStmt.attributes }
titleStmt.content =
  title+, (author | editor | sponsor | funder | principal | respStmt)*
titleStmt.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
sponsor =
  
  ## specifies the name of a sponsoring organization or
  ## institution.
  element sponsor { sponsor.content, sponsor.attributes }
sponsor.content = macro.phraseSeq
sponsor.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
funder =
  
  ## (Funding body) specifies the name of an individual, institution, or organization
  ## responsible for the funding of a project or text.
  element funder { funder.content, funder.attributes }
funder.content = macro.phraseSeq
funder.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
principal =
  
  ## (principal researcher) supplies the name of the principal researcher responsible for the
  ## creation of an electronic text.
  element principal { principal.content, principal.attributes }
principal.content = macro.phraseSeq
principal.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
editionStmt =
  
  ## (edition statement) groups information relating to one edition of a text.
  element editionStmt { editionStmt.content, editionStmt.attributes }
editionStmt.content = model.pLike+ | (edition, respStmt*)
editionStmt.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
edition =
  
  ## (Edition) describes the particularities of one edition of a text.
  element edition { edition.content, edition.attributes }
edition.content = macro.phraseSeq
edition.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
extent =
  
  ## describes the approximate size of a text as stored on
  ## some carrier medium, whether digital or non-digital, specified in any convenient units.
  element extent { extent.content, extent.attributes }
extent.content = macro.phraseSeq
extent.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
publicationStmt =
  
  ## (publication statement) groups information concerning the publication or distribution
  ## of an electronic or other text. 
  element publicationStmt {
    publicationStmt.content, publicationStmt.attributes
  }
publicationStmt.content = model.pLike+ | model.publicationStmtPart+
publicationStmt.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
distributor =
  
  ## supplies the name of a person or other agency responsible for the
  ## distribution of a text.
  element distributor { distributor.content, distributor.attributes }
distributor.content = macro.phraseSeq
distributor.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
authority =
  
  ## (release authority) supplies the name of a person or other agency responsible for
  ##   making an electronic file available, other than a publisher or
  ##   distributor.
  element authority { authority.content, authority.attributes }
authority.content = macro.phraseSeq
authority.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
idno =
  
  ## (identifying number) supplies any standard or non-standard number used to identify a
  ## bibliographic item.
  element idno { idno.content, idno.attributes }
idno.content = text
idno.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## categorizes the number, for example as an ISBN or other
  ##          standard series.
  ##    
  attribute type { data.enumerated }?,
  empty
availability =
  
  ## supplies information about the availability of a text, for
  ##   example any restrictions on its use or distribution, its copyright
  ##   status, etc.
  element availability { availability.content, availability.attributes }
availability.content = model.pLike+
availability.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## supplies a code identifying the current availability of the
  ## text.
  ##    
  [ a1:defaultValue = "unknown" ]
  attribute status {
    
    ## (the text is freely available.
    ##     ) 
    "free"
    | 
      ## (the status of the text is unknown.
      ##     ) 
      "unknown"
    | 
      ## (the text is not freely available.
      ##    ) 
      "restricted"
  }?,
  empty
seriesStmt =
  
  ## (series statement) groups information about the series, if any, to which
  ## a publication belongs.
  element seriesStmt { seriesStmt.content, seriesStmt.attributes }
seriesStmt.content =
  model.pLike+
  | (title+, (idno | respStmt)*)
seriesStmt.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
notesStmt =
  
  ## (Notes statement) collects together any notes providing information about a text
  ## additional to that recorded in other parts of the bibliographic
  ## description.
  element notesStmt { notesStmt.content, notesStmt.attributes }
notesStmt.content = model.noteLike+
notesStmt.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
sourceDesc =
  
  ## supplies a description of the source text(s) from
  ## which an electronic text was derived or generated.
  element sourceDesc { sourceDesc.content, sourceDesc.attributes }
sourceDesc.content =
  model.pLike+ | listBibl | (model.biblLike | model.sourceDescPart)+
sourceDesc.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
scriptStmt =
  
  ## (script statement) contains a citation giving details of the script used for
  ## a spoken text.
  element scriptStmt { scriptStmt.content, scriptStmt.attributes }
scriptStmt.content = model.pLike+ | model.biblLike
scriptStmt.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
recordingStmt =
  
  ## (recording statement) describes a set of recordings used in transcription of a
  ## spoken text.
  element recordingStmt {
    recordingStmt.content, recordingStmt.attributes
  }
recordingStmt.content = model.pLike+ | recording+
recordingStmt.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
recording =
  
  ## (recording event) details of an audio or video recording event
  ## used as the source of a spoken text, either directly or from
  ## a public broadcast. 
  element recording { recording.content, recording.attributes }
recording.content = model.pLike+ | model.recordingPart*
recording.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  
  ## the kind of recording.
  [ a1:defaultValue = "audio" ]
  attribute type {
    
    ## (audio recording) 
    "audio"
    | 
      ## (audio and video recording) 
      "video"
  }?,
  
  ## the original duration of the recording. 
  attribute dur { data.duration }?,
  empty
equipment =
  
  ## (equipment) provides technical details of the equipment and media used for
  ## an audio or video recording used as the source for a spoken text.
  element equipment { equipment.content, equipment.attributes }
equipment.content = model.pLike+
equipment.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
broadcast =
  
  ## (broadcast) describes a broadcast used as the source of a spoken text.
  element broadcast { broadcast.content, broadcast.attributes }
broadcast.content = model.pLike+ | model.biblLike | recording
broadcast.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
encodingDesc =
  
  ## (Encoding description) documents the relationship between an electronic text and the
  ## source or sources from which it was derived.
  element encodingDesc { encodingDesc.content, encodingDesc.attributes }
encodingDesc.content = (model.encodingPart | model.pLike)+
encodingDesc.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
projectDesc =
  
  ## (project description) describes in detail the aim or purpose for which an electronic
  ## file was encoded, together with any other relevant information
  ## concerning the process by which it was assembled or collected.
  element projectDesc { projectDesc.content, projectDesc.attributes }
projectDesc.content = model.pLike+
projectDesc.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
samplingDecl =
  
  ## (sampling declaration) contains a prose description of the rationale and methods used
  ## in sampling texts in the creation of a corpus or collection.
  element samplingDecl { samplingDecl.content, samplingDecl.attributes }
samplingDecl.content = model.pLike+
samplingDecl.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
editorialDecl =
  
  ## (editorial practice declaration) provides details of editorial principles and practices applied
  ## during the encoding of a text.
  element editorialDecl {
    editorialDecl.content, editorialDecl.attributes
  }
editorialDecl.content = model.pLike+ | model.editorialDeclPart+
editorialDecl.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
correction =
  
  ## (correction principles) states how and under what circumstances corrections have been
  ## made in the text.
  element correction { correction.content, correction.attributes }
correction.content = model.pLike+
correction.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  
  ## indicates the degree of correction applied to the text.
  ##    
  [ a1:defaultValue = "unknown" ]
  attribute status {
    
    ## (the text has been thoroughly checked and
    ##                        proofread.
    ##     ) 
    "high"
    | 
      ## (the text has been checked at least once.
      ##     ) 
      "medium"
    | 
      ## (the text has not been checked.
      ##     ) 
      "low"
    | 
      ## (the correction status of the text is unknown.
      ##    ) 
      "unknown"
  }?,
  
  ## indicates the method adopted to indicate corrections within the
  ##          text.
  ##    
  [ a1:defaultValue = "silent" ]
  attribute method {
    
    ## (corrections have been made silently
    ##     ) 
    "silent"
    | 
      ## (corrections have been represented using editorial tags
      ##    ) 
      "tags"
  }?,
  empty
normalization =
  
  ## indicates the extent of normalization or regularization of the
  ## original source carried out in converting it to electronic form.
  element normalization {
    normalization.content, normalization.attributes
  }
normalization.content = model.pLike+
normalization.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  
  ## indicates the authority for any normalization carried out.
  ##     
  attribute source { data.pointer }?,
  
  ## indicates the method adopted to indicate normalizations within
  ##          the text.
  ##    
  [ a1:defaultValue = "silent" ]
  attribute method {
    
    ## (normalization made silently
    ##   ) 
    "silent"
    | 
      ## (normalization represented using editorial tags
      ##    ) 
      "tags"
  }?,
  empty
quotation =
  
  ## specifies editorial practice adopted with respect to quotation
  ##   marks in the original. 
  element quotation { quotation.content, quotation.attributes }
quotation.content = model.pLike+
quotation.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  
  ## indicates whether or not quotation marks have been retained as
  ##       content within the text. 
  [ a1:defaultValue = "all" ]
  attribute marks {
    
    ## (no quotation marks have been retained ) 
    "none"
    | 
      ## (some quotation marks have been retained ) 
      "some"
    | 
      ## (all quotation marks have been retained ) 
      "all"
  }?,
  
  ## specifies how quotation marks are indicated within the
  ##       text.
  [ a1:defaultValue = "unknown" ]
  attribute form {
    
    ## (quotation marks are retained as data.) 
    "data"
    | 
      ## (the rendition attribute is consistently used to
      ##           indicate the form of quotation marks.) 
      "rend"
    | 
      ## (use of quotation marks has been standardized.) 
      "std"
    | 
      ## (quotation marks are represented inconsistently.) 
      "nonstd"
    | 
      ## (use of quotation marks is unknown.) 
      "unknown"
  }?,
  empty
hyphenation =
  
  ## (Hyphenation) summarizes the way in which hyphenation in a source text has been
  ## treated in an encoded version of it.
  element hyphenation { hyphenation.content, hyphenation.attributes }
hyphenation.content = model.pLike+
hyphenation.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  
  ## indicates whether or not end-of-line hyphenation has been
  ##	retained in a text.
  [ a1:defaultValue = "some" ]
  attribute eol {
    
    ## (all end-of-line hyphenation has been retained,
    ##                    even though the lineation of the original
    ##                    may not have been.
    ##    ) 
    "all"
    | 
      ## (end-of-line hyphenation has been retained in some
      ##                    cases.
      ##    ) 
      "some"
    | 
      ## (all soft end-of-line hyphenation has been removed:
      ##                    any remaining end-od-line hyphenation should be retained.
      ##   ) 
      "hard"
    | 
      ## (all end-of-line hyphenation has been removed:
      ##                   any remaining hyphenation occurred within the line.
      ##    ) 
      "none"
  }?,
  empty
segmentation =
  
  ## describes the principles according to which the text has been
  ## segmented, for example into sentences, tone-units, graphemic strata,
  ## etc.
  element segmentation { segmentation.content, segmentation.attributes }
segmentation.content = model.pLike+
segmentation.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
stdVals =
  
  ## (Standard values) specifies the format used when standardized date or number
  ## values are supplied.
  element stdVals { stdVals.content, stdVals.attributes }
stdVals.content = model.pLike+
stdVals.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
interpretation =
  
  ## describes the scope of any analytic or interpretive information
  ## added to the text in addition to the transcription. 
  element interpretation {
    interpretation.content, interpretation.attributes
  }
interpretation.content = model.pLike+
interpretation.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
tagsDecl =
  
  ## (tagging declaration) provides detailed information about the tagging applied to an SGML or XML document.
  element tagsDecl { tagsDecl.content, tagsDecl.attributes }
tagsDecl.content = rendition*, \namespace*
tagsDecl.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
tagUsage =
  
  ## (tag usage) supplies information about the usage of a specific element
  ## within a text. 
  element tagUsage { tagUsage.content, tagUsage.attributes }
tagUsage.content = macro.paraContent
tagUsage.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## the name (generic identifier)
  ## of the element indicated by the tag.
  attribute gi { data.name },
  
  ## specifies the number of occurrences of this element within the text.
  ##  
  attribute occurs { data.count }?,
  
  ## specifies the number of occurrences of this element within the text
  ## which bear a distinct value for the global xml:id attribute. 
  attribute withId { data.count }?,
  
  ## specifies the identifier of a rendition element which
  ## defines how this element is to be rendered.
  attribute render { data.pointer }?,
  empty
\namespace =
  
  ## supplies the formal name of the namespace to which the elements
  ## documented by its children belong. 
  element namespace { namespace.content, namespace.attributes }
namespace.content = tagUsage+
namespace.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## the full formal name of the namespace concerned.
  attribute name { data.namespace },
  empty
rendition =
  
  ## (rendition) supplies information about the intended rendition of one or more
  ## elements.
  element rendition { rendition.content, rendition.attributes }
rendition.content = macro.paraContent
rendition.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
refsDecl =
  
  ## (references declaration) specifies how canonical references are constructed for this
  ##   text.
  element refsDecl { refsDecl.content, refsDecl.attributes }
refsDecl.content = model.pLike+ | cRefPattern+ | state+
refsDecl.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  
  ## identifies the document type within which
  ##       this reference declaration is used.
  [ a1:defaultValue = "TEI" ] attribute doctype { data.name }?,
  empty
cRefPattern =
  
  ## (defines how to convert a canonical reference into a URI) specifies an expression and replacement pattern for
  ##   tranforming a canonical reference into a URI
  element cRefPattern { cRefPattern.content, cRefPattern.attributes }
cRefPattern.content = model.pLike*
cRefPattern.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## specifies a regular expression against which the values of
  ##       cRef attributes can be matched.
  attribute matchPattern { data.pattern },
  
  ## specifies a replacement pattern
  ##       which, once subpattern substitution has been performed, provides
  ##       a URI.
  attribute replacementPattern { text },
  empty
state =
  
  ## specifies one component of a canonical reference defined by
  ## the milestone method.
  element state { state.content, state.attributes }
state.content = empty
state.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## indicates which edition or version the milestone applies to.
  attribute ed { data.code }?,
  
  ## indicates what kind of state is changing at this milestone.
  ## Suggested values include: 1] page (page breaks in the reference edition.
  ##     ); 2] column (column breaks.
  ##     ); 3] line (line breaks.
  ##     ); 4] book (any units termed book, liber, etc.
  ##     ); 5] poem (individual poems in a collection.
  ##     ); 6] canto (cantos or other major sections of a poem.
  ##     ); 7] stanza (stanzas within a poem, book, or canto.
  ##     ); 8] act (acts within a play.
  ##     ); 9] scene (scenes within a play or act.
  ##     ); 10] section (sections of any kind.
  ##     ); 11] absent (passages not present in the reference edition.)
  attribute unit { data.enumerated },
  
  ## specifies the fixed length of the reference component.
  attribute length { data.count }?,
  
  ## supplies a delimiting string following the reference
  ##           component.
  attribute delim { text }?,
  empty
classDecl =
  
  ## (classification declarations) contains one or more taxonomies defining any classificatory
  ## codes used elsewhere in the text.
  element classDecl { classDecl.content, classDecl.attributes }
classDecl.content = taxonomy+
classDecl.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
taxonomy =
  
  ## (taxonomy) defines a typology used to classify texts either implicitly, by
  ## means of a bibliographic citation, or explicitly by a structured
  ## taxonomy.
  element taxonomy { taxonomy.content, taxonomy.attributes }
taxonomy.content =
  model.glossLike* | category+ | (model.biblLike, category*)
taxonomy.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
category =
  
  ## (category) contains an individual descriptive category, possibly nested
  ## within a superordinate category, within a user-defined taxonomy.
  element category { category.content, category.attributes }
category.content = (catDesc | model.glossLike), category*
category.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
catDesc =
  
  ## (category description) describes some category within a taxonomy
  ## or text typology, either in the form of a brief prose description
  ## or in terms of the situational parameters used by the TEI
  ## formal textDesc.
  element catDesc { catDesc.content, catDesc.attributes }
catDesc.content = (text | model.phrase | model.catDescPart)*
catDesc.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
fsdDecl =
  
  ## (FSD (feature-system declaration) declaration) identifies the feature system declaration which contains
  ## definitions for a particular type of feature structure.
  element fsdDecl { fsdDecl.content, fsdDecl.attributes }
fsdDecl.content = empty
fsdDecl.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## identifies the type of feature structure documented by the FSD;
  ## this will be the value of the type attribute on at least one
  ## feature structure.
  attribute type { data.enumerated },
  
  ## supplies a link to the entity containing the feature system
  ## declaration. 
  attribute url { data.pointer },
  empty
metDecl =
  
  ## documents the notation employed to represent a metrical
  ##   pattern when this is specified as the value of a met,
  ##   real, or rhyme attribute on any structural
  ##   element of a metrical text (e.g. lg, l, or
  ##   seg).
  element metDecl { metDecl.content, metDecl.attributes }
metDecl.content = macro.componentSeq | metSym+
metDecl.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  
  ## indicates whether the notation conveys the abstract
  ##       metrical form, its actual prosodic realization, or the rhyme
  ##       scheme, or some combination thereof.
  
  ## Sorry, unable to create schema that uses actual counts minOccurs=1 and maxOccurs=3; approximating to minOccurs=1 and maxOccurs=unbounded.
  [ a1:defaultValue = "met real" ]
  attribute type {
    list { data.enumerated, data.enumerated* }
  }?,
  
  ## specifies a regular expression defining any value that
  ##	is legal for this notation.
  attribute pattern { data.pattern }?,
  empty
metSym =
  
  ## documents the intended significance of a particular character or
  ## character sequence within a metrical notation, either explicitly or in
  ## terms of other symbol elements in the same metDecl.
  element metSym { metSym.content, metSym.attributes }
metSym.content = macro.phraseSeq
metSym.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## specifies the character or character sequence being documented.
  attribute value {
    list { data.word+ }
  },
  
  ## specifies whether the symbol is defined in terms of other
  ## symbols (terminal is set to false) or in prose
  ## (terminal is set to true).
  [ a1:defaultValue = "true" ]
  attribute terminal {
    
    ## (the element contains a prose definition of its meaning.) 
    "true"
    | 
      ## (the element contains a definition of its meaning given using
      ## symbols defined elsewhere in the same metDecl element.) 
      "false"
  }?,
  empty
variantEncoding =
  
  ## declares the method used to encode text-critical variants.
  element variantEncoding {
    variantEncoding.content, variantEncoding.attributes
  }
variantEncoding.content = empty
variantEncoding.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## indicates which method is used to encode the apparatus of
  ## variants.
  attribute method {
    
    ## (apparatus uses line numbers or other canonical reference scheme
    ## referenced in a base text.) 
    "location-referenced"
    | 
      ## (apparatus indicates the precise locations of the beginning and
      ## ending of each lemma relative to a base text.) 
      "double-end-point"
    | 
      ## (alternate readings of a passage are given in parallel in the
      ## text; no notion of a base text is necessary.) 
      "parallel-segmentation"
  },
  
  ## indicates whether the apparatus appears within the running text
  ## or external to it.
  attribute location {
    
    ## (apparatus appears within the running text.) 
    "internal"
    | 
      ## (apparatus appears outside the base text.) 
      "external"
  },
  empty
profileDesc =
  
  ## (text-profile description) provides a detailed description of non-bibliographic aspects of a
  ## text, specifically the languages and sublanguages used, the situation in
  ## which it was produced, the participants and their setting.
  element profileDesc { profileDesc.content, profileDesc.attributes }
profileDesc.content = creation?, model.profileDescPart*
profileDesc.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
creation =
  
  ## contains information about the creation of a text.
  element creation { creation.content, creation.attributes }
creation.content = macro.phraseSeq
creation.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
langUsage =
  
  ## (language usage) describes the languages, sublanguages, registers, dialects etc.
  ## represented within a text.
  element langUsage { langUsage.content, langUsage.attributes }
langUsage.content = language+
langUsage.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
language =
  
  ## characterizes a single language or sublanguage used within a
  ##   text.
  element language { language.content, language.attributes }
language.content = macro.phraseSeq
language.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## Supplies a language code constructed as defined in RFC 3066 (or
  ##       its successor) which is used to identify the language documented
  ##       by this element, and which is referenced by the global xml:lang attribute.
  attribute ident { data.language },
  
  ## specifies the approximate percentage (by volume) of the
  ##       text which uses this language.
  ##       
  attribute usage {
    xsd:nonNegativeInteger { maxInclusive = "100" }
  }?,
  empty
textClass =
  
  ## (text classification) groups information which describes the nature or topic of a text
  ## in terms of a standard classification scheme, thesaurus, etc.
  element textClass { textClass.content, textClass.attributes }
textClass.content = (classCode | catRef | keywords)*
textClass.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declarable.attribute.default,
  empty
keywords =
  
  ## contains a list of keywords or phrases identifying the topic or
  ## nature of a text.
  element keywords { keywords.content, keywords.attributes }
keywords.content = term+ | \list
keywords.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## identifies the controlled vocabulary within which the set of
  ##   keywords concerned is defined.
  ##    
  attribute scheme { data.pointer },
  empty
classCode =
  
  ## contains the classification code used for this text in some
  ## standard classification system.
  element classCode { classCode.content, classCode.attributes }
classCode.content = macro.phraseSeq
classCode.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## identifies the classification system or taxonomy in use.
  attribute scheme { data.pointer },
  empty
catRef =
  
  ## (category reference) specifies one or more defined categories
  ## within some taxonomy or text typology.
  element catRef { catRef.content, catRef.attributes }
catRef.content = empty
catRef.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## identifies the categories concerned
  ##    
  attribute target {
    list { data.pointer+ }
  },
  
  ## identifies the classification scheme within which the set of
  ##     categories concerned is defined
  ##    
  attribute scheme { data.pointer }?,
  empty
revisionDesc =
  
  ## (revision description) summarizes the revision history for a file.
  element revisionDesc { revisionDesc.content, revisionDesc.attributes }
revisionDesc.content = \list | change+
revisionDesc.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
change =
  
  ## summarizes a particular change or correction made
  ## to a particular version of an electronic text which is
  ## shared between several researchers.
  element change { change.content, change.attributes }
change.content = macro.specialPara
change.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.ascribed.attribute.who,
  
  ## supplies the date of the change in standard form,  i.e. yyyy-mm-dd.
  attribute date { data.temporal }?,
  empty
model.headerPart = encodingDesc | profileDesc
model.headerPart_sequence = encodingDesc, profileDesc
model.headerPart_sequenceOptional = encodingDesc?, profileDesc?
model.headerPart_sequenceOptionalRepeatable =
  encodingDesc*, profileDesc*
model.headerPart_sequenceRepeatable = encodingDesc+, profileDesc+
model.sourceDescPart = scriptStmt | recordingStmt
model.sourceDescPart_sequence = scriptStmt, recordingStmt
model.sourceDescPart_sequenceOptional = scriptStmt?, recordingStmt?
model.sourceDescPart_sequenceOptionalRepeatable =
  scriptStmt*, recordingStmt*
model.sourceDescPart_sequenceRepeatable = scriptStmt+, recordingStmt+
model.encodingPart =
  projectDesc
  | samplingDecl
  | editorialDecl
  | tagsDecl
  | refsDecl
  | classDecl
  | fsdDecl
  | metDecl
  | variantEncoding
model.encodingPart_sequence =
  projectDesc,
  samplingDecl,
  editorialDecl,
  tagsDecl,
  refsDecl,
  classDecl,
  fsdDecl,
  metDecl,
  variantEncoding
model.encodingPart_sequenceOptional =
  projectDesc?,
  samplingDecl?,
  editorialDecl?,
  tagsDecl?,
  refsDecl?,
  classDecl?,
  fsdDecl?,
  metDecl?,
  variantEncoding?
model.encodingPart_sequenceOptionalRepeatable =
  projectDesc*,
  samplingDecl*,
  editorialDecl*,
  tagsDecl*,
  refsDecl*,
  classDecl*,
  fsdDecl*,
  metDecl*,
  variantEncoding*
model.encodingPart_sequenceRepeatable =
  projectDesc+,
  samplingDecl+,
  editorialDecl+,
  tagsDecl+,
  refsDecl+,
  classDecl+,
  fsdDecl+,
  metDecl+,
  variantEncoding+
model.editorialDeclPart =
  correction
  | normalization
  | quotation
  | hyphenation
  | segmentation
  | stdVals
  | interpretation
model.editorialDeclPart_sequence =
  correction,
  normalization,
  quotation,
  hyphenation,
  segmentation,
  stdVals,
  interpretation
model.editorialDeclPart_sequenceOptional =
  correction?,
  normalization?,
  quotation?,
  hyphenation?,
  segmentation?,
  stdVals?,
  interpretation?
model.editorialDeclPart_sequenceOptionalRepeatable =
  correction*,
  normalization*,
  quotation*,
  hyphenation*,
  segmentation*,
  stdVals*,
  interpretation*
model.editorialDeclPart_sequenceRepeatable =
  correction+,
  normalization+,
  quotation+,
  hyphenation+,
  segmentation+,
  stdVals+,
  interpretation+
model.profileDescPart = langUsage | textClass
model.profileDescPart_sequence = langUsage, textClass
model.profileDescPart_sequenceOptional = langUsage?, textClass?
model.profileDescPart_sequenceOptionalRepeatable =
  langUsage*, textClass*
model.profileDescPart_sequenceRepeatable = langUsage+, textClass+
TEI =
  
  ## (TEI document) contains a single TEI-conformant document,
  ## comprising a TEI header and a text, either in isolation or as part of a
  ## teiCorpus element.
  element TEI { TEI.content, TEI.attributes }
TEI.content = teiHeader, \text
TEI.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## The version of the TEI scheme
  [ a1:defaultValue = "5.0" ] attribute version { xsd:decimal }?,
  empty
\text =
  
  ## contains a single text of any kind, whether unitary or
  ## composite, for example a poem or drama, a collection of essays, a novel,
  ## a dictionary, or a corpus sample.
  element text { text.content, text.attributes }
text.content =
  model.global*,
  (front, model.global*)?,
  (body | group),
  model.global*,
  (back, model.global*)?
text.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declaring.attribute.decls,
  empty
body =
  
  ## (text body) contains the whole body of a single unitary text, excluding any front or back matter.
  element body { body.content, body.attributes }
body.content =
  model.global*,
  (model.divWrapper, (model.global | model.divWrapper)*)?,
  (model.divGenLike, (model.global | model.divGenLike)*)?,
  ((model.divLike, (model.global | model.divGenLike)*)+
   | (model.div1Like, (model.global | model.divGenLike)*)+
   | ((macro.component, model.global*)+,
      ((model.divLike, (model.global | model.divGenLike)*)+
       | (model.div1Like, (model.global | model.divGenLike)*)+)?)),
  (model.divWrapper.bottom, model.global*)*
body.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declaring.attribute.decls,
  empty
group =
  
  ## contains the body of a composite text, grouping together a
  ## sequence of distinct texts (or groups of such texts) which are regarded
  ## as a unit for some purpose, for example the collected works of an
  ## author, a sequence of prose essays, etc.
  element group { group.content, group.attributes }
group.content =
  (model.divWrapper | model.global)*,
  ((\text | group), (\text | group | model.global)*),
  model.divWrapper.bottom*
group.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declaring.attribute.decls,
  empty
\div =
  
  ## (text division) contains a subdivision of the front, body, or back of a
  ## text.
  element div { div.content, div.attributes }
div.content =
  (model.divWrapper | model.global)*,
  ((((\div | divGen), model.global*)+
    | ((macro.component, model.global*)+,
       ((\div | divGen), model.global*)*)),
   ((model.divWrapper | model.divWrapper.bottom), model.global*)*)?
div.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
div1 =
  
  ## (level-1 text division) contains a first-level subdivision of the front, body, or back
  ## of a text.
  element div1 { div1.content, div1.attributes }
div1.content =
  (model.divWrapper | model.global)*,
  (((model.div2Like | model.divGenLike), model.global*)+
   | ((macro.component, model.global*)+,
      ((model.div2Like | model.divGenLike), model.global*)*)),
  ((model.divWrapper | model.divWrapper.bottom), model.global*)*
div1.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
div2 =
  
  ## (level-2 text division) contains a second-level subdivision of the front, body, or back of a
  ##  text.
  element div2 { div2.content, div2.attributes }
div2.content =
  (model.divWrapper | model.global)*,
  (((model.div3Like | model.divGenLike), model.global*)+
   | ((macro.component, model.global*)+,
      ((model.div3Like | model.divGenLike), model.global*)*)),
  ((model.divWrapper | model.divWrapper.bottom), model.global*)*
div2.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
div3 =
  
  ## (level-3 text division) contains a third-level subdivision of the front, body, or back of a
  ##  text.
  element div3 { div3.content, div3.attributes }
div3.content =
  (model.divWrapper | model.global)*,
  (((model.div4Like | model.divGenLike), model.global*)+
   | ((macro.component, model.global*)+,
      ((model.div4Like | model.divGenLike), model.global*)*)),
  ((model.divWrapper | model.divWrapper.bottom), model.global*)*
div3.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
div4 =
  
  ## (level-4 text division) contains a fourth-level subdivision of the front, body, or back of a
  ##  text.
  element div4 { div4.content, div4.attributes }
div4.content =
  (model.divWrapper | model.global)*,
  (((model.div5Like | model.divGenLike), model.global*)+
   | ((macro.component, model.global*)+,
      ((model.div5Like | model.divGenLike), model.global*)*)),
  ((model.divWrapper | model.divWrapper.bottom), model.global*)*
div4.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
div5 =
  
  ## (level-5 text division) contains a fifth-level subdivision of the front, body, or back of a
  ##  text.
  element div5 { div5.content, div5.attributes }
div5.content =
  (model.divWrapper | model.global)*,
  (((model.div6Like | model.divGenLike), model.global*)+
   | ((macro.component, model.global*)+,
      ((model.div6Like | model.divGenLike), model.global*)*)),
  ((model.divWrapper | model.divWrapper.bottom), model.global*)*
div5.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
div6 =
  
  ## (level-6 text division) contains a sixth-level subdivision of the front, body, or back of a
  ##  text.
  element div6 { div6.content, div6.attributes }
div6.content =
  (model.divWrapper | model.global)*,
  (((model.div7Like | model.divGenLike), model.global*)+
   | ((macro.component, model.global*)+,
      ((model.div7Like | model.divGenLike), model.global*)*)),
  ((model.divWrapper | model.divWrapper.bottom), model.global*)*
div6.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
div7 =
  
  ## (level-7 text division) contains the smallest possible subdivision of the front, body or
  ## back of a text, larger than a paragraph.
  element div7 { div7.content, div7.attributes }
div7.content =
  (model.divWrapper | model.global)*,
  (macro.component, model.global*)+,
  ((model.divWrapper | model.divWrapper.bottom), model.global*)*
div7.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
trailer =
  
  ## (trailer) contains a closing title or footer appearing at the end of
  ## a division of a text. 
  element trailer { trailer.content, trailer.attributes }
trailer.content = macro.phraseSeq
trailer.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
byline =
  
  ## contains the primary statement of responsibility given for a work
  ## on its title page or at the head or end of the work.
  element byline { byline.content, byline.attributes }
byline.content =
  (text | model.gLike | model.phrase | docAuthor | model.global)*
byline.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
dateline =
  
  ## contains a brief description of the place, date, time, etc. of
  ##	production of a letter, newspaper story, or other work, prefixed or
  ##	suffixed to it as a kind of heading or trailer. 
  element dateline { dateline.content, dateline.attributes }
dateline.content = macro.phraseSeq
dateline.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
argument =
  
  ## A formal list or prose description of the topics addressed by
  ##	a subdivision of a text.
  element argument { argument.content, argument.attributes }
argument.content =
  model.global*,
  (head, model.global*)?,
  (macro.component, model.global*)+
argument.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
epigraph =
  
  ## (epigraph) contains a quotation, anonymous or attributed, appearing at
  ## the start of a section or chapter, or on a title page. 
  element epigraph { epigraph.content, epigraph.attributes }
epigraph.content = macro.componentSeq
epigraph.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
opener =
  
  ## groups together dateline, byline, salutation, and similar
  ## phrases appearing as a preliminary group at the start of a
  ## division, especially of a letter.
  element opener { opener.content, opener.attributes }
opener.content =
  (text
   | model.gLike
   | model.phrase
   | argument
   | byline
   | dateline
   | epigraph
   | salute
   | signed
   | model.global)*
opener.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
closer =
  
  ## groups together dateline, byline, salutation, and similar
  ## phrases appearing as a final group at the end of a
  ## division, especially of a letter.
  element closer { closer.content, closer.attributes }
closer.content =
  (text
   | model.gLike
   | signed
   | dateline
   | salute
   | model.phrase
   | model.global)*
closer.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
salute =
  
  ## (salutation) contains a salutation or greeting prefixed to a foreword,
  ## dedicatory epistle, or other division of a text, or the
  ## salutation in the closing of a letter, preface, etc.
  element salute { salute.content, salute.attributes }
salute.content = macro.phraseSeq
salute.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
signed =
  
  ## (signature) contains the closing salutation, etc., appended to a foreword,
  ## dedicatory epistle, or other division of a text. 
  element signed { signed.content, signed.attributes }
signed.content = macro.phraseSeq
signed.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
titlePage =
  
  ## (title page) contains the title page of a text, appearing within the front
  ## or back matter. 
  element titlePage { titlePage.content, titlePage.attributes }
titlePage.content =
  model.global*,
  model.titlepagePart,
  (model.titlepagePart | model.global)*
titlePage.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## classifies the title page according to any convenient typology.
  attribute type { data.enumerated }?,
  empty
docTitle =
  
  ## (document title) contains the title of a document, including all its
  ## constituents, as given on a title page.
  element docTitle { docTitle.content, docTitle.attributes }
docTitle.content = model.global*, (titlePart, model.global*)+
docTitle.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
titlePart =
  
  ## (title part) contains a subsection or division of the title of a work, as
  ## indicated on a title page.
  element titlePart { titlePart.content, titlePart.attributes }
titlePart.content = macro.paraContent
titlePart.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## specifies the role of this subdivision of the title.
  ## Suggested values include: 1] main (main title of the work
  ##         ); 2] sub (subtitle  of the work
  ##         ); 3] alt (alternative title  of the work
  ##         ); 4] short (abbreviated form of title); 5] desc (descriptive paraphrase of the work 
  ##    )
  [ a1:defaultValue = "main" ] attribute type { data.enumerated }?,
  empty
docAuthor =
  
  ## (document author) contains the name of the author of the document, as given on the
  ## title page (often but not always contained in a byline).
  element docAuthor { docAuthor.content, docAuthor.attributes }
docAuthor.content = macro.phraseSeq
docAuthor.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
imprimatur =
  
  ## contains a formal statement authorizing the publication of
  ## a work, sometimes required to appear on a title page or its verso.
  element imprimatur { imprimatur.content, imprimatur.attributes }
imprimatur.content = macro.paraContent
imprimatur.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
docEdition =
  
  ## (document edition) contains an edition statement as presented on a title page of a
  ## document.
  element docEdition { docEdition.content, docEdition.attributes }
docEdition.content = macro.paraContent
docEdition.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
docImprint =
  
  ## (document imprint) contains the imprint statement (place and date of publication,
  ## publisher name), as given
  ## (usually) at the foot of a title page.
  element docImprint { docImprint.content, docImprint.attributes }
docImprint.content =
  (text
   | model.gLike
   | model.phrase
   | pubPlace
   | docDate
   | publisher
   | model.global)*
docImprint.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
docDate =
  
  ## (document date) contains the date of a document, as given
  ## (usually) on a title page.
  element docDate { docDate.content, docDate.attributes }
docDate.content = macro.phraseSeq
docDate.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## gives the value of the date in a standard form, generally YYYY-MM-DD.
  attribute value { data.temporal }?,
  empty
front =
  
  ## (front matter) contains any prefatory matter (headers,
  ## title page, prefaces, dedications, etc.)
  ## found  at the start of a document, before the main body.
  element front { front.content, front.attributes }
front.content =
  (model.frontPart | model.pLike.front | model.global)*,
  ((model.div1Like, (model.frontPart | model.div1Like | model.global)*)
   | (model.divLike,
      (model.frontPart | model.divLike | model.global)*))?
front.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declaring.attribute.decls,
  empty
back =
  
  ## (back matter) contains any appendixes, etc. following the main part of a
  ## text.
  element back { back.content, back.attributes }
back.content =
  (model.frontPart | model.global | model.divWrapper)*,
  ((model.divLike, (model.global | model.frontPart)*)+
   | (model.div1Like, (model.global | model.frontPart)*)+)?,
  model.divWrapper.bottom*
back.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.declaring.attribute.decls,
  empty
link =
  
  ## defines an association or hypertextual link
  ## among elements or passages, of some type
  ## not more precisely specifiable by other elements.
  element link { link.content, link.attributes }
link.content = empty
link.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.pointing.attribute.type,
  att.pointing.attribute.evaluate,
  
  ## specifies the identifiers of the elements or passages
  ##     to be linked or associated.
  ##  
  attribute targets {
    list { data.pointer, data.pointer+ }
  },
  empty
linkGrp =
  
  ## defines a collection of associations or hypertextual links.
  element linkGrp { linkGrp.content, linkGrp.attributes }
linkGrp.content = (link | ptr)+
linkGrp.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.pointing.group.attribute.domains,
  att.pointing.group.attribute.targFunc,
  att.pointing.attribute.type,
  att.pointing.attribute.evaluate,
  empty
ab =
  
  ## (anonymous block) contains any arbitrary component-level unit of text, acting as
  ## an anonymous container for phrase or inter level elements analogous to, but
  ## without the semantic baggage of, a paragraph.
  element ab { ab.content, ab.attributes }
ab.content = macro.paraContent
ab.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  
  ## specifies whether or not the block is complete. 
  [ a1:defaultValue = "N" ]
  attribute part {
    
    ## (the block is incomplete) 
    "Y"
    | 
      ## (either the block is complete, or no claim is made as to its
      ## completeness) 
      "N"
    | 
      ## (the initial part of an incomplete block) 
      "I"
    | 
      ## (a medial part of an incomplete block) 
      "M"
    | 
      ## (the final part of an incomplete block) 
      "F"
  }?,
  empty
anchor =
  
  ## (anchor point) attaches an identifier to a
  ## point within a text, whether or not it corresponds with a textual
  ## element.
  element anchor { anchor.content, anchor.attributes }
anchor.content = empty
anchor.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  empty
seg =
  
  ## (arbitrary segment) contains any arbitrary phrase-level unit of text (including
  ## other seg elements).
  element seg { seg.content, seg.attributes }
seg.content = macro.paraContent
seg.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.segLike.attribute.type,
  att.segLike.attribute.function,
  att.segLike.attribute.part,
  
  ## provides a sub-categorization of the segment marked.
  attribute subtype { data.word }?,
  empty
when =
  
  ## (when) indicates a point in time either relative to other elements in the
  ## same timeline tag, or absolutely.
  element when { when.content, when.attributes }
when.content = empty
when.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## supplies an absolute value for the time.
  attribute absolute { data.temporal }?,
  
  ## specifies the unit of time in which the  interval
  ## value is expressed, if this is not inherited from the parent timeLine.
  ## Suggested values include: 1] s (seconds); 2] ms (milliseconds); 3] m (minutes); 4] h (hours); 5] d (days)
  attribute unit { data.enumerated }?,
  
  ## specifies the numeric portion of a time interval
  attribute interval {
    xsd:float { minExclusive = "0" }
    | "unknown"
  }?,
  
  ## identifies the reference point for determining the time of the
  ## current when element, which is obtained by adding the interval to the
  ## time of the reference point.
  attribute since { data.pointer }?,
  empty
timeline =
  
  ## (timeline) provides a set of ordered points in time which can be linked to
  ## elements of a spoken text to create a temporal alignment of that text.
  element timeline { timeline.content, timeline.attributes }
timeline.content = when+
timeline.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## designates the origin of the timeline, i.e. the time at which it
  ## begins.
  attribute origin { data.pointer },
  
  ## specifies the unit of time corresponding to the
  ##	interval value of the timeline or of its
  ##	constituent points in time.
  ## Suggested values include: 1] d (days); 2] h (hours); 3] m (minutes); 4] s (seconds); 5] ms (milliseconds)
  attribute unit { data.enumerated }?,
  
  ## specifies the numeric portion of a time interval
  attribute interval {
    xsd:float { minExclusive = "0" }
    | "regular"
    | "irregular"
  }?,
  empty
join =
  
  ## identifies a possibly fragmented segment of text, by pointing
  ## at the possibly discontiguous elements which compose it.
  element join { join.content, join.attributes }
join.content = macro.glossSeq
join.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.pointing.attribute.type,
  att.pointing.attribute.evaluate,
  
  ## specifies the identifiers of the elements or passages
  ##        to be joined into a virtual
  ##        element.
  attribute targets {
    list { data.pointer, data.pointer+ }
  },
  
  ## specifies the name of an element
  ## which this aggregation
  ## may be understood to represent.
  attribute result { data.name }?,
  
  ## indicates whether the targets to be joined include the
  ## entire element indicated (the entire subtree including its root),
  ## or just the children of the target (the branches of the subtree).
  [ a1:defaultValue = "root" ]
  attribute scope {
    
    ## (the rooted subtrees indicated by the targets
    ## attribute are joined, each subtree become a child of the virtual
    ## element created by the join) 
    "root"
    | 
      ## (the children of the subtrees indicated by the
      ## targets attribute become the children of the virtual element
      ## (i.e. the roots of the subtrees are discarded)) 
      "branches"
  }?,
  empty
joinGrp =
  
  ## (join group) groups a collection of join elements and possibly
  ##   pointers.
  element joinGrp { joinGrp.content, joinGrp.attributes }
joinGrp.content = macro.glossSeq?, (join | ptr)+
joinGrp.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.pointing.group.attribute.domains,
  att.pointing.group.attribute.targFunc,
  att.pointing.attribute.type,
  att.pointing.attribute.evaluate,
  
  ## describes the result of the joins gathered in this collection.
  attribute result { data.name }?,
  empty
alt =
  
  ## (alternation) identifies an alternation or a set of choices among elements or passages.
  element alt { alt.content, alt.attributes }
alt.content = empty
alt.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.pointing.attribute.type,
  att.pointing.attribute.evaluate,
  
  ## specifies the identifiers of the alternative elements or passages.
  attribute targets {
    list { data.pointer, data.pointer+ }
  },
  
  ## states whether the alternations gathered in this collection are exclusive or inclusive.
  attribute mode {
    
    ## (indicates that the alternation is exclusive, i.e. that
    ##		  at most one of the alternatives occurs.) 
    "excl"
    | 
      ## (indicates that the alternation is not exclusive, i.e. that
      ##		  one or more of the alternatives occur.) 
      "incl"
  }?,
  
  ## If mode is excl, each weight
  ##       states the probability that the corresponding alternative
  ##       occurs. If modeincl each weight states
  ##       the probability that the corresponding alternative occurs given
  ##       that at least one of the other alternatives occurs.
  attribute weights {
    list { data.probability+ }
  }?,
  empty
altGrp =
  
  ## (alternation group) groups a collection of alt elements and possibly
  ## pointers.
  element altGrp { altGrp.content, altGrp.attributes }
altGrp.content = (alt | ptr)*
altGrp.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.pointing.group.attribute.domains,
  att.pointing.group.attribute.targFunc,
  att.pointing.attribute.type,
  att.pointing.attribute.evaluate,
  
  ## states whether the alternations gathered in this collection are
  ## exclusive or inclusive.
  [ a1:defaultValue = "excl" ]
  attribute mode {
    
    ## (indicates that the alternation is exclusive, i.e. that at
    ## most one of the alternatives occurs.) 
    "excl"
    | 
      ## (indicates that the alternation is not exclusive, i.e. that
      ## one or more of the alternatives occur.) 
      "incl"
  }?,
  empty
att.global.linking.attributes =
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
att.global.linking.attribute.next =
  
  ## points to the next element of a virtual aggregate of which
  ##       the current element is part.
  attribute next { data.pointer }?
att.global.linking.attribute.prev =
  
  ## points to the previous element of a virtual aggregate of
  ##       which the current element is part.
  attribute prev { data.pointer }?
att.pointing.attributes =
  att.pointing.attribute.type, att.pointing.attribute.evaluate, empty
att.pointing.attribute.type =
  
  ## categorizes the pointer in some respect, using any
  ##       convenient set of categories.
  attribute type { data.word }?
att.pointing.attribute.evaluate =
  
  ## specifies the intended meaning when the target of a
  ##       pointer is itself a pointer.
  attribute evaluate {
    
    ## (if the element pointed to is itself a pointer, then
    ##	  the target of that pointer will be taken, and so on, until
    ##	  an element is found which is not a pointer.) 
    "all"
    | 
      ## (if the element pointed to is itself a pointer, then
      ##	  its target (whether a pointer or not) is taken as the target
      ##	  of this pointer.) 
      "one"
    | 
      ## (no further evaluation of targets is carried out
      ##	  beyond that needed to find the element specified in the
      ##	  pointer's target.) 
      "none"
  }?
att.pointing.group.attributes =
  att.pointing.group.attribute.domains,
  att.pointing.group.attribute.targFunc,
  empty
att.pointing.group.attribute.domains =
  
  ## optionally specifies the identifiers of the elements
  ##       within which all elements indicated by the contents of this
  ##       element lie.
  attribute domains {
    list { data.name+ }
  }?
att.pointing.group.attribute.targFunc =
  
  ## describes the function of each of the values of the
  ##       targets attribute of the enclosed link,
  ##       join or alt tags.
  attribute targFunc {
    list { data.word+ }
  }?
set =
  
  ## contains a description of the setting, time, locale, appearance,
  ## etc., of the action of a play, typically found in the front matter of
  ## a printed performance text (not a stage direction).
  element set { set.content, set.attributes }
set.content = model.global*, head?, (macro.component, model.global*)*
set.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
prologue =
  
  ## contains the prologue to a drama,  typically spoken by an actor out of
  ## character, possibly in association with a particular performance or venue.
  element prologue { prologue.content, prologue.attributes }
prologue.content =
  (model.divWrapper | model.global)*,
  (macro.component, model.global*)+,
  (model.divWrapper.bottom, model.global*)*
prologue.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
epilogue =
  
  ## contains the epilogue to a drama,  typically spoken by an actor
  ## out of character, possibly in association with a particular performance
  ## or venue.
  element epilogue { epilogue.content, epilogue.attributes }
epilogue.content =
  (model.divWrapper | model.global)*,
  (macro.component, model.global*)+,
  (model.divWrapper.bottom, model.global*)*
epilogue.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
performance =
  
  ## contains a section of front or back matter describing how a
  ## dramatic piece is to be performed in general or how it was performed
  ## on some specific occasion. 
  element performance { performance.content, performance.attributes }
performance.content =
  (model.divWrapper | model.global)*,
  (macro.component, model.global*)+,
  (model.divWrapper.bottom, model.global*)*
performance.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
castList =
  
  ## (cast list) contains a single cast list or dramatis personae.
  element castList { castList.content, castList.attributes }
castList.content =
  (model.divWrapper | model.global)*,
  (macro.component, model.global*)*,
  ((castItem | castGroup), model.global*)+,
  (macro.component, model.global*)*
castList.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
castGroup =
  
  ## (Cast list grouping) groups one or more individual castItem
  ## elements within a cast list.
  element castGroup { castGroup.content, castGroup.attributes }
castGroup.content =
  model.global*,
  (head, model.global*)?,
  ((castItem | castGroup | roleDesc), model.global*)+,
  (trailer, model.global*)?
castGroup.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
castItem =
  
  ## (Cast list item) contains a single entry within a cast list, describing
  ## either a single role or a list of non-speaking roles.
  element castItem { castItem.content, castItem.attributes }
castItem.content =
  (text
   | model.gLike
   | model.castItemPart
   | model.phrase
   | model.global)*
castItem.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## characterizes the cast item.
  ##    
  [ a1:defaultValue = "role" ]
  attribute type {
    
    ## (the item describes a single role.
    ##        ) 
    "role"
    | 
      ## (the item describes a list of non-speaking roles.
      ##    ) 
      "list"
  }?,
  empty
role =
  
  ## the name of a dramatic role, as given in a cast list.
  element role { role.content, role.attributes }
role.content = macro.phraseSeq
role.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
roleDesc =
  
  ## (role description) describes a character's role in a drama.
  element roleDesc { roleDesc.content, roleDesc.attributes }
roleDesc.content = macro.phraseSeq
roleDesc.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
actor =
  
  ## (actor) Name of an actor appearing within a cast list.
  element actor { actor.content, actor.attributes }
actor.content = macro.phraseSeq
actor.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
move =
  
  ## (Movement) marks the actual entrance or exit of one or more characters on stage.
  element move { move.content, move.attributes }
move.content = empty
move.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.ascribed.attribute.who,
  
  ## characterizes the movement, for example as an entrance or exit.
  ## Suggested values include: 1] entrance (character is entering the stage.); 2] exit (character is exiting the stage.); 3] onstage (character moves on stage)
  attribute type { data.enumerated }?,
  
  ## specifies the direction of a stage movement.
  ## Sample values include: 1] L (stage left); 2] R (stage right); 3] C (centre stage)
  attribute where {
    list { data.enumerated+ }
  }?,
  
  ## identifies the performance or performances in which this movement
  ##		occurred as specified.
  attribute perf {
    list { data.pointer+ }
  }?,
  empty
view =
  
  ## describes the visual context of some part of a screen play in
  ## terms of what the spectator sees, generally independent of any
  ## dialogue.
  element view { view.content, view.attributes }
view.content = macro.specialPara
view.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
camera =
  
  ## describes a particular camera angle or viewpoint in a screen play.
  element camera { camera.content, camera.attributes }
camera.content = macro.paraContent
camera.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  empty
sound =
  
  ## describes a sound effect or musical sequence specified within a
  ## screen play or radio script.
  element sound { sound.content, sound.attributes }
sound.content = macro.paraContent
sound.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## categorizes the sound in some respect, e.g. as music, special
  ## effect, etc.
  attribute type { data.enumerated }?,
  
  ## indicates whether the sound overlaps the surrounding speeches
  ## or interrupts them.
  [ a1:defaultValue = "unknown" ]
  attribute discrete {
    
    ## (the sound is heard between the surrounding speeches) 
    "true"
    | 
      ## (the sound overlaps the surrounding speeches) 
      "false"
    | 
      ## (unknown or inapplicable) 
      "unknown"
  }?,
  empty
caption =
  
  ## contains the text of a caption or other text displayed as part of
  ## a film script or screenplay.
  element caption { caption.content, caption.attributes }
caption.content = macro.paraContent
caption.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  empty
tech =
  
  ## (Technical stage direction) describes a special-purpose stage direction that is not
  ## meant for the actors.
  element tech { tech.content, tech.attributes }
tech.content = macro.paraContent
tech.attributes =
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.linking.attribute.next,
  att.global.linking.attribute.prev,
  
  ## categorizes the technical stage direction.
  attribute type {
    
    ## (a lighting cue) 
    "light"
    | 
      ## (a sound cue) 
      "sound"
    | 
      ## (a prop cue) 
      "prop"
    | 
      ## (a blocking instruction) 
      "block"
  }?,
  
  ## identifies the performance or performances to which this
  ## technical direction applies.
  attribute perf { data.enumerated }?,
  empty
model.divPart.stage = model.stageLike | castList
model.divPart.stage_sequence = model.stageLike, castList
model.divPart.stage_sequenceOptional = model.stageLike?, castList?
model.divPart.stage_sequenceOptionalRepeatable =
  model.stageLike*, castList*
model.divPart.stage_sequenceRepeatable = model.stageLike+, castList+
start = TEI
