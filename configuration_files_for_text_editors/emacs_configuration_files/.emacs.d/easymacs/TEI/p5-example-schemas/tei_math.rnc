default namespace = "http://www.w3.org/1998/Math/MathML"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace a1 = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace ns1 = "http://www.tei-c.org/ns/1.0"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace teix = "http://www.tei-c.org/ns/Examples"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2007-03-13T16:05:05Z.

# 
# This template file is freely available and you are hereby
#             authorised to copy, modify, and redistribute it in any way without
#             further reference or permissions.
# When making such modifications, you are strongly recommended to
#             change the present text to include an accurate statement of the
#             licencing conditions applicable to your modified text.
div {
  # MathML 2.0 DTD  .......................................................
  
  # file: mathml2.dtd
  
  # MathML 2.0 DTD
  # 
  # This is the Mathematical Markup Language (MathML) 2.0, an XML
  # application for describing mathematical notation and capturing
  # both its structure and content.
  # 
  # Copyright 1998-2002 World Wide Web Consortium
  #    (Massachusetts Institute of Technology, Institut National de
  #     Recherche en Informatique et en Automatique, Keio University).
  #     All Rights Reserved.
  # 
  # Permission to use, copy, modify and distribute the MathML 2.0 DTD and
  # its accompanying documentation for any purpose and without fee is
  # hereby granted in perpetuity, provided that the above copyright notice
  # and this paragraph appear in all copies.  The copyright holders make
  # no representation about the suitability of the DTD for any purpose.
  # 
  # It is provided "as is" without expressed or implied warranty.
  # 
  #    Revision:   $Id: mathml2-main.rng 492 2005-06-24 20:30:39Z rahtz $
  # 
  # This entity may be identified by the PUBLIC and SYSTEM identifiers:
  # 
  #   PUBLIC "-//W3C//DTD MathML 2.0//EN"
  #   SYSTEM "mathml2.dtd"
  # 
  # Revisions: editor and revision history at EOF
  
  # MathML Qualified Names module ...............................
  
  # Start of import of mathml2-qname-1.mod.rng
  div {
    # .......................................................................
    
    # MathML Qualified Names Module  ........................................
    
    # file: mathml2-qname-1.mod
    # 
    # This is the Mathematical Markup Language (MathML) 2.0, an XML 
    # application for describing mathematical notation and capturing 
    # both its structure and content.
    # 
    # Copyright 1998-2000 W3C (MIT, INRIA, Keio), All Rights Reserved.
    # Revision: $Id: mathml2-qname-1.mod.rng 1784 2006-10-06 08:23:45Z rahtz $ 
    # 
    # This DTD module is identified by the PUBLIC and SYSTEM identifiers:
    # 
    #   PUBLIC "-//W3C//ENTITIES MathML 2.0 Qualified Names 1.0//EN"
    #   SYSTEM "mathml2-qname-1.mod"
    # 
    # Revisions:
    # (none)
    # .......................................................................
    
    # MathML Qualified Names
    # 
    # This module is contained in two parts, labeled Section 'A' and 'B':
    # 
    #   Section A declares parameter entities to support namespace-
    #   qualified names, namespace declarations, and name prefixing 
    #   for MathML.
    # 
    #   Section B declares parameter entities used to provide
    #   namespace-qualified names for all MathML element types.
    # 
    # This module is derived from the XHTML Qualified Names Template module.
    
    # Section A: XHTML XML Namespace Framework ::::::::::::::::::::
    
    # XLink ...............
    math_XLINK.xmlns.attrib = empty
    # MathML ..............
    MATHML.xmlns.extra.attrib = math_XLINK.xmlns.attrib
    MATHML.xmlns.attrib = empty, MATHML.xmlns.extra.attrib
  }
  # End of import of mathml2-qname-1.mod.rng
  
  # if %NS.prefixed; is INCLUDE, include all NS attributes, 
  # otherwise just those associated with MathML
  MATHML.NamespaceDecl.attrib = MATHML.xmlns.attrib
  # Attributes shared by all elements  ..........................
  MATHML.Common.attrib =
    MATHML.NamespaceDecl.attrib,
    attribute xlink:href { text }?,
    attribute xlink:type { text }?,
    attribute class { text }?,
    attribute style { text }?,
    attribute id { xsd:ID }?,
    attribute xref { xsd:IDREF }?,
    attribute other { text }?
  # Presentation element set  ...................................
  
  # Attribute definitions
  mathml.att-fontsize = attribute fontsize { text }?
  mathml.att-fontweight = attribute fontweight { "normal" | "bold" }?
  mathml.att-fontstyle = attribute fontstyle { "normal" | "italic" }?
  mathml.att-fontfamily = attribute fontfamily { text }?
  mathml.att-color = attribute color { text }?
  # MathML2 typographically-distinguished symbol attributes
  mathml.att-mathvariant = attribute mathvariant { text }?
  mathml.att-mathsize = attribute mathsize { text }?
  mathml.att-mathcolor = attribute mathcolor { text }?
  mathml.att-mathbackground = attribute mathbackground { text }?
  mathml.att-fontinfo =
    mathml.att-fontsize,
    mathml.att-fontweight,
    mathml.att-fontstyle,
    mathml.att-fontfamily,
    mathml.att-color,
    mathml.att-mathvariant,
    mathml.att-mathsize,
    mathml.att-mathcolor,
    mathml.att-mathbackground
  mathml.att-form = attribute form { "prefix" | "infix" | "postfix" }?
  mathml.att-fence = attribute fence { "true" | "false" }?
  mathml.att-separator = attribute separator { "true" | "false" }?
  mathml.att-lspace = attribute lspace { text }?
  mathml.att-rspace = attribute rspace { text }?
  mathml.att-stretchy = attribute stretchy { "true" | "false" }?
  mathml.att-symmetric = attribute symmetric { "true" | "false" }?
  mathml.att-maxsize = attribute maxsize { text }?
  mathml.att-minsize = attribute minsize { text }?
  mathml.att-largeop = attribute largeop { "true" | "false" }?
  mathml.att-movablelimits =
    attribute movablelimits { "true" | "false" }?
  mathml.att-accent = attribute accent { "true" | "false" }?
  mathml.att-opinfo =
    mathml.att-form,
    mathml.att-fence,
    mathml.att-separator,
    mathml.att-lspace,
    mathml.att-rspace,
    mathml.att-stretchy,
    mathml.att-symmetric,
    mathml.att-maxsize,
    mathml.att-minsize,
    mathml.att-largeop,
    mathml.att-movablelimits,
    mathml.att-accent
  mathml.att-width = attribute width { text }?
  mathml.att-height = attribute height { text }?
  mathml.att-depth = attribute depth { text }?
  mathml.att-linebreak = attribute linebreak { text }?
  mathml.att-sizeinfo =
    mathml.att-width, mathml.att-height, mathml.att-depth
  mathml.att-lquote = attribute lquote { text }?
  mathml.att-rquote = attribute rquote { text }?
  mathml.att-linethickness = attribute linethickness { text }?
  mathml.att-scriptlevel = attribute scriptlevel { text }?
  mathml.att-displaystyle = attribute displaystyle { "true" | "false" }?
  mathml.att-scriptsizemultiplier =
    attribute scriptsizemultiplier { text }?
  mathml.att-scriptminsize = attribute scriptminsize { text }?
  mathml.att-background = attribute background { text }?
  mathml.att-veryverythinmathspace =
    attribute veryverythinmathspace { text }?
  mathml.att-verythinmathspace = attribute verythinmathspace { text }?
  mathml.att-thinmathspace = attribute thinmathspace { text }?
  mathml.att-mediummathspace = attribute mediummathspace { text }?
  mathml.att-thickmathspace = attribute thickmathspace { text }?
  mathml.att-verythickmathspace = attribute verythickmathspace { text }?
  mathml.att-veryverythickmathspace =
    attribute veryverythickmathspace { text }?
  mathml.att-open = attribute open { text }?
  mathml.att-close = attribute close { text }?
  mathml.att-separators = attribute separators { text }?
  mathml.att-subscriptshift = attribute subscriptshift { text }?
  mathml.att-superscriptshift = attribute superscriptshift { text }?
  mathml.att-accentunder = attribute accentunder { "true" | "false" }?
  mathml.att-align = attribute align { text }?
  mathml.att-numalign = attribute numalign { text }?
  mathml.att-denomalign = attribute denomalign { text }?
  mathml.att-rowalign = attribute rowalign { text }?
  mathml.att-columnalign = attribute columnalign { text }?
  mathml.att-columnwidth = attribute columnwidth { text }?
  mathml.att-groupalign = attribute groupalign { text }?
  mathml.att-alignmentscope = attribute alignmentscope { text }?
  mathml.att-rowspacing = attribute rowspacing { text }?
  mathml.att-columnspacing = attribute columnspacing { text }?
  mathml.att-rowlines = attribute rowlines { text }?
  mathml.att-columnlines = attribute columnlines { text }?
  mathml.att-frame = attribute frame { "none" | "solid" | "dashed" }?
  mathml.att-side =
    attribute side {
      "left" | "right" | "leftoverlap" | "rightoverlap"
    }?
  mathml.att-framespacing = attribute framespacing { text }?
  mathml.att-equalrows = attribute equalrows { text }?
  mathml.att-equalcolumns = attribute equalcolumns { text }?
  mathml.att-tableinfo =
    mathml.att-align,
    mathml.att-rowalign,
    mathml.att-columnalign,
    mathml.att-columnwidth,
    mathml.att-groupalign,
    mathml.att-alignmentscope,
    mathml.att-side,
    mathml.att-rowspacing,
    mathml.att-columnspacing,
    mathml.att-rowlines,
    mathml.att-columnlines,
    mathml.att-width,
    mathml.att-frame,
    mathml.att-framespacing,
    mathml.att-equalrows,
    mathml.att-equalcolumns,
    mathml.att-displaystyle
  mathml.att-rowspan = attribute rowspan { text }?
  mathml.att-columnspan = attribute columnspan { text }?
  mathml.att-edge = attribute edge { "left" | "right" }?
  mathml.att-actiontype = attribute actiontype { text }?
  mathml.att-selection = attribute selection { text }?
  mathml.att-name = attribute name { text }?
  mathml.att-alt = attribute alt { text }?
  mathml.att-index = attribute index { text }?
  mathml.att-bevelled = attribute bevelled { text }?
  # Presentation schemata with content
  mathml.ptoken =
    mathml.mi | mathml.mn | mathml.mo | mathml.mtext | mathml.ms
  mathml.attlist-mi &= MATHML.Common.attrib, mathml.att-fontinfo
  mathml.attlist-mn &= MATHML.Common.attrib, mathml.att-fontinfo
  mathml.attlist-mo &=
    MATHML.Common.attrib, mathml.att-fontinfo, mathml.att-opinfo
  mathml.attlist-mtext &= MATHML.Common.attrib, mathml.att-fontinfo
  mathml.attlist-ms &=
    MATHML.Common.attrib,
    mathml.att-fontinfo,
    mathml.att-lquote,
    mathml.att-rquote
  # Empty presentation schemata
  mathml.petoken = mathml.mspace
  mathml.mspace = element mspace { mathml.attlist-mspace, empty }
  mathml.any |= mathml.mspace
  mathml.attlist-mspace &=
    mathml.att-sizeinfo, mathml.att-linebreak, MATHML.Common.attrib
  # Presentation: general layout schemata
  mathml.pgenschema =
    mathml.mrow
    | mathml.mfrac
    | mathml.msqrt
    | mathml.mroot
    | mathml.menclose
    | mathml.mstyle
    | mathml.merror
    | mathml.mpadded
    | mathml.mphantom
    | mathml.mfenced
  mathml.attlist-mrow &= MATHML.Common.attrib
  mathml.attlist-mfrac &=
    MATHML.Common.attrib,
    mathml.att-bevelled,
    mathml.att-numalign,
    mathml.att-denomalign,
    mathml.att-linethickness
  mathml.attlist-msqrt &= MATHML.Common.attrib
  mathml.attlist-menclose &=
    MATHML.Common.attrib,
    [ a:defaultValue = "longdiv" ] attribute notation { text }?
  mathml.attlist-mroot &= MATHML.Common.attrib
  mathml.attlist-mstyle &=
    MATHML.Common.attrib,
    mathml.att-fontinfo,
    mathml.att-opinfo,
    mathml.att-lquote,
    mathml.att-rquote,
    mathml.att-linethickness,
    mathml.att-scriptlevel,
    mathml.att-scriptsizemultiplier,
    mathml.att-scriptminsize,
    mathml.att-background,
    mathml.att-veryverythinmathspace,
    mathml.att-verythinmathspace,
    mathml.att-thinmathspace,
    mathml.att-mediummathspace,
    mathml.att-thickmathspace,
    mathml.att-verythickmathspace,
    mathml.att-veryverythickmathspace,
    mathml.att-open,
    mathml.att-close,
    mathml.att-separators,
    mathml.att-subscriptshift,
    mathml.att-superscriptshift,
    mathml.att-accentunder,
    mathml.att-tableinfo,
    mathml.att-rowspan,
    mathml.att-columnspan,
    mathml.att-edge,
    mathml.att-actiontype,
    mathml.att-selection
  mathml.attlist-merror &= MATHML.Common.attrib
  mathml.attlist-mpadded &=
    MATHML.Common.attrib, mathml.att-sizeinfo, mathml.att-lspace
  mathml.attlist-mphantom &= MATHML.Common.attrib
  mathml.attlist-mfenced &=
    MATHML.Common.attrib,
    mathml.att-open,
    mathml.att-close,
    mathml.att-separators
  # Presentation layout schemata: scripts and limits
  mathml.pscrschema =
    mathml.msub
    | mathml.msup
    | mathml.msubsup
    | mathml.munder
    | mathml.mover
    | mathml.munderover
    | mathml.mmultiscripts
  mathml.attlist-msub &= MATHML.Common.attrib, mathml.att-subscriptshift
  mathml.attlist-msup &=
    MATHML.Common.attrib, mathml.att-superscriptshift
  mathml.attlist-msubsup &=
    MATHML.Common.attrib,
    mathml.att-subscriptshift,
    mathml.att-superscriptshift
  mathml.attlist-munder &= MATHML.Common.attrib, mathml.att-accentunder
  mathml.attlist-mover &= MATHML.Common.attrib, mathml.att-accent
  mathml.attlist-munderover &=
    MATHML.Common.attrib, mathml.att-accent, mathml.att-accentunder
  mathml.attlist-mmultiscripts &=
    MATHML.Common.attrib,
    mathml.att-subscriptshift,
    mathml.att-superscriptshift
  # Presentation layout schemata: empty elements for scripts
  mathml.pscreschema = mathml.mprescripts | mathml.none
  mathml.mprescripts =
    element mprescripts { mathml.attlist-mprescripts, empty }
  mathml.any |= mathml.mprescripts
  mathml.attlist-mprescripts &= MATHML.xmlns.attrib
  mathml.none = element none { mathml.attlist-none, empty }
  mathml.any |= mathml.none
  mathml.attlist-none &= MATHML.xmlns.attrib
  # Presentation layout schemata: tables
  mathml.ptabschema =
    mathml.mtable | mathml.mtr | mathml.mlabeledtr | mathml.mtd
  mathml.attlist-mtable &= MATHML.Common.attrib, mathml.att-tableinfo
  mathml.attlist-mtr &=
    MATHML.Common.attrib,
    mathml.att-rowalign,
    mathml.att-columnalign,
    mathml.att-groupalign
  mathml.attlist-mlabeledtr &=
    MATHML.Common.attrib,
    mathml.att-rowalign,
    mathml.att-columnalign,
    mathml.att-groupalign
  mathml.attlist-mtd &=
    MATHML.Common.attrib,
    mathml.att-rowalign,
    mathml.att-columnalign,
    mathml.att-groupalign,
    mathml.att-rowspan,
    mathml.att-columnspan
  mathml.plschema =
    mathml.pgenschema | mathml.pscrschema | mathml.ptabschema
  # Empty presentation layout schemata
  mathml.peschema = mathml.maligngroup | mathml.malignmark
  mathml.malignmark =
    element malignmark { mathml.attlist-malignmark, empty }
  mathml.any |= mathml.malignmark
  mathml.attlist-malignmark &= mathml.att-edge
  mathml.maligngroup =
    element maligngroup { mathml.attlist-maligngroup, empty }
  mathml.any |= mathml.maligngroup
  mathml.attlist-maligngroup &=
    MATHML.Common.attrib, mathml.att-groupalign
  mathml.mglyph = element mglyph { mathml.attlist-mglyph, empty }
  mathml.any |= mathml.mglyph
  mathml.attlist-mglyph &=
    mathml.att-alt, mathml.att-fontfamily, mathml.att-index
  # Presentation action schemata
  mathml.pactions = mathml.maction
  mathml.attlist-maction &=
    MATHML.Common.attrib, mathml.att-actiontype, mathml.att-selection
  # The following entity for substitution into
  # content constructs excludes elements that
  # are not valid as expressions.
  mathml.PresInCont =
    mathml.ptoken
    | mathml.petoken
    | mathml.plschema
    | mathml.peschema
    | mathml.pactions
  # Presentation entity: all presentation constructs
  mathml.Presentation =
    mathml.ptoken
    | mathml.petoken
    | mathml.pscreschema
    | mathml.plschema
    | mathml.peschema
    | mathml.pactions
  # Content element set  ........................................
  
  # Attribute definitions
  mathml.att-base = [ a:defaultValue = "10" ] attribute base { text }?
  mathml.att-closure =
    [ a:defaultValue = "closed" ] attribute closure { text }?
  mathml.att-definition =
    [ a:defaultValue = "" ] attribute definitionURL { text }?
  mathml.att-encoding =
    [ a:defaultValue = "" ] attribute encoding { text }?
  mathml.att-nargs = [ a:defaultValue = "1" ] attribute nargs { text }?
  mathml.att-occurrence =
    [ a:defaultValue = "function-model" ] attribute occurrence { text }?
  mathml.att-order =
    [ a:defaultValue = "numeric" ] attribute order { text }?
  mathml.att-scope =
    [ a:defaultValue = "local" ] attribute scope { text }?
  mathml.att-type = attribute type { text }?
  # Content elements: leaf nodes
  mathml.ctoken = mathml.csymbol | mathml.ci | mathml.cn
  mathml.attlist-ci &=
    MATHML.Common.attrib,
    mathml.att-type,
    mathml.att-definition,
    mathml.att-encoding
  mathml.attlist-csymbol &=
    MATHML.Common.attrib,
    mathml.att-encoding,
    mathml.att-type,
    mathml.att-definition
  mathml.attlist-cn &=
    MATHML.Common.attrib,
    mathml.att-type,
    mathml.att-base,
    mathml.att-definition,
    mathml.att-encoding
  # Content elements: specials
  mathml.cspecial = mathml.apply | mathml.reln | mathml.lambda
  mathml.attlist-apply &= MATHML.Common.attrib
  mathml.attlist-reln &= MATHML.Common.attrib
  mathml.attlist-lambda &= MATHML.Common.attrib
  # Content elements: others
  mathml.cother = mathml.condition | mathml.declare | mathml.sep
  mathml.attlist-condition &= MATHML.Common.attrib
  mathml.attlist-declare &=
    MATHML.Common.attrib,
    mathml.att-type,
    mathml.att-scope,
    mathml.att-nargs,
    mathml.att-occurrence,
    mathml.att-definition,
    mathml.att-encoding
  mathml.sep = element sep { mathml.attlist-sep, empty }
  mathml.any |= mathml.sep
  mathml.attlist-sep &= MATHML.xmlns.attrib
  # Content elements: semantic mapping
  mathml.csemantics =
    mathml.semantics | mathml.annotation | mathml.annotation-xml
  mathml.attlist-semantics &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.attlist-annotation &= MATHML.Common.attrib, mathml.att-encoding
  mathml.attlist-annotation-xml &=
    MATHML.Common.attrib, mathml.att-encoding
  # Content elements: constructors
  mathml.cconstructor =
    mathml.interval
    | mathml.list
    | mathml.matrix
    | mathml.matrixrow
    | mathml.set
    | mathml.vector
    | mathml.piecewise
  mathml.attlist-interval &= MATHML.Common.attrib, mathml.att-closure
  mathml.attlist-set &= MATHML.Common.attrib, mathml.att-type
  mathml.attlist-list &= MATHML.Common.attrib, mathml.att-order
  mathml.attlist-vector &= MATHML.Common.attrib
  mathml.attlist-matrix &= MATHML.Common.attrib
  mathml.attlist-matrixrow &= MATHML.Common.attrib
  mathml.attlist-piecewise &= MATHML.Common.attrib
  mathml.attlist-piece &= MATHML.Common.attrib
  mathml.attlist-otherwise &= MATHML.Common.attrib
  # Content elements: symbols
  mathml.c0ary =
    mathml.integers
    | mathml.reals
    | mathml.rationals
    | mathml.naturalnumbers
    | mathml.complexes
    | mathml.primes
    | mathml.exponentiale
    | mathml.imaginaryi
    | mathml.notanumber
    | mathml.true
    | mathml.false
    | mathml.emptyset
    | mathml.pi
    | mathml.eulergamma
    | mathml.infinity
  mathml.integers = element integers { mathml.attlist-integers, empty }
  mathml.any |= mathml.integers
  mathml.attlist-integers &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.reals = element reals { mathml.attlist-reals, empty }
  mathml.any |= mathml.reals
  mathml.attlist-reals &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.rationals =
    element rationals { mathml.attlist-rationals, empty }
  mathml.any |= mathml.rationals
  mathml.attlist-rationals &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.naturalnumbers =
    element naturalnumbers { mathml.attlist-naturalnumbers, empty }
  mathml.any |= mathml.naturalnumbers
  mathml.attlist-naturalnumbers &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.complexes =
    element complexes { mathml.attlist-complexes, empty }
  mathml.any |= mathml.complexes
  mathml.attlist-complexes &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.primes = element primes { mathml.attlist-primes, empty }
  mathml.any |= mathml.primes
  mathml.attlist-primes &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.exponentiale =
    element exponentiale { mathml.attlist-exponentiale, empty }
  mathml.any |= mathml.exponentiale
  mathml.attlist-exponentiale &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.imaginaryi =
    element imaginaryi { mathml.attlist-imaginaryi, empty }
  mathml.any |= mathml.imaginaryi
  mathml.attlist-imaginaryi &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.notanumber =
    element notanumber { mathml.attlist-notanumber, empty }
  mathml.any |= mathml.notanumber
  mathml.attlist-notanumber &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.true = element true { mathml.attlist-true, empty }
  mathml.any |= mathml.true
  mathml.attlist-true &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.false = element false { mathml.attlist-false, empty }
  mathml.any |= mathml.false
  mathml.attlist-false &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.emptyset = element emptyset { mathml.attlist-emptyset, empty }
  mathml.any |= mathml.emptyset
  mathml.attlist-emptyset &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.pi = element pi { mathml.attlist-pi, empty }
  mathml.any |= mathml.pi
  mathml.attlist-pi &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.eulergamma =
    element eulergamma { mathml.attlist-eulergamma, empty }
  mathml.any |= mathml.eulergamma
  mathml.attlist-eulergamma &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.infinity = element infinity { mathml.attlist-infinity, empty }
  mathml.any |= mathml.infinity
  mathml.attlist-infinity &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  # Content elements: operators
  mathml.cfuncop1ary =
    mathml.inverse
    | mathml.ident
    | mathml.domain
    | mathml.codomain
    | mathml.image
  mathml.inverse = element inverse { mathml.attlist-inverse, empty }
  mathml.any |= mathml.inverse
  mathml.attlist-inverse &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.domain = element domain { mathml.attlist-domain, empty }
  mathml.any |= mathml.domain
  mathml.attlist-domain &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.codomain = element codomain { mathml.attlist-codomain, empty }
  mathml.any |= mathml.codomain
  mathml.attlist-codomain &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.image = element image { mathml.attlist-image, empty }
  mathml.any |= mathml.image
  mathml.attlist-image &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cfuncopnary = mathml.fn | mathml.compose
  mathml.attlist-fn &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.ident = element ident { mathml.attlist-ident, empty }
  mathml.any |= mathml.ident
  mathml.attlist-ident &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.compose = element compose { mathml.attlist-compose, empty }
  mathml.any |= mathml.compose
  mathml.attlist-compose &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.carithop1ary =
    mathml.abs
    | mathml.conjugate
    | mathml.exp
    | mathml.factorial
    | mathml.arg
    | mathml.real
    | mathml.imaginary
    | mathml.floor
    | mathml.ceiling
  mathml.exp = element exp { mathml.attlist-exp, empty }
  mathml.any |= mathml.exp
  mathml.attlist-exp &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.abs = element abs { mathml.attlist-abs, empty }
  mathml.any |= mathml.abs
  mathml.attlist-abs &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arg = element arg { mathml.attlist-arg, empty }
  mathml.any |= mathml.arg
  mathml.attlist-arg &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.real = element real { mathml.attlist-real, empty }
  mathml.any |= mathml.real
  mathml.attlist-real &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.imaginary =
    element imaginary { mathml.attlist-imaginary, empty }
  mathml.any |= mathml.imaginary
  mathml.attlist-imaginary &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.conjugate =
    element conjugate { mathml.attlist-conjugate, empty }
  mathml.any |= mathml.conjugate
  mathml.attlist-conjugate &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.factorial =
    element factorial { mathml.attlist-factorial, empty }
  mathml.any |= mathml.factorial
  mathml.attlist-factorial &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.floor = element floor { mathml.attlist-floor, empty }
  mathml.any |= mathml.floor
  mathml.attlist-floor &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.ceiling = element ceiling { mathml.attlist-ceiling, empty }
  mathml.any |= mathml.ceiling
  mathml.attlist-ceiling &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.carithop1or2ary = mathml.minus
  mathml.minus = element minus { mathml.attlist-minus, empty }
  mathml.any |= mathml.minus
  mathml.attlist-minus &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.carithop2ary =
    mathml.quotient | mathml.divide | mathml.power | mathml.rem
  mathml.quotient = element quotient { mathml.attlist-quotient, empty }
  mathml.any |= mathml.quotient
  mathml.attlist-quotient &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.divide = element divide { mathml.attlist-divide, empty }
  mathml.any |= mathml.divide
  mathml.attlist-divide &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.power = element power { mathml.attlist-power, empty }
  mathml.any |= mathml.power
  mathml.attlist-power &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.rem = element rem { mathml.attlist-rem, empty }
  mathml.any |= mathml.rem
  mathml.attlist-rem &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.carithopnary =
    mathml.plus
    | mathml.times
    | mathml.max
    | mathml.min
    | mathml.gcd
    | mathml.lcm
  mathml.plus = element plus { mathml.attlist-plus, empty }
  mathml.any |= mathml.plus
  mathml.attlist-plus &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.max = element max { mathml.attlist-max, empty }
  mathml.any |= mathml.max
  mathml.attlist-max &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.min = element min { mathml.attlist-min, empty }
  mathml.any |= mathml.min
  mathml.attlist-min &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.times = element times { mathml.attlist-times, empty }
  mathml.any |= mathml.times
  mathml.attlist-times &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.gcd = element gcd { mathml.attlist-gcd, empty }
  mathml.any |= mathml.gcd
  mathml.attlist-gcd &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.lcm = element lcm { mathml.attlist-lcm, empty }
  mathml.any |= mathml.lcm
  mathml.attlist-lcm &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.carithoproot = mathml.root
  mathml.root = element root { mathml.attlist-root, empty }
  mathml.any |= mathml.root
  mathml.attlist-root &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clogicopquant = mathml.exists | mathml.forall
  mathml.exists = element exists { mathml.attlist-exists, empty }
  mathml.any |= mathml.exists
  mathml.attlist-exists &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.forall = element forall { mathml.attlist-forall, empty }
  mathml.any |= mathml.forall
  mathml.attlist-forall &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clogicopnary = mathml.and | mathml.or | mathml.xor
  mathml.and = element and { mathml.attlist-and, empty }
  mathml.any |= mathml.and
  mathml.attlist-and &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.or = element or { mathml.attlist-or, empty }
  mathml.any |= mathml.or
  mathml.attlist-or &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.xor = element xor { mathml.attlist-xor, empty }
  mathml.any |= mathml.xor
  mathml.attlist-xor &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clogicop1ary = mathml.not
  mathml.not = element not { mathml.attlist-not, empty }
  mathml.any |= mathml.not
  mathml.attlist-not &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clogicop2ary = mathml.implies
  mathml.implies = element implies { mathml.attlist-implies, empty }
  mathml.any |= mathml.implies
  mathml.attlist-implies &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.ccalcop =
    mathml.log
    | mathml.int
    | mathml.diff
    | mathml.partialdiff
    | mathml.divergence
    | mathml.grad
    | mathml.curl
    | mathml.laplacian
  mathml.divergence =
    element divergence { mathml.attlist-divergence, empty }
  mathml.any |= mathml.divergence
  mathml.attlist-divergence &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.grad = element grad { mathml.attlist-grad, empty }
  mathml.any |= mathml.grad
  mathml.attlist-grad &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.curl = element curl { mathml.attlist-curl, empty }
  mathml.any |= mathml.curl
  mathml.attlist-curl &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.laplacian =
    element laplacian { mathml.attlist-laplacian, empty }
  mathml.any |= mathml.laplacian
  mathml.attlist-laplacian &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.log = element log { mathml.attlist-log, empty }
  mathml.any |= mathml.log
  mathml.attlist-log &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.int = element int { mathml.attlist-int, empty }
  mathml.any |= mathml.int
  mathml.attlist-int &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.diff = element diff { mathml.attlist-diff, empty }
  mathml.any |= mathml.diff
  mathml.attlist-diff &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.partialdiff =
    element partialdiff { mathml.attlist-partialdiff, empty }
  mathml.any |= mathml.partialdiff
  mathml.attlist-partialdiff &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.ccalcop1ary = mathml.ln
  mathml.ln = element ln { mathml.attlist-ln, empty }
  mathml.any |= mathml.ln
  mathml.attlist-ln &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csetop1ary = mathml.card
  mathml.card = element card { mathml.attlist-card, empty }
  mathml.any |= mathml.card
  mathml.attlist-card &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csetop2ary = mathml.setdiff
  mathml.setdiff = element setdiff { mathml.attlist-setdiff, empty }
  mathml.any |= mathml.setdiff
  mathml.attlist-setdiff &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csetopnary =
    mathml.union | mathml.intersect | mathml.cartesianproduct
  mathml.union = element union { mathml.attlist-union, empty }
  mathml.any |= mathml.union
  mathml.attlist-union &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.intersect =
    element intersect { mathml.attlist-intersect, empty }
  mathml.any |= mathml.intersect
  mathml.attlist-intersect &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cartesianproduct =
    element cartesianproduct { mathml.attlist-cartesianproduct, empty }
  mathml.any |= mathml.cartesianproduct
  mathml.attlist-cartesianproduct &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cseqop = mathml.sum | mathml.product | mathml.limit
  mathml.sum = element sum { mathml.attlist-sum, empty }
  mathml.any |= mathml.sum
  mathml.attlist-sum &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.product = element product { mathml.attlist-product, empty }
  mathml.any |= mathml.product
  mathml.attlist-product &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.limit = element limit { mathml.attlist-limit, empty }
  mathml.any |= mathml.limit
  mathml.attlist-limit &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.ctrigop =
    mathml.sin
    | mathml.cos
    | mathml.tan
    | mathml.sec
    | mathml.csc
    | mathml.cot
    | mathml.sinh
    | mathml.cosh
    | mathml.tanh
    | mathml.sech
    | mathml.csch
    | mathml.coth
    | mathml.arcsin
    | mathml.arccos
    | mathml.arctan
    | mathml.arccosh
    | mathml.arccot
    | mathml.arccoth
    | mathml.arccsc
    | mathml.arccsch
    | mathml.arcsec
    | mathml.arcsech
    | mathml.arcsinh
    | mathml.arctanh
  mathml.sin = element sin { mathml.attlist-sin, empty }
  mathml.any |= mathml.sin
  mathml.attlist-sin &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cos = element cos { mathml.attlist-cos, empty }
  mathml.any |= mathml.cos
  mathml.attlist-cos &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.tan = element tan { mathml.attlist-tan, empty }
  mathml.any |= mathml.tan
  mathml.attlist-tan &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.sec = element sec { mathml.attlist-sec, empty }
  mathml.any |= mathml.sec
  mathml.attlist-sec &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csc = element csc { mathml.attlist-csc, empty }
  mathml.any |= mathml.csc
  mathml.attlist-csc &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cot = element cot { mathml.attlist-cot, empty }
  mathml.any |= mathml.cot
  mathml.attlist-cot &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.sinh = element sinh { mathml.attlist-sinh, empty }
  mathml.any |= mathml.sinh
  mathml.attlist-sinh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cosh = element cosh { mathml.attlist-cosh, empty }
  mathml.any |= mathml.cosh
  mathml.attlist-cosh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.tanh = element tanh { mathml.attlist-tanh, empty }
  mathml.any |= mathml.tanh
  mathml.attlist-tanh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.sech = element sech { mathml.attlist-sech, empty }
  mathml.any |= mathml.sech
  mathml.attlist-sech &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csch = element csch { mathml.attlist-csch, empty }
  mathml.any |= mathml.csch
  mathml.attlist-csch &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.coth = element coth { mathml.attlist-coth, empty }
  mathml.any |= mathml.coth
  mathml.attlist-coth &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arcsin = element arcsin { mathml.attlist-arcsin, empty }
  mathml.any |= mathml.arcsin
  mathml.attlist-arcsin &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccos = element arccos { mathml.attlist-arccos, empty }
  mathml.any |= mathml.arccos
  mathml.attlist-arccos &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arctan = element arctan { mathml.attlist-arctan, empty }
  mathml.any |= mathml.arctan
  mathml.attlist-arctan &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccosh = element arccosh { mathml.attlist-arccosh, empty }
  mathml.any |= mathml.arccosh
  mathml.attlist-arccosh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccot = element arccot { mathml.attlist-arccot, empty }
  mathml.any |= mathml.arccot
  mathml.attlist-arccot &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccoth = element arccoth { mathml.attlist-arccoth, empty }
  mathml.any |= mathml.arccoth
  mathml.attlist-arccoth &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccsc = element arccsc { mathml.attlist-arccsc, empty }
  mathml.any |= mathml.arccsc
  mathml.attlist-arccsc &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arccsch = element arccsch { mathml.attlist-arccsch, empty }
  mathml.any |= mathml.arccsch
  mathml.attlist-arccsch &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arcsec = element arcsec { mathml.attlist-arcsec, empty }
  mathml.any |= mathml.arcsec
  mathml.attlist-arcsec &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arcsech = element arcsech { mathml.attlist-arcsech, empty }
  mathml.any |= mathml.arcsech
  mathml.attlist-arcsech &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arcsinh = element arcsinh { mathml.attlist-arcsinh, empty }
  mathml.any |= mathml.arcsinh
  mathml.attlist-arcsinh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.arctanh = element arctanh { mathml.attlist-arctanh, empty }
  mathml.any |= mathml.arctanh
  mathml.attlist-arctanh &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cstatopnary =
    mathml.mean
    | mathml.sdev
    | mathml.variance
    | mathml.median
    | mathml.mode
  mathml.mean = element mean { mathml.attlist-mean, empty }
  mathml.any |= mathml.mean
  mathml.attlist-mean &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.sdev = element sdev { mathml.attlist-sdev, empty }
  mathml.any |= mathml.sdev
  mathml.attlist-sdev &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.variance = element variance { mathml.attlist-variance, empty }
  mathml.any |= mathml.variance
  mathml.attlist-variance &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.median = element median { mathml.attlist-median, empty }
  mathml.any |= mathml.median
  mathml.attlist-median &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.mode = element mode { mathml.attlist-mode, empty }
  mathml.any |= mathml.mode
  mathml.attlist-mode &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cstatopmoment = mathml.moment
  mathml.moment = element moment { mathml.attlist-moment, empty }
  mathml.any |= mathml.moment
  mathml.attlist-moment &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clalgop1ary = mathml.determinant | mathml.transpose
  mathml.determinant =
    element determinant { mathml.attlist-determinant, empty }
  mathml.any |= mathml.determinant
  mathml.attlist-determinant &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.transpose =
    element transpose { mathml.attlist-transpose, empty }
  mathml.any |= mathml.transpose
  mathml.attlist-transpose &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clalgop2ary =
    mathml.vectorproduct | mathml.scalarproduct | mathml.outerproduct
  mathml.vectorproduct =
    element vectorproduct { mathml.attlist-vectorproduct, empty }
  mathml.any |= mathml.vectorproduct
  mathml.attlist-vectorproduct &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.scalarproduct =
    element scalarproduct { mathml.attlist-scalarproduct, empty }
  mathml.any |= mathml.scalarproduct
  mathml.attlist-scalarproduct &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.outerproduct =
    element outerproduct { mathml.attlist-outerproduct, empty }
  mathml.any |= mathml.outerproduct
  mathml.attlist-outerproduct &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.clalgopnary = mathml.selector
  mathml.selector = element selector { mathml.attlist-selector, empty }
  mathml.any |= mathml.selector
  mathml.attlist-selector &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  # Content elements: relations
  mathml.cgenrel2ary = mathml.neq | mathml.factorof
  mathml.neq = element neq { mathml.attlist-neq, empty }
  mathml.any |= mathml.neq
  mathml.attlist-neq &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.factorof = element factorof { mathml.attlist-factorof, empty }
  mathml.any |= mathml.factorof
  mathml.attlist-factorof &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cgenrelnary =
    mathml.eq
    | mathml.leq
    | mathml.lt
    | mathml.geq
    | mathml.gt
    | mathml.equivalent
    | mathml.approx
  mathml.eq = element eq { mathml.attlist-eq, empty }
  mathml.any |= mathml.eq
  mathml.attlist-eq &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.equivalent =
    element equivalent { mathml.attlist-equivalent, empty }
  mathml.any |= mathml.equivalent
  mathml.attlist-equivalent &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.approx = element approx { mathml.attlist-approx, empty }
  mathml.any |= mathml.approx
  mathml.attlist-approx &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.gt = element gt { mathml.attlist-gt, empty }
  mathml.any |= mathml.gt
  mathml.attlist-gt &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.lt = element lt { mathml.attlist-lt, empty }
  mathml.any |= mathml.lt
  mathml.attlist-lt &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.geq = element geq { mathml.attlist-geq, empty }
  mathml.any |= mathml.geq
  mathml.attlist-geq &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.leq = element leq { mathml.attlist-leq, empty }
  mathml.any |= mathml.leq
  mathml.attlist-leq &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csetrel2ary =
    mathml.in | mathml.notin | mathml.notsubset | mathml.notprsubset
  mathml.in = element in { mathml.attlist-in, empty }
  mathml.any |= mathml.in
  mathml.attlist-in &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.notin = element notin { mathml.attlist-notin, empty }
  mathml.any |= mathml.notin
  mathml.attlist-notin &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.notsubset =
    element notsubset { mathml.attlist-notsubset, empty }
  mathml.any |= mathml.notsubset
  mathml.attlist-notsubset &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.notprsubset =
    element notprsubset { mathml.attlist-notprsubset, empty }
  mathml.any |= mathml.notprsubset
  mathml.attlist-notprsubset &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.csetrelnary = mathml.subset | mathml.prsubset
  mathml.subset = element subset { mathml.attlist-subset, empty }
  mathml.any |= mathml.subset
  mathml.attlist-subset &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.prsubset = element prsubset { mathml.attlist-prsubset, empty }
  mathml.any |= mathml.prsubset
  mathml.attlist-prsubset &=
    MATHML.Common.attrib, mathml.att-definition, mathml.att-encoding
  mathml.cseqrel2ary = mathml.tendsto
  mathml.tendsto = element tendsto { mathml.attlist-tendsto, empty }
  mathml.any |= mathml.tendsto
  mathml.attlist-tendsto &=
    MATHML.Common.attrib,
    mathml.att-definition,
    mathml.att-encoding,
    mathml.att-type
  # Content elements: quantifiers
  mathml.cquantifier =
    mathml.lowlimit
    | mathml.uplimit
    | mathml.bvar
    | mathml.degree
    | mathml.logbase
    | mathml.momentabout
    | mathml.domainofapplication
  mathml.attlist-lowlimit &= MATHML.Common.attrib
  mathml.attlist-uplimit &= MATHML.Common.attrib
  mathml.attlist-bvar &= MATHML.Common.attrib
  mathml.attlist-degree &= MATHML.Common.attrib
  mathml.attlist-logbase &= MATHML.Common.attrib
  mathml.attlist-momentabout &= MATHML.Common.attrib
  mathml.attlist-domainofapplication &= MATHML.Common.attrib
  # Operator groups
  mathml.cop1ary =
    mathml.cfuncop1ary
    | mathml.carithop1ary
    | mathml.clogicop1ary
    | mathml.ccalcop1ary
    | mathml.ctrigop
    | mathml.clalgop1ary
    | mathml.csetop1ary
  mathml.cop2ary =
    mathml.carithop2ary
    | mathml.clogicop2ary
    | mathml.clalgop2ary
    | mathml.csetop2ary
  mathml.copnary =
    mathml.cfuncopnary
    | mathml.carithopnary
    | mathml.clogicopnary
    | mathml.csetopnary
    | mathml.cstatopnary
    | mathml.clalgopnary
  mathml.copmisc =
    mathml.carithoproot
    | mathml.carithop1or2ary
    | mathml.ccalcop
    | mathml.cseqop
    | mathml.cstatopmoment
    | mathml.clogicopquant
  # Relation groups
  mathml.crel2ary =
    mathml.cgenrel2ary | mathml.csetrel2ary | mathml.cseqrel2ary
  mathml.crelnary = mathml.cgenrelnary | mathml.csetrelnary
  # Content constructs: all
  mathml.Content =
    mathml.ctoken
    | mathml.cspecial
    | mathml.cother
    | mathml.csemantics
    | mathml.c0ary
    | mathml.cconstructor
    | mathml.cquantifier
    | mathml.cop1ary
    | mathml.cop2ary
    | mathml.copnary
    | mathml.copmisc
    | mathml.crel2ary
    | mathml.crelnary
  # Content constructs for substitution in presentation structures
  mathml.ContInPres =
    mathml.ci
    | mathml.csymbol
    | mathml.cn
    | mathml.c0ary
    | mathml.apply
    | mathml.fn
    | mathml.lambda
    | mathml.reln
    | mathml.cconstructor
    | mathml.semantics
    | mathml.declare
  # .............................................................
  
  # Recursive definition for content of expressions. Include
  # presentation constructs at lowest level so presentation
  # layout schemata hold presentation or content elements.
  # Include content constructs at lowest level so content
  # elements hold PCDATA or presentation elements at leaf
  # level (for permitted substitutable elements in context)
  mathml.ContentExpression = (mathml.Content | mathml.PresInCont)*
  mathml.PresExpression = (mathml.Presentation | mathml.ContInPres)*
  mathml.MathExpression = (mathml.PresInCont | mathml.ContInPres)*
  # PCDATA or MathML character elements
  mathml.MathMLCharacters = text | mathml.mglyph
  # Content elements: tokens
  
  # (may contain embedded presentation constructs)
  mathml.ci =
    element ci {
      mathml.attlist-ci, (mathml.MathMLCharacters | mathml.PresInCont)*
    }
  mathml.any |= mathml.ci
  mathml.csymbol =
    element csymbol {
      mathml.attlist-csymbol,
      (mathml.MathMLCharacters | mathml.PresInCont)*
    }
  mathml.any |= mathml.csymbol
  mathml.cn =
    element cn {
      mathml.attlist-cn,
      (mathml.MathMLCharacters | mathml.sep | mathml.PresInCont)*
    }
  mathml.any |= mathml.cn
  # Content elements: special
  mathml.apply =
    element apply { mathml.attlist-apply, mathml.ContentExpression }
  mathml.any |= mathml.apply
  mathml.reln =
    element reln { mathml.attlist-reln, mathml.ContentExpression }
  mathml.any |= mathml.reln
  mathml.lambda =
    element lambda { mathml.attlist-lambda, mathml.ContentExpression }
  mathml.any |= mathml.lambda
  # Content elements: other
  mathml.condition =
    element condition {
      mathml.attlist-condition, mathml.ContentExpression
    }
  mathml.any |= mathml.condition
  mathml.declare =
    element declare { mathml.attlist-declare, mathml.ContentExpression }
  mathml.any |= mathml.declare
  # Content elements: semantics
  mathml.semantics =
    element semantics {
      mathml.attlist-semantics, mathml.ContentExpression
    }
  mathml.any |= mathml.semantics
  mathml.Annotation.content = text
  mathml.annotation =
    element annotation {
      mathml.attlist-annotation, mathml.Annotation.content
    }
  mathml.any |= mathml.annotation
  mathml.annotation-xml =
    element annotation-xml { mathml.attlist-annotation-xml, mathml.any }
  mathml.any |= mathml.annotation-xml
  # Content elements: constructors
  mathml.interval =
    element interval {
      mathml.attlist-interval, mathml.ContentExpression
    }
  mathml.any |= mathml.interval
  mathml.set =
    element set { mathml.attlist-set, mathml.ContentExpression }
  mathml.any |= mathml.set
  mathml.list =
    element list { mathml.attlist-list, mathml.ContentExpression }
  mathml.any |= mathml.list
  mathml.vector =
    element vector { mathml.attlist-vector, mathml.ContentExpression }
  mathml.any |= mathml.vector
  mathml.matrix =
    element matrix { mathml.attlist-matrix, mathml.ContentExpression }
  mathml.any |= mathml.matrix
  mathml.matrixrow =
    element matrixrow {
      mathml.attlist-matrixrow, mathml.ContentExpression
    }
  mathml.any |= mathml.matrixrow
  mathml.piecewise =
    element piecewise {
      mathml.attlist-piecewise, mathml.piece*, mathml.otherwise?
    }
  mathml.any |= mathml.piecewise
  mathml.piece =
    element piece { mathml.attlist-piece, mathml.ContentExpression }
  mathml.any |= mathml.piece
  mathml.otherwise =
    element otherwise {
      mathml.attlist-otherwise, mathml.ContentExpression
    }
  mathml.any |= mathml.otherwise
  # Content elements: operator (user-defined)
  mathml.fn = element fn { mathml.attlist-fn, mathml.ContentExpression }
  mathml.any |= mathml.fn
  # Content elements: quantifiers
  mathml.lowlimit =
    element lowlimit {
      mathml.attlist-lowlimit, mathml.ContentExpression
    }
  mathml.any |= mathml.lowlimit
  mathml.uplimit =
    element uplimit { mathml.attlist-uplimit, mathml.ContentExpression }
  mathml.any |= mathml.uplimit
  mathml.bvar =
    element bvar { mathml.attlist-bvar, mathml.ContentExpression }
  mathml.any |= mathml.bvar
  mathml.degree =
    element degree { mathml.attlist-degree, mathml.ContentExpression }
  mathml.any |= mathml.degree
  mathml.logbase =
    element logbase { mathml.attlist-logbase, mathml.ContentExpression }
  mathml.any |= mathml.logbase
  mathml.momentabout =
    element momentabout {
      mathml.attlist-momentabout, mathml.ContentExpression
    }
  mathml.any |= mathml.momentabout
  mathml.domainofapplication =
    element domainofapplication {
      mathml.attlist-domainofapplication, mathml.ContentExpression
    }
  mathml.any |= mathml.domainofapplication
  # .............................................................
  
  # Presentation layout schemata contain tokens,
  # layout and content schemata.
  mathml.mstyle =
    element mstyle { mathml.attlist-mstyle, mathml.PresExpression }
  mathml.any |= mathml.mstyle
  mathml.merror =
    element merror { mathml.attlist-merror, mathml.PresExpression }
  mathml.any |= mathml.merror
  mathml.mphantom =
    element mphantom { mathml.attlist-mphantom, mathml.PresExpression }
  mathml.any |= mathml.mphantom
  mathml.mrow =
    element mrow { mathml.attlist-mrow, mathml.PresExpression }
  mathml.any |= mathml.mrow
  mathml.mfrac =
    element mfrac { mathml.attlist-mfrac, mathml.PresExpression }
  mathml.any |= mathml.mfrac
  mathml.msqrt =
    element msqrt { mathml.attlist-msqrt, mathml.PresExpression }
  mathml.any |= mathml.msqrt
  mathml.menclose =
    element menclose { mathml.attlist-menclose, mathml.PresExpression }
  mathml.any |= mathml.menclose
  mathml.mroot =
    element mroot { mathml.attlist-mroot, mathml.PresExpression }
  mathml.any |= mathml.mroot
  mathml.msub =
    element msub { mathml.attlist-msub, mathml.PresExpression }
  mathml.any |= mathml.msub
  mathml.msup =
    element msup { mathml.attlist-msup, mathml.PresExpression }
  mathml.any |= mathml.msup
  mathml.msubsup =
    element msubsup { mathml.attlist-msubsup, mathml.PresExpression }
  mathml.any |= mathml.msubsup
  mathml.mmultiscripts =
    element mmultiscripts {
      mathml.attlist-mmultiscripts, mathml.PresExpression
    }
  mathml.any |= mathml.mmultiscripts
  mathml.munder =
    element munder { mathml.attlist-munder, mathml.PresExpression }
  mathml.any |= mathml.munder
  mathml.mover =
    element mover { mathml.attlist-mover, mathml.PresExpression }
  mathml.any |= mathml.mover
  mathml.munderover =
    element munderover {
      mathml.attlist-munderover, mathml.PresExpression
    }
  mathml.any |= mathml.munderover
  mathml.mtable =
    element mtable { mathml.attlist-mtable, mathml.PresExpression }
  mathml.any |= mathml.mtable
  mathml.mtr = element mtr { mathml.attlist-mtr, mathml.PresExpression }
  mathml.any |= mathml.mtr
  mathml.mlabeledtr =
    element mlabeledtr {
      mathml.attlist-mlabeledtr, mathml.PresExpression
    }
  mathml.any |= mathml.mlabeledtr
  mathml.mtd = element mtd { mathml.attlist-mtd, mathml.PresExpression }
  mathml.any |= mathml.mtd
  mathml.maction =
    element maction { mathml.attlist-maction, mathml.PresExpression }
  mathml.any |= mathml.maction
  mathml.mfenced =
    element mfenced { mathml.attlist-mfenced, mathml.PresExpression }
  mathml.any |= mathml.mfenced
  mathml.mpadded =
    element mpadded { mathml.attlist-mpadded, mathml.PresExpression }
  mathml.any |= mathml.mpadded
  # Presentation elements contain PCDATA or malignmark constructs.
  mathml.mi =
    element mi {
      mathml.attlist-mi, (mathml.MathMLCharacters | mathml.malignmark)*
    }
  mathml.any |= mathml.mi
  mathml.mn =
    element mn {
      mathml.attlist-mn, (mathml.MathMLCharacters | mathml.malignmark)*
    }
  mathml.any |= mathml.mn
  mathml.mo =
    element mo {
      mathml.attlist-mo, (mathml.MathMLCharacters | mathml.malignmark)*
    }
  mathml.any |= mathml.mo
  mathml.mtext =
    element mtext {
      mathml.attlist-mtext,
      (mathml.MathMLCharacters | mathml.malignmark)*
    }
  mathml.any |= mathml.mtext
  mathml.ms =
    element ms {
      mathml.attlist-ms, (mathml.MathMLCharacters | mathml.malignmark)*
    }
  mathml.any |= mathml.ms
  # Browser interface definition  ...............................
  
  # Attributes for top-level element "math"
  mathml.att-macros = attribute macros { text }?
  mathml.att-mode = attribute mode { text }?
  mathml.att-display = attribute display { text }?
  mathml.att-topinfo =
    MATHML.Common.attrib,
    mathml.att-macros,
    mathml.att-mode,
    mathml.att-display
  # Attributes for browser interface element
  mathml.att-baseline = attribute baseline { text }?
  mathml.att-overflow =
    [ a:defaultValue = "scroll" ]
    attribute overflow { "scroll" | "elide" | "truncate" | "scale" }?
  mathml.att-altimg = attribute altimg { text }?
  mathml.att-alttext = attribute alttext { text }?
  mathml.att-browif =
    mathml.att-type,
    mathml.att-name,
    mathml.att-height,
    mathml.att-width,
    mathml.att-baseline,
    mathml.att-overflow,
    mathml.att-altimg,
    mathml.att-alttext
  # .............................................................
  
  # The top-level element "math" contains MathML encoded
  # mathematics. The "math" element has the browser info
  # attributes iff it is also the browser interface element.
  mathml.math =
    element math { mathml.attlist-math, mathml.MathExpression }
  mathml.any |= mathml.math
  mathml.attlist-math &= mathml.att-topinfo, mathml.att-browif
  # MathML Character Entities ..............................................
  
  # Entity sets from ISO Technical Report 9573-13 .....
  
  # Entity sets from informative annex to ISO 8879:1986 (SGML) .......
  
  # New characters defined by MathML ............................
  
  # MathML aliases for characters defined above .................
  
  # end of MathML Character Entity section
  
  # Revision History:
  # 
  # Initial draft (syntax = XML) 1997-05-09
  #    Stephen Buswell
  # Revised 1997-05-14
  #    Robert Miner
  # Revised 1997-06-29 and 1997-07-02
  #    Stephen Buswell
  # Revised 1997-12-15
  #    Stephen Buswell
  # Revised 1998-02-08
  #    Stephen Buswell
  # Revised 1998-04-04
  #    Stephen Buswell
  # Entities and small revisions 1999-02-21
  #    David Carlisle
  # Added attribute definitionURL to ci and cn 1999-10-11
  #    Nico Poppelier
  # Additions for MathML 2  1999-12-16
  #    David Carlisle
  # Namespace support 2000-01-14
  #    David Carlisle
  # XHTML Compatibility 2000-02-23
  #    Murray Altheim
  # New content elements 2000-03-26
  #    David Carlisle
  # Further revisions for MathML2 CR draft 2000-07-11
  #    David Carlisle
  # Further revisions for MathML2 CR draft 2000-10-31
  #    David Carlisle
  # Revisions for Unicode 3.2  2002-05-21
  #    David Carlisle
  # Add width and side attributes to mtable (to align with the specification)  2002-06-05
  #    David Carlisle
  # Use %XLINK.prefix rather than hardwired xlink:, add xlink:type 2002-06-12
  #    David Carlisle
  # Add missing numalign and denomalign attributes for mfrac 2002-07-05
  #    David Carlisle
  #
  
  # end of MathML 2.0 DTD  ................................................
  
  # .......................................................................
  mathml.any |= text
}
tei_data.certainty = "high" | "medium" | "low" | "unknown"
tei_data.probability =
  xsd:double { minInclusive = "0" maxInclusive = "1" }
tei_data.numeric = xsd:double | xsd:decimal
tei_data.count = xsd:nonNegativeInteger
tei_data.temporal =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
  | xsd:token {
      pattern =
        "(-?[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T)?([01][0-9]|2[0-3])(:[0-5][0-9])?(Z|[+\-]((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
    }
tei_data.duration = xsd:duration
tei_data.truthValue = xsd:boolean
tei_data.xTruthValue = xsd:boolean | "unknown" | "inapplicable"
tei_data.language = xsd:language
tei_data.sex = "0" | "1" | "2" | "9"
tei_data.namespace = xsd:anyURI
tei_data.outputMeasurement =
  xsd:token {
    pattern =
      "[\-+]?\d+(\.\d+)?(%|cm|mm|in|pt|pc|px|em|ex|gd|rem|vw|vh|vm)"
  }
tei_data.pattern = xsd:token
tei_data.pointer = xsd:anyURI
tei_data.code = xsd:anyURI
tei_data.enumerated = xsd:token
tei_data.key = xsd:string
tei_data.word = xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
tei_data.name = xsd:Name
tei_macro.component = tei_model.common
tei_macro.componentSeq = (tei_macro.component | tei_model.global)*
tei_macro.paraContent =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_model.inter
   | tei_model.global)*
tei_macro.phraseSeq =
  (text | tei_model.gLike | tei_model.phrase | tei_model.global)*
tei_macro.specialPara =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_model.inter
   | tei_model.divPart
   | tei_model.global)*
tei_macro.xtext = (text | tei_model.gLike)*
tei_macro.fileDescPart =
  tei_titleStmt,
  tei_editionStmt?,
  tei_extent?,
  tei_publicationStmt,
  tei_seriesStmt?,
  tei_notesStmt?
tei_macro.glossSeq = tei_altIdent?, tei_equiv*, tei_gloss*, tei_desc*
tei_att.ascribed.attributes = att.ascribed.attribute.who, empty
att.ascribed.attribute.who =
  
  ## indicates the person, or group of
  ##	people, to whom the element content is ascribed.
  attribute who {
    list { tei_data.pointer+ }
  }?
tei_att.authorialIntervention.attributes =
  att.authorialIntervention.attribute.hand,
  att.authorialIntervention.attribute.status,
  att.authorialIntervention.attribute.type,
  empty
att.authorialIntervention.attribute.hand =
  
  ## signifies the hand of the agent which made the addition or
  ##       performed the deletion.
  attribute hand { tei_data.pointer }?
att.authorialIntervention.attribute.status =
  
  ## may be used to indicate faulty deletions, e.g. strikeouts
  ##       which include too much or too little text, or erroneous
  ##       additions, e.g., an insertion which duplicates some of the text
  ##       already present.
  ## Sample values include: 1] duplicate (all of the text indicated as an addition duplicates
  ##	  some text that is in the original, whether the duplication
  ##	  is word-for-word or less exact.); 2] duplicate-partial (part of the text indicated as an addition duplicates
  ##	  some text that is in the original); 3] excessStart (some text at the beginning of the deletion is marked
  ##           as deleted even though it clearly should not be
  ##           deleted.); 4] excessEnd (some text at the end of the deletion is marked as
  ##           deleted even though it clearly should not be
  ##           deleted.); 5] shortStart (some text at the beginning of the deletion is not
  ##           marked as deleted even though it clearly should be.); 6] shortEnd (some text at the end of the deletion is not marked as
  ##           deleted even though it clearly should be.); 7] unremarkable (the deletion is not faulty.)
  [ a1:defaultValue = "unremarkable" ]
  attribute status { tei_data.enumerated }?
att.authorialIntervention.attribute.type =
  
  ## classifies the type of addition or deletion using any convenient typology.
  attribute type { tei_data.enumerated }?
tei_att.datable.attributes =
  att.datable.attribute.notBefore,
  att.datable.attribute.notAfter,
  att.datable.attribute.from,
  att.datable.attribute.to,
  empty
att.datable.attribute.notBefore =
  
  ## specifies the earliest possible date for the event in
  ##	standard form, e.g. yyyy-mm-dd.
  attribute notBefore { tei_data.temporal }?
att.datable.attribute.notAfter =
  
  ## specifies the latest possible date for the event in
  ##	standard form, e.g. yyyy-mm-dd.
  attribute notAfter { tei_data.temporal }?
att.datable.attribute.from =
  
  ## indicates the starting point of the period in standard form.
  attribute from { tei_data.temporal }?
att.datable.attribute.to =
  
  ## indicates the ending point of the period in standard form.
  attribute to { tei_data.temporal }?
tei_att.datePart.attributes =
  att.datePart.attribute.value, att.datePart.attribute.dur, empty
att.datePart.attribute.value =
  
  ## supplies the value of a date or time in a standard form.
  attribute value { tei_data.temporal }?
att.datePart.attribute.dur =
  
  ## (duration) indicates the length of this element in time.
  attribute dur { xsd:duration }?
tei_att.declarable.attributes = att.declarable.attribute.default, empty
att.declarable.attribute.default =
  
  ## indicates whether or not this element is selected by default when
  ## its parent is selected.
  [ a1:defaultValue = "false" ]
  attribute default {
    
    ## (This element is selected if its parent is selected) 
    "true"
    | 
      ## (This element can only be selected explicitly, unless it is the
      ## only one of its kind, in which case it is selected if its parent is selected.) 
      "false"
  }?
tei_att.declaring.attributes = att.declaring.attribute.decls, empty
att.declaring.attribute.decls =
  
  ## identifies one or more declarable elements within the
  ## header, which are understood to apply to the element bearing this
  ## attribute and its content.
  attribute decls {
    list { tei_data.pointer+ }
  }?
tei_att.divLike.attributes =
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  empty
att.divLike.attribute.type =
  
  ## specifies a name conventionally used for this level of
  ##		subdivision, e.g. act, volume, book,
  ##		section, canto, etc.
  attribute type { tei_data.enumerated }?
att.divLike.attribute.org =
  
  ## specifies how the content of the division is organized.
  [ a1:defaultValue = "uniform" ]
  attribute org {
    
    ## (composite content: i.e. no claim is made about the
    ##		  sequence in which the immediate contents of this division
    ##		  are to be processed, or their inter-relationships.) 
    "composite"
    | 
      ## (uniform content: i.e. the immediate contents of this
      ##		  element are regarded as forming a logical unit, to be
      ##		  processed in sequence.) 
      "uniform"
  }?
att.divLike.attribute.sample =
  
  ## indicates whether this division is a sample of the
  ##		original source and if so, from which part.
  [ a1:defaultValue = "complete" ]
  attribute sample {
    
    ## (division lacks material present at end in source.) 
    "initial"
    | 
      ## (division lacks material at start and end.) 
      "medial"
    | 
      ## (division lacks material at start.) 
      "final"
    | 
      ## (position of sampled material within original unknown.) 
      "unknown"
    | 
      ## (division is not a sample.) 
      "complete"
  }?
att.divLike.attribute.part =
  
  ## specifies whether or not the division is fragmented by
  ##		some other structural element, for example a speech which is
  ##		divided between two or more verse stanzas.
  [ a1:defaultValue = "N" ]
  attribute part {
    
    ## (the division is incomplete in some respect) 
    "Y"
    | 
      ## (either the division is complete, or no claim is made as to its completeness.) 
      "N"
    | 
      ## (the initial part of an incomplete division) 
      "I"
    | 
      ## (a medial part of an incomplete division) 
      "M"
    | 
      ## (the final part of an incomplete division) 
      "F"
  }?
tei_att.interpLike.attributes =
  att.interpLike.attribute.resp,
  att.interpLike.attribute.type,
  att.interpLike.attribute.inst,
  empty
att.interpLike.attribute.resp =
  
  ## indicates who is responsible for the interpretation.
  attribute resp { tei_data.pointer }?
att.interpLike.attribute.type =
  
  ## indicates what kind of phenomenon is being noted in the passage.
  ## Sample values include: 1] image (identifies an image in the passage.
  ##    ); 2] character (identifies a character associated with the passage.
  ##    ); 3] theme (identifies a theme in the passage.
  ##    ); 4] allusion (identifies an allusion to another text.
  ##    )
  attribute type { tei_data.enumerated }?
att.interpLike.attribute.inst =
  
  ## points to instances of the analysis or interpretation represented
  ## by the current element.
  attribute inst {
    list { tei_data.pointer+ }
  }?
tei_att.editLike.attributes =
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
att.editLike.attribute.cert =
  
  ## signifies the degree of certainty associated with the
  ##	intervention or interpretation.
  attribute cert { tei_data.enumerated }?
att.editLike.attribute.resp =
  
  ## indicates the agency responsible for the
  ##	intervention or interpretation, for example an editor or transcriber.
  attribute resp { tei_data.pointer }?
att.editLike.attribute.evidence =
  
  ## indicates the nature of the evidence supporting the reliability or
  ##   accuracy of the intervention or interpretation.
  ## Sample values include: 1] internal (there is internal evidence to support the intervention.); 2] external (there is external evidence to support the intervention.); 3] conjecture (the intervention or interpretation has been made by
  ##	  the editor, cataloguer, or scholar on the basis of their expertise.)
  attribute evidence { tei_data.enumerated }?
tei_att.global.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
att.global.attribute.xmlspace =
  
  ## signals an intention that white space should be 
  ##       preserved by applications
  attribute xml:space {
    
    ##
    "default"
    | 
      ##
      "preserve"
  }?
att.global.attribute.xmlid =
  
  ## provides a unique identifier for the element bearing the
  ##       attribute.
  attribute xml:id { xsd:ID }?
att.global.attribute.n =
  
  ## gives a number (or other label) for an element, which is
  ##       not necessarily unique within the document.
  attribute n {
    list { tei_data.word+ }
  }?
att.global.attribute.xmllang =
  
  ## indicates the language of the element content using the
  ##       codes from RFC
  ##       3066
  attribute xml:lang { tei_data.language }?
att.global.attribute.rend =
  
  ## indicates how the element in question was rendered or
  ##	presented in the source text.
  attribute rend {
    list { tei_data.word+ }
  }?
att.global.attribute.xmlbase =
  
  ## provides a base URI reference with which applications can
  ##       resolve relative URI references into absolute URI
  ##       references.
  attribute xml:base { tei_data.pointer }?
tei_att.measured.attributes =
  att.measured.attribute.unit, att.measured.attribute.scope, empty
att.measured.attribute.unit =
  
  ## names the units used for the measurement.
  ## Suggested values include: 1] cm (centimetres); 2] mm (millimetres); 3] in (inches)
  attribute unit { tei_data.enumerated }?
att.measured.attribute.scope =
  
  ## specifies the applicability of this measurement, where
  ##    more than one object is being measured.
  ## Sample values include: 1] all (measurement applies to all instances.); 2] most (measurement applies to most of the instances inspected.); 3] range (measurement applies to only the specified range of instances.)
  attribute scope { tei_data.enumerated }?
tei_att.measurement.attributes =
  att.measurement.attribute.unit,
  att.measurement.attribute.quantity,
  att.measurement.attribute.commodity,
  empty
att.measurement.attribute.unit =
  
  ## indicates the units used for the measurement, usually
  ##       using the standard symbol for the desired units.
  ## Suggested values include: 1] m (metre); 2] kg (kilogram); 3] s (second); 4] Hz (hertz); 5] Pa (pascal); 6]  (ohm); 7] L (litre); 8] t (tonne); 9] ha (hectare); 10]  (ngstrm); 11] mL (millilitre); 12] cm (centimetre); 13] dB (decibel); 14] kbit (kilobit); 15] Kibit (kibibit); 16] kB (kilobyte); 17] KiB (kibibyte); 18] MB (megabyte); 19] MiB (mebibyte)
  attribute unit { tei_data.enumerated }?
att.measurement.attribute.quantity =
  
  ## specifies the number of the specified units that
  ##       comprise the measurement
  attribute quantity { tei_data.numeric }?
att.measurement.attribute.commodity =
  
  ## indicates the substance that is being measured
  attribute commodity {
    list { tei_data.word+ }
  }?
tei_att.naming.attributes = att.naming.attribute.key, empty
att.naming.attribute.key =
  
  ## provides a means of locating a full definition for the
  ##       entity being named such as a database record key or a
  ##       URI.
  attribute key { tei_data.key }?
tei_att.placement.attributes = att.placement.attribute.place, empty
att.placement.attribute.place =
  
  ## 
  ## Suggested values include: 1] infralinear (below the line); 2] margin-bot (in bottom margin); 3] margin-left (in left margin); 4] margin-right (in right margin); 5] margin-top (in top margin); 6] opposite (on opposite page); 7] overleaf (on the other side of the leaf); 8] supralinear (above the line); 9] verso (on verso of sheet); 10] app (note appears in the apparatus at the foot of the page.); 11] end (note appears at end of chapter or volume.); 12] foot (note appears at foot of page.); 13] inline (note appears as a marked paragraph in the body of the text.); 14] interlinear (note appears between lines of the text; a less precise form of either infralinear or supralinear.); 15] inline (addition is made in a space left in the witness by an earlier scribe.); 16] mixed (one or more of the other values)
  attribute place { tei_data.enumerated }?
tei_att.segLike.attributes =
  att.segLike.attribute.type,
  att.segLike.attribute.function,
  att.segLike.attribute.part,
  empty
att.segLike.attribute.type =
  
  ## characterizes the type of segment.
  attribute type { tei_data.enumerated }?
att.segLike.attribute.function =
  
  ## characterizes the function of the segment.
  attribute function { tei_data.enumerated }?
att.segLike.attribute.part =
  
  ## specifies whether or not the segment is fragmented by some other
  ## structural element, for example a clause which is divided between two
  ## or more sentences.
  [ a1:defaultValue = "N" ]
  attribute part {
    
    ## (the segment is incomplete in some respect) 
    "Y"
    | 
      ## (either the segment is complete, or no claim is made as to
      ## its completeness) 
      "N"
    | 
      ## (the initial part of an incomplete segment) 
      "I"
    | 
      ## (a medial part of an incomplete segment) 
      "M"
    | 
      ## (the final part of an incomplete segment) 
      "F"
  }?
tei_att.spanning.attributes = att.spanning.attribute.spanTo, empty
att.spanning.attribute.spanTo =
  
  ## indicates the end of a span initiated by the element
  ##	bearing this attribute.
  attribute spanTo { tei_data.pointer }?
tei_att.tableDecoration.attributes =
  att.tableDecoration.attribute.role,
  att.tableDecoration.attribute.rows,
  att.tableDecoration.attribute.cols,
  empty
att.tableDecoration.attribute.role =
  
  ## indicates the kind of information held in this cell or
  ## in each cell of this row.
  ## Suggested values include: 1] label (labelling or descriptive information only.); 2] data (data values.)
  [ a1:defaultValue = "data" ] attribute role { tei_data.enumerated }?
att.tableDecoration.attribute.rows =
  
  ## indicates the number of rows occupied by this cell or row.
  [ a1:defaultValue = "1" ] attribute rows { tei_data.count }?
att.tableDecoration.attribute.cols =
  
  ## indicates the number of columns occupied by this cell or
  ##	row.
  [ a1:defaultValue = "1" ] attribute cols { tei_data.count }?
tei_att.timed.attributes =
  att.timed.attribute.start,
  att.timed.attribute.end,
  att.timed.attribute.dur,
  empty
att.timed.attribute.start =
  
  ## indicates the location within a temporal alignment
  ##       at which this element begins.
  attribute start { tei_data.pointer }?
att.timed.attribute.end =
  
  ## indicates the location within a temporal alignment at which
  ##    this element ends.
  attribute end { tei_data.pointer }?
att.timed.attribute.dur =
  
  ## (duration) indicates the length of this element in time
  attribute dur { xsd:duration }?
tei_att.translatable.attributes =
  att.translatable.attribute.version, empty
att.translatable.attribute.version =
  
  ## specifies the version name or number of the source from
  ##	which the translated version was derived
  attribute version { tei_data.word }?
tei_att.typed.attributes =
  att.typed.attribute.type, att.typed.attribute.subtype, empty
att.typed.attribute.type =
  
  ## characterizes the element in some sense, using any convenient
  ##  classification scheme or typology.
  attribute type { tei_data.word }?
att.typed.attribute.subtype =
  
  ## provides a sub-categorization of the element, if needed
  attribute subtype { tei_data.word }?
tei_model.nameLike.agent = tei_name
tei_model.nameLike.agent_sequence = tei_name
tei_model.nameLike.agent_sequenceOptional = tei_name?
tei_model.nameLike.agent_sequenceOptionalRepeatable = tei_name*
tei_model.nameLike.agent_sequenceRepeatable = tei_name+
tei_model.segLike = notAllowed
tei_model.segLike_sequence = empty
tei_model.segLike_sequenceOptional = empty
tei_model.segLike_sequenceOptionalRepeatable = empty
tei_model.segLike_sequenceRepeatable = notAllowed
tei_model.hiLike =
  tei_foreign
  | tei_emph
  | tei_hi
  | tei_distinct
  | tei_mentioned
  | tei_soCalled
  | tei_gloss
  | tei_term
  | tei_title
tei_model.hiLike_sequence =
  tei_foreign,
  tei_emph,
  tei_hi,
  tei_distinct,
  tei_mentioned,
  tei_soCalled,
  tei_gloss,
  tei_term,
  tei_title
tei_model.hiLike_sequenceOptional =
  tei_foreign?,
  tei_emph?,
  tei_hi?,
  tei_distinct?,
  tei_mentioned?,
  tei_soCalled?,
  tei_gloss?,
  tei_term?,
  tei_title?
tei_model.hiLike_sequenceOptionalRepeatable =
  tei_foreign*,
  tei_emph*,
  tei_hi*,
  tei_distinct*,
  tei_mentioned*,
  tei_soCalled*,
  tei_gloss*,
  tei_term*,
  tei_title*
tei_model.hiLike_sequenceRepeatable =
  tei_foreign+,
  tei_emph+,
  tei_hi+,
  tei_distinct+,
  tei_mentioned+,
  tei_soCalled+,
  tei_gloss+,
  tei_term+,
  tei_title+
tei_model.dateLike = tei_date | tei_time
tei_model.dateLike_sequence = tei_date, tei_time
tei_model.dateLike_sequenceOptional = tei_date?, tei_time?
tei_model.dateLike_sequenceOptionalRepeatable = tei_date*, tei_time*
tei_model.dateLike_sequenceRepeatable = tei_date+, tei_time+
tei_model.measureLike = tei_num | tei_measure
tei_model.measureLike_sequence = tei_num, tei_measure
tei_model.measureLike_sequenceOptional = tei_num?, tei_measure?
tei_model.measureLike_sequenceOptionalRepeatable =
  tei_num*, tei_measure*
tei_model.measureLike_sequenceRepeatable = tei_num+, tei_measure+
tei_model.graphicLike = tei_graphic | tei_binaryObject | tei_formula
tei_model.graphicLike_sequence =
  tei_graphic, tei_binaryObject, tei_formula
tei_model.graphicLike_sequenceOptional =
  tei_graphic?, tei_binaryObject?, tei_formula?
tei_model.graphicLike_sequenceOptionalRepeatable =
  tei_graphic*, tei_binaryObject*, tei_formula*
tei_model.graphicLike_sequenceRepeatable =
  tei_graphic+, tei_binaryObject+, tei_formula+
tei_model.pPart.msdesc = notAllowed
tei_model.pPart.msdesc_sequence = empty
tei_model.pPart.msdesc_sequenceOptional = empty
tei_model.pPart.msdesc_sequenceOptionalRepeatable = empty
tei_model.pPart.msdesc_sequenceRepeatable = notAllowed
tei_model.pPart.edit =
  tei_sic
  | tei_corr
  | tei_choice
  | tei_reg
  | tei_orig
  | tei_add
  | tei_del
  | tei_unclear
  | tei_abbr
  | tei_expan
tei_model.pPart.edit_sequence =
  tei_sic,
  tei_corr,
  tei_choice,
  tei_reg,
  tei_orig,
  tei_add,
  tei_del,
  tei_unclear,
  tei_abbr,
  tei_expan
tei_model.pPart.edit_sequenceOptional =
  tei_sic?,
  tei_corr?,
  tei_choice?,
  tei_reg?,
  tei_orig?,
  tei_add?,
  tei_del?,
  tei_unclear?,
  tei_abbr?,
  tei_expan?
tei_model.pPart.edit_sequenceOptionalRepeatable =
  tei_sic*,
  tei_corr*,
  tei_choice*,
  tei_reg*,
  tei_orig*,
  tei_add*,
  tei_del*,
  tei_unclear*,
  tei_abbr*,
  tei_expan*
tei_model.pPart.edit_sequenceRepeatable =
  tei_sic+,
  tei_corr+,
  tei_choice+,
  tei_reg+,
  tei_orig+,
  tei_add+,
  tei_del+,
  tei_unclear+,
  tei_abbr+,
  tei_expan+
tei_model.ptrLike = tei_ptr | tei_ref
tei_model.ptrLike_sequence = tei_ptr, tei_ref
tei_model.ptrLike_sequenceOptional = tei_ptr?, tei_ref?
tei_model.ptrLike_sequenceOptionalRepeatable = tei_ptr*, tei_ref*
tei_model.ptrLike_sequenceRepeatable = tei_ptr+, tei_ref+
tei_model.lPart = notAllowed
tei_model.lPart_sequence = empty
tei_model.lPart_sequenceOptional = empty
tei_model.lPart_sequenceOptionalRepeatable = empty
tei_model.lPart_sequenceRepeatable = notAllowed
tei_model.global.meta = tei_index
tei_model.global.meta_sequence = tei_index
tei_model.global.meta_sequenceOptional = tei_index?
tei_model.global.meta_sequenceOptionalRepeatable = tei_index*
tei_model.global.meta_sequenceRepeatable = tei_index+
tei_model.milestoneLike = tei_milestone | tei_pb | tei_lb | tei_cb
tei_model.milestoneLike_sequence = tei_milestone, tei_pb, tei_lb, tei_cb
tei_model.milestoneLike_sequenceOptional =
  tei_milestone?, tei_pb?, tei_lb?, tei_cb?
tei_model.milestoneLike_sequenceOptionalRepeatable =
  tei_milestone*, tei_pb*, tei_lb*, tei_cb*
tei_model.milestoneLike_sequenceRepeatable =
  tei_milestone+, tei_pb+, tei_lb+, tei_cb+
tei_model.gLike = notAllowed
tei_model.gLike_sequence = empty
tei_model.gLike_sequenceOptional = empty
tei_model.gLike_sequenceOptionalRepeatable = empty
tei_model.gLike_sequenceRepeatable = notAllowed
tei_model.oddDecl = notAllowed
tei_model.oddDecl_sequence = empty
tei_model.oddDecl_sequenceOptional = empty
tei_model.oddDecl_sequenceOptionalRepeatable = empty
tei_model.oddDecl_sequenceRepeatable = notAllowed
tei_model.oddRef = notAllowed
tei_model.oddRef_sequence = empty
tei_model.oddRef_sequenceOptional = empty
tei_model.oddRef_sequenceOptionalRepeatable = empty
tei_model.oddRef_sequenceRepeatable = notAllowed
tei_model.oddPhr = notAllowed
tei_model.oddPhr_sequence = empty
tei_model.oddPhr_sequenceOptional = empty
tei_model.oddPhr_sequenceOptionalRepeatable = empty
tei_model.oddPhr_sequenceRepeatable = notAllowed
tei_model.qLike = tei_q | tei_quote | tei_cit
tei_model.qLike_sequence = tei_q, tei_quote, tei_cit
tei_model.qLike_sequenceOptional = tei_q?, tei_quote?, tei_cit?
tei_model.qLike_sequenceOptionalRepeatable =
  tei_q*, tei_quote*, tei_cit*
tei_model.qLike_sequenceRepeatable = tei_q+, tei_quote+, tei_cit+
tei_model.biblLike =
  tei_bibl | tei_biblItem | tei_biblStruct | tei_biblFull
tei_model.biblLike_sequence =
  tei_bibl, tei_biblItem, tei_biblStruct, tei_biblFull
tei_model.biblLike_sequenceOptional =
  tei_bibl?, tei_biblItem?, tei_biblStruct?, tei_biblFull?
tei_model.biblLike_sequenceOptionalRepeatable =
  tei_bibl*, tei_biblItem*, tei_biblStruct*, tei_biblFull*
tei_model.biblLike_sequenceRepeatable =
  tei_bibl+, tei_biblItem+, tei_biblStruct+, tei_biblFull+
tei_model.listLike = tei_list | tei_listBibl
tei_model.listLike_sequence = tei_list, tei_listBibl
tei_model.listLike_sequenceOptional = tei_list?, tei_listBibl?
tei_model.listLike_sequenceOptionalRepeatable = tei_list*, tei_listBibl*
tei_model.listLike_sequenceRepeatable = tei_list+, tei_listBibl+
tei_model.noteLike = tei_note
tei_model.noteLike_sequence = tei_note
tei_model.noteLike_sequenceOptional = tei_note?
tei_model.noteLike_sequenceOptionalRepeatable = tei_note*
tei_model.noteLike_sequenceRepeatable = tei_note+
tei_model.stageLike = tei_stage
tei_model.stageLike_sequence = tei_stage
tei_model.stageLike_sequenceOptional = tei_stage?
tei_model.stageLike_sequenceOptionalRepeatable = tei_stage*
tei_model.stageLike_sequenceRepeatable = tei_stage+
tei_model.complexVal = notAllowed
tei_model.complexVal_sequence = empty
tei_model.complexVal_sequenceOptional = empty
tei_model.complexVal_sequenceOptionalRepeatable = empty
tei_model.complexVal_sequenceRepeatable = notAllowed
tei_model.singleVal = notAllowed
tei_model.singleVal_sequence = empty
tei_model.singleVal_sequenceOptional = empty
tei_model.singleVal_sequenceOptionalRepeatable = empty
tei_model.singleVal_sequenceRepeatable = notAllowed
tei_model.entryParts.top = notAllowed
tei_model.entryParts.top_sequence = empty
tei_model.entryParts.top_sequenceOptional = empty
tei_model.entryParts.top_sequenceOptionalRepeatable = empty
tei_model.entryParts.top_sequenceRepeatable = notAllowed
tei_model.global.edit = tei_gap
tei_model.global.edit_sequence = tei_gap
tei_model.global.edit_sequenceOptional = tei_gap?
tei_model.global.edit_sequenceOptionalRepeatable = tei_gap*
tei_model.global.edit_sequenceRepeatable = tei_gap+
tei_model.divPart = tei_p | tei_l | tei_lg | tei_sp
tei_model.divPart_sequence = tei_p, tei_l, tei_lg, tei_sp
tei_model.divPart_sequenceOptional = tei_p?, tei_l?, tei_lg?, tei_sp?
tei_model.divPart_sequenceOptionalRepeatable =
  tei_p*, tei_l*, tei_lg*, tei_sp*
tei_model.divPart_sequenceRepeatable = tei_p+, tei_l+, tei_lg+, tei_sp+
tei_model.blockLike = notAllowed
tei_model.blockLike_sequence = empty
tei_model.blockLike_sequenceOptional = empty
tei_model.blockLike_sequenceOptionalRepeatable = empty
tei_model.blockLike_sequenceRepeatable = notAllowed
tei_model.pLike = tei_p
tei_model.pLike_sequence = tei_p
tei_model.pLike_sequenceOptional = tei_p?
tei_model.pLike_sequenceOptionalRepeatable = tei_p*
tei_model.pLike_sequenceRepeatable = tei_p+
tei_model.persTraitLike = notAllowed
tei_model.persTraitLike_sequence = empty
tei_model.persTraitLike_sequenceOptional = empty
tei_model.persTraitLike_sequenceOptionalRepeatable = empty
tei_model.persTraitLike_sequenceRepeatable = notAllowed
tei_model.persStateLike = notAllowed
tei_model.persStateLike_sequence = empty
tei_model.persStateLike_sequenceOptional = empty
tei_model.persStateLike_sequenceOptionalRepeatable = empty
tei_model.persStateLike_sequenceRepeatable = notAllowed
tei_model.persEventLike = notAllowed
tei_model.persEventLike_sequence = empty
tei_model.persEventLike_sequenceOptional = empty
tei_model.persEventLike_sequenceOptionalRepeatable = empty
tei_model.persEventLike_sequenceRepeatable = notAllowed
tei_model.assertLike =
  tei_model.persTraitLike
  | tei_model.persStateLike
  | tei_model.persEventLike
tei_model.assertLike_sequence =
  tei_model.persTraitLike,
  tei_model.persStateLike,
  tei_model.persEventLike
tei_model.assertLike_sequenceOptional =
  tei_model.persTraitLike?,
  tei_model.persStateLike?,
  tei_model.persEventLike?
tei_model.assertLike_sequenceOptionalRepeatable =
  tei_model.persTraitLike*,
  tei_model.persStateLike*,
  tei_model.persEventLike*
tei_model.assertLike_sequenceRepeatable =
  tei_model.persTraitLike+,
  tei_model.persStateLike+,
  tei_model.persEventLike+
tei_model.personLike = notAllowed
tei_model.personLike_sequence = empty
tei_model.personLike_sequenceOptional = empty
tei_model.personLike_sequenceOptionalRepeatable = empty
tei_model.personLike_sequenceRepeatable = notAllowed
tei_model.personPart = tei_model.assertLike | tei_bibl
tei_model.personPart_sequence = tei_model.assertLike, tei_bibl
tei_model.personPart_sequenceOptional = tei_model.assertLike?, tei_bibl?
tei_model.personPart_sequenceOptionalRepeatable =
  tei_model.assertLike*, tei_bibl*
tei_model.personPart_sequenceRepeatable =
  tei_model.assertLike+, tei_bibl+
tei_model.publicationStmtPart =
  tei_address
  | tei_date
  | tei_publisher
  | tei_pubPlace
  | tei_distributor
  | tei_authority
  | tei_idno
  | tei_availability
tei_model.publicationStmtPart_sequence =
  tei_address,
  tei_date,
  tei_publisher,
  tei_pubPlace,
  tei_distributor,
  tei_authority,
  tei_idno,
  tei_availability
tei_model.publicationStmtPart_sequenceOptional =
  tei_address?,
  tei_date?,
  tei_publisher?,
  tei_pubPlace?,
  tei_distributor?,
  tei_authority?,
  tei_idno?,
  tei_availability?
tei_model.publicationStmtPart_sequenceOptionalRepeatable =
  tei_address*,
  tei_date*,
  tei_publisher*,
  tei_pubPlace*,
  tei_distributor*,
  tei_authority*,
  tei_idno*,
  tei_availability*
tei_model.publicationStmtPart_sequenceRepeatable =
  tei_address+,
  tei_date+,
  tei_publisher+,
  tei_pubPlace+,
  tei_distributor+,
  tei_authority+,
  tei_idno+,
  tei_availability+
tei_model.glossLike = tei_altIdent | tei_desc | tei_equiv | tei_gloss
tei_model.glossLike_sequence =
  tei_altIdent, tei_desc, tei_equiv, tei_gloss
tei_model.glossLike_sequenceOptional =
  tei_altIdent?, tei_desc?, tei_equiv?, tei_gloss?
tei_model.glossLike_sequenceOptionalRepeatable =
  tei_altIdent*, tei_desc*, tei_equiv*, tei_gloss*
tei_model.glossLike_sequenceRepeatable =
  tei_altIdent+, tei_desc+, tei_equiv+, tei_gloss+
tei_model.quoteLike = tei_quote
tei_model.quoteLike_sequence = tei_quote
tei_model.quoteLike_sequenceOptional = tei_quote?
tei_model.quoteLike_sequenceOptionalRepeatable = tei_quote*
tei_model.quoteLike_sequenceRepeatable = tei_quote+
tei_model.respLike = tei_author | tei_editor | tei_respStmt
tei_model.respLike_sequence = tei_author, tei_editor, tei_respStmt
tei_model.respLike_sequenceOptional =
  tei_author?, tei_editor?, tei_respStmt?
tei_model.respLike_sequenceOptionalRepeatable =
  tei_author*, tei_editor*, tei_respStmt*
tei_model.respLike_sequenceRepeatable =
  tei_author+, tei_editor+, tei_respStmt+
tei_model.divWrapper.bottom = tei_trailer | tei_closer | tei_signed
tei_model.divWrapper.bottom_sequence =
  tei_trailer, tei_closer, tei_signed
tei_model.divWrapper.bottom_sequenceOptional =
  tei_trailer?, tei_closer?, tei_signed?
tei_model.divWrapper.bottom_sequenceOptionalRepeatable =
  tei_trailer*, tei_closer*, tei_signed*
tei_model.divWrapper.bottom_sequenceRepeatable =
  tei_trailer+, tei_closer+, tei_signed+
tei_model.divWrapper =
  tei_head
  | tei_byline
  | tei_dateline
  | tei_argument
  | tei_epigraph
  | tei_opener
  | tei_salute
  | tei_docAuthor
  | tei_docDate
tei_model.divWrapper_sequence =
  tei_head,
  tei_byline,
  tei_dateline,
  tei_argument,
  tei_epigraph,
  tei_opener,
  tei_salute,
  tei_docAuthor,
  tei_docDate
tei_model.divWrapper_sequenceOptional =
  tei_head?,
  tei_byline?,
  tei_dateline?,
  tei_argument?,
  tei_epigraph?,
  tei_opener?,
  tei_salute?,
  tei_docAuthor?,
  tei_docDate?
tei_model.divWrapper_sequenceOptionalRepeatable =
  tei_head*,
  tei_byline*,
  tei_dateline*,
  tei_argument*,
  tei_epigraph*,
  tei_opener*,
  tei_salute*,
  tei_docAuthor*,
  tei_docDate*
tei_model.divWrapper_sequenceRepeatable =
  tei_head+,
  tei_byline+,
  tei_dateline+,
  tei_argument+,
  tei_epigraph+,
  tei_opener+,
  tei_salute+,
  tei_docAuthor+,
  tei_docDate+
tei_model.frontPart.drama = notAllowed
tei_model.frontPart.drama_sequence = empty
tei_model.frontPart.drama_sequenceOptional = empty
tei_model.frontPart.drama_sequenceOptionalRepeatable = empty
tei_model.frontPart.drama_sequenceRepeatable = notAllowed
tei_model.pLike.front =
  tei_head
  | tei_byline
  | tei_argument
  | tei_epigraph
  | tei_docTitle
  | tei_titlePart
  | tei_docAuthor
  | tei_docEdition
  | tei_docImprint
  | tei_docDate
tei_model.pLike.front_sequence =
  tei_head,
  tei_byline,
  tei_argument,
  tei_epigraph,
  tei_docTitle,
  tei_titlePart,
  tei_docAuthor,
  tei_docEdition,
  tei_docImprint,
  tei_docDate
tei_model.pLike.front_sequenceOptional =
  tei_head?,
  tei_byline?,
  tei_argument?,
  tei_epigraph?,
  tei_docTitle?,
  tei_titlePart?,
  tei_docAuthor?,
  tei_docEdition?,
  tei_docImprint?,
  tei_docDate?
tei_model.pLike.front_sequenceOptionalRepeatable =
  tei_head*,
  tei_byline*,
  tei_argument*,
  tei_epigraph*,
  tei_docTitle*,
  tei_titlePart*,
  tei_docAuthor*,
  tei_docEdition*,
  tei_docImprint*,
  tei_docDate*
tei_model.pLike.front_sequenceRepeatable =
  tei_head+,
  tei_byline+,
  tei_argument+,
  tei_epigraph+,
  tei_docTitle+,
  tei_titlePart+,
  tei_docAuthor+,
  tei_docEdition+,
  tei_docImprint+,
  tei_docDate+
tei_model.titlepagePart =
  tei_graphic
  | tei_binaryObject
  | tei_byline
  | tei_epigraph
  | tei_docTitle
  | tei_titlePart
  | tei_docAuthor
  | tei_imprimatur
  | tei_docEdition
  | tei_docImprint
  | tei_docDate
  | tei_figure
tei_model.titlepagePart_sequence =
  tei_graphic,
  tei_binaryObject,
  tei_byline,
  tei_epigraph,
  tei_docTitle,
  tei_titlePart,
  tei_docAuthor,
  tei_imprimatur,
  tei_docEdition,
  tei_docImprint,
  tei_docDate,
  tei_figure
tei_model.titlepagePart_sequenceOptional =
  tei_graphic?,
  tei_binaryObject?,
  tei_byline?,
  tei_epigraph?,
  tei_docTitle?,
  tei_titlePart?,
  tei_docAuthor?,
  tei_imprimatur?,
  tei_docEdition?,
  tei_docImprint?,
  tei_docDate?,
  tei_figure?
tei_model.titlepagePart_sequenceOptionalRepeatable =
  tei_graphic*,
  tei_binaryObject*,
  tei_byline*,
  tei_epigraph*,
  tei_docTitle*,
  tei_titlePart*,
  tei_docAuthor*,
  tei_imprimatur*,
  tei_docEdition*,
  tei_docImprint*,
  tei_docDate*,
  tei_figure*
tei_model.titlepagePart_sequenceRepeatable =
  tei_graphic+,
  tei_binaryObject+,
  tei_byline+,
  tei_epigraph+,
  tei_docTitle+,
  tei_titlePart+,
  tei_docAuthor+,
  tei_imprimatur+,
  tei_docEdition+,
  tei_docImprint+,
  tei_docDate+,
  tei_figure+
tei_model.msItemPart =
  tei_model.quoteLike
  | tei_model.respLike
  | tei_bibl
  | tei_listBibl
  | tei_title
tei_model.msItemPart_sequence =
  tei_model.quoteLike,
  tei_model.respLike,
  tei_bibl,
  tei_listBibl,
  tei_title
tei_model.msItemPart_sequenceOptional =
  tei_model.quoteLike?,
  tei_model.respLike?,
  tei_bibl?,
  tei_listBibl?,
  tei_title?
tei_model.msItemPart_sequenceOptionalRepeatable =
  tei_model.quoteLike*,
  tei_model.respLike*,
  tei_bibl*,
  tei_listBibl*,
  tei_title*
tei_model.msItemPart_sequenceRepeatable =
  tei_model.quoteLike+,
  tei_model.respLike+,
  tei_bibl+,
  tei_listBibl+,
  tei_title+
tei_model.choicePart =
  tei_sic
  | tei_corr
  | tei_reg
  | tei_orig
  | tei_unclear
  | tei_abbr
  | tei_expan
tei_model.choicePart_sequence =
  tei_sic, tei_corr, tei_reg, tei_orig, tei_unclear, tei_abbr, tei_expan
tei_model.choicePart_sequenceOptional =
  tei_sic?,
  tei_corr?,
  tei_reg?,
  tei_orig?,
  tei_unclear?,
  tei_abbr?,
  tei_expan?
tei_model.choicePart_sequenceOptionalRepeatable =
  tei_sic*,
  tei_corr*,
  tei_reg*,
  tei_orig*,
  tei_unclear*,
  tei_abbr*,
  tei_expan*
tei_model.choicePart_sequenceRepeatable =
  tei_sic+,
  tei_corr+,
  tei_reg+,
  tei_orig+,
  tei_unclear+,
  tei_abbr+,
  tei_expan+
tei_model.lLike = tei_l
tei_model.lLike_sequence = tei_l
tei_model.lLike_sequenceOptional = tei_l?
tei_model.lLike_sequenceOptionalRepeatable = tei_l*
tei_model.lLike_sequenceRepeatable = tei_l+
tei_model.recordingPart =
  tei_model.dateLike | tei_respStmt | tei_equipment | tei_broadcast
tei_model.recordingPart_sequence =
  tei_model.dateLike, tei_respStmt, tei_equipment, tei_broadcast
tei_model.recordingPart_sequenceOptional =
  tei_model.dateLike?, tei_respStmt?, tei_equipment?, tei_broadcast?
tei_model.recordingPart_sequenceOptionalRepeatable =
  tei_model.dateLike*, tei_respStmt*, tei_equipment*, tei_broadcast*
tei_model.recordingPart_sequenceRepeatable =
  tei_model.dateLike+, tei_respStmt+, tei_equipment+, tei_broadcast+
tei_model.imprintPart = tei_publisher | tei_biblScope | tei_pubPlace
tei_model.imprintPart_sequence =
  tei_publisher, tei_biblScope, tei_pubPlace
tei_model.imprintPart_sequenceOptional =
  tei_publisher?, tei_biblScope?, tei_pubPlace?
tei_model.imprintPart_sequenceOptionalRepeatable =
  tei_publisher*, tei_biblScope*, tei_pubPlace*
tei_model.imprintPart_sequenceRepeatable =
  tei_publisher+, tei_biblScope+, tei_pubPlace+
tei_model.catDescPart = notAllowed
tei_model.catDescPart_sequence = empty
tei_model.catDescPart_sequenceOptional = empty
tei_model.catDescPart_sequenceOptionalRepeatable = empty
tei_model.catDescPart_sequenceRepeatable = notAllowed
tei_model.settingPart = notAllowed
tei_model.settingPart_sequence = empty
tei_model.settingPart_sequenceOptional = empty
tei_model.settingPart_sequenceOptionalRepeatable = empty
tei_model.settingPart_sequenceRepeatable = notAllowed
tei_model.textDescPart_sequence = empty
tei_model.castItemPart = notAllowed
tei_model.castItemPart_sequence = empty
tei_model.castItemPart_sequenceOptional = empty
tei_model.castItemPart_sequenceOptionalRepeatable = empty
tei_model.castItemPart_sequenceRepeatable = notAllowed
tei_model.physDescPart_sequenceOptional = empty
tei_model.addressLike = tei_email | tei_address
tei_model.addressLike_sequence = tei_email, tei_address
tei_model.addressLike_sequenceOptional = tei_email?, tei_address?
tei_model.addressLike_sequenceOptionalRepeatable =
  tei_email*, tei_address*
tei_model.addressLike_sequenceRepeatable = tei_email+, tei_address+
tei_model.nameLike = tei_model.nameLike.agent | tei_rs
tei_model.nameLike_sequence = tei_model.nameLike.agent, tei_rs
tei_model.nameLike_sequenceOptional = tei_model.nameLike.agent?, tei_rs?
tei_model.nameLike_sequenceOptionalRepeatable =
  tei_model.nameLike.agent*, tei_rs*
tei_model.nameLike_sequenceRepeatable =
  tei_model.nameLike.agent+, tei_rs+
tei_model.global =
  tei_model.global.meta
  | tei_model.milestoneLike
  | tei_model.noteLike
  | tei_model.global.edit
tei_model.global_sequence =
  tei_model.global.meta,
  tei_model.milestoneLike,
  tei_model.noteLike,
  tei_model.global.edit
tei_model.global_sequenceOptional =
  tei_model.global.meta?,
  tei_model.milestoneLike?,
  tei_model.noteLike?,
  tei_model.global.edit?
tei_model.global_sequenceOptionalRepeatable =
  tei_model.global.meta*,
  tei_model.milestoneLike*,
  tei_model.noteLike*,
  tei_model.global.edit*
tei_model.global_sequenceRepeatable =
  tei_model.global.meta+,
  tei_model.milestoneLike+,
  tei_model.noteLike+,
  tei_model.global.edit+
tei_model.featureVal = tei_model.complexVal | tei_model.singleVal
tei_model.featureVal_sequence =
  tei_model.complexVal, tei_model.singleVal
tei_model.featureVal_sequenceOptional =
  tei_model.complexVal?, tei_model.singleVal?
tei_model.featureVal_sequenceOptionalRepeatable =
  tei_model.complexVal*, tei_model.singleVal*
tei_model.featureVal_sequenceRepeatable =
  tei_model.complexVal+, tei_model.singleVal+
tei_model.common =
  tei_model.oddDecl
  | tei_model.oddRef
  | tei_model.qLike
  | tei_model.biblLike
  | tei_model.listLike
  | tei_model.divPart
  | tei_label
  | tei_table
  | tei_figure
tei_model.common_sequence =
  tei_model.oddDecl,
  tei_model.oddRef,
  tei_model.qLike,
  tei_model.biblLike,
  tei_model.listLike,
  tei_model.divPart,
  tei_label,
  tei_table,
  tei_figure
tei_model.common_sequenceOptional =
  tei_model.oddDecl?,
  tei_model.oddRef?,
  tei_model.qLike?,
  tei_model.biblLike?,
  tei_model.listLike?,
  tei_model.divPart?,
  tei_label?,
  tei_table?,
  tei_figure?
tei_model.common_sequenceOptionalRepeatable =
  tei_model.oddDecl*,
  tei_model.oddRef*,
  tei_model.qLike*,
  tei_model.biblLike*,
  tei_model.listLike*,
  tei_model.divPart*,
  tei_label*,
  tei_table*,
  tei_figure*
tei_model.common_sequenceRepeatable =
  tei_model.oddDecl+,
  tei_model.oddRef+,
  tei_model.qLike+,
  tei_model.biblLike+,
  tei_model.listLike+,
  tei_model.divPart+,
  tei_label+,
  tei_table+,
  tei_figure+
tei_model.biblPart =
  tei_model.respLike
  | tei_model.imprintPart
  | tei_series
  | tei_edition
  | tei_extent
  | tei_distributor
  | tei_idno
tei_model.biblPart_sequence =
  tei_model.respLike,
  tei_model.imprintPart,
  tei_series,
  tei_edition,
  tei_extent,
  tei_distributor,
  tei_idno
tei_model.biblPart_sequenceOptional =
  tei_model.respLike?,
  tei_model.imprintPart?,
  tei_series?,
  tei_edition?,
  tei_extent?,
  tei_distributor?,
  tei_idno?
tei_model.biblPart_sequenceOptionalRepeatable =
  tei_model.respLike*,
  tei_model.imprintPart*,
  tei_series*,
  tei_edition*,
  tei_extent*,
  tei_distributor*,
  tei_idno*
tei_model.biblPart_sequenceRepeatable =
  tei_model.respLike+,
  tei_model.imprintPart+,
  tei_series+,
  tei_edition+,
  tei_extent+,
  tei_distributor+,
  tei_idno+
tei_model.datePart = notAllowed
tei_model.datePart_sequence = empty
tei_model.datePart_sequenceOptional = empty
tei_model.datePart_sequenceOptionalRepeatable = empty
tei_model.datePart_sequenceRepeatable = notAllowed
tei_model.frontPart =
  tei_model.frontPart.drama | tei_divGen | tei_titlePage
tei_model.frontPart_sequence =
  tei_model.frontPart.drama, tei_divGen, tei_titlePage
tei_model.frontPart_sequenceOptional =
  tei_model.frontPart.drama?, tei_divGen?, tei_titlePage?
tei_model.frontPart_sequenceOptionalRepeatable =
  tei_model.frontPart.drama*, tei_divGen*, tei_titlePage*
tei_model.frontPart_sequenceRepeatable =
  tei_model.frontPart.drama+, tei_divGen+, tei_titlePage+
tei_model.addrPart =
  tei_model.nameLike
  | tei_addrLine
  | tei_street
  | tei_postCode
  | tei_postBox
tei_model.addrPart_sequence =
  tei_model.nameLike,
  tei_addrLine,
  tei_street,
  tei_postCode,
  tei_postBox
tei_model.addrPart_sequenceOptional =
  tei_model.nameLike?,
  tei_addrLine?,
  tei_street?,
  tei_postCode?,
  tei_postBox?
tei_model.addrPart_sequenceOptionalRepeatable =
  tei_model.nameLike*,
  tei_addrLine*,
  tei_street*,
  tei_postCode*,
  tei_postBox*
tei_model.addrPart_sequenceRepeatable =
  tei_model.nameLike+,
  tei_addrLine+,
  tei_street+,
  tei_postCode+,
  tei_postBox+
tei_model.pPart.data =
  tei_model.dateLike
  | tei_model.measureLike
  | tei_model.addressLike
  | tei_model.nameLike
tei_model.pPart.data_sequence =
  tei_model.dateLike,
  tei_model.measureLike,
  tei_model.addressLike,
  tei_model.nameLike
tei_model.pPart.data_sequenceOptional =
  tei_model.dateLike?,
  tei_model.measureLike?,
  tei_model.addressLike?,
  tei_model.nameLike?
tei_model.pPart.data_sequenceOptionalRepeatable =
  tei_model.dateLike*,
  tei_model.measureLike*,
  tei_model.addressLike*,
  tei_model.nameLike*
tei_model.pPart.data_sequenceRepeatable =
  tei_model.dateLike+,
  tei_model.measureLike+,
  tei_model.addressLike+,
  tei_model.nameLike+
tei_model.inter =
  tei_model.oddDecl
  | tei_model.oddRef
  | tei_model.qLike
  | tei_model.biblLike
  | tei_model.listLike
  | tei_model.stageLike
  | tei_label
  | tei_text
  | tei_table
  | tei_figure
tei_model.inter_sequence =
  tei_model.oddDecl,
  tei_model.oddRef,
  tei_model.qLike,
  tei_model.biblLike,
  tei_model.listLike,
  tei_model.stageLike,
  tei_label,
  tei_text,
  tei_table,
  tei_figure
tei_model.inter_sequenceOptional =
  tei_model.oddDecl?,
  tei_model.oddRef?,
  tei_model.qLike?,
  tei_model.biblLike?,
  tei_model.listLike?,
  tei_model.stageLike?,
  tei_label?,
  tei_text?,
  tei_table?,
  tei_figure?
tei_model.inter_sequenceOptionalRepeatable =
  tei_model.oddDecl*,
  tei_model.oddRef*,
  tei_model.qLike*,
  tei_model.biblLike*,
  tei_model.listLike*,
  tei_model.stageLike*,
  tei_label*,
  tei_text*,
  tei_table*,
  tei_figure*
tei_model.inter_sequenceRepeatable =
  tei_model.oddDecl+,
  tei_model.oddRef+,
  tei_model.qLike+,
  tei_model.biblLike+,
  tei_model.listLike+,
  tei_model.stageLike+,
  tei_label+,
  tei_text+,
  tei_table+,
  tei_figure+
tei_model.phrase =
  tei_model.segLike
  | tei_model.hiLike
  | tei_model.graphicLike
  | tei_model.pPart.msdesc
  | tei_model.pPart.edit
  | tei_model.ptrLike
  | tei_model.lPart
  | tei_model.oddPhr
  | tei_model.pPart.data
tei_model.phrase_sequence =
  tei_model.segLike,
  tei_model.hiLike,
  tei_model.graphicLike,
  tei_model.pPart.msdesc,
  tei_model.pPart.edit,
  tei_model.ptrLike,
  tei_model.lPart,
  tei_model.oddPhr,
  tei_model.pPart.data
tei_model.phrase_sequenceOptional =
  tei_model.segLike?,
  tei_model.hiLike?,
  tei_model.graphicLike?,
  tei_model.pPart.msdesc?,
  tei_model.pPart.edit?,
  tei_model.ptrLike?,
  tei_model.lPart?,
  tei_model.oddPhr?,
  tei_model.pPart.data?
tei_model.phrase_sequenceOptionalRepeatable =
  tei_model.segLike*,
  tei_model.hiLike*,
  tei_model.graphicLike*,
  tei_model.pPart.msdesc*,
  tei_model.pPart.edit*,
  tei_model.ptrLike*,
  tei_model.lPart*,
  tei_model.oddPhr*,
  tei_model.pPart.data*
tei_model.phrase_sequenceRepeatable =
  tei_model.segLike+,
  tei_model.hiLike+,
  tei_model.graphicLike+,
  tei_model.pPart.msdesc+,
  tei_model.pPart.edit+,
  tei_model.ptrLike+,
  tei_model.lPart+,
  tei_model.oddPhr+,
  tei_model.pPart.data+
tei_model.divLike = tei_div
tei_model.divLike_sequence = tei_div
tei_model.divLike_sequenceOptional = tei_div?
tei_model.divLike_sequenceOptionalRepeatable = tei_div*
tei_model.divLike_sequenceRepeatable = tei_div+
tei_model.divGenLike = tei_divGen
tei_model.divGenLike_sequence = tei_divGen
tei_model.divGenLike_sequenceOptional = tei_divGen?
tei_model.divGenLike_sequenceOptionalRepeatable = tei_divGen*
tei_model.divGenLike_sequenceRepeatable = tei_divGen+
tei_model.div1Like = tei_div1
tei_model.div1Like_sequence = tei_div1
tei_model.div1Like_sequenceOptional = tei_div1?
tei_model.div1Like_sequenceOptionalRepeatable = tei_div1*
tei_model.div1Like_sequenceRepeatable = tei_div1+
tei_model.div2Like = tei_div2
tei_model.div2Like_sequence = tei_div2
tei_model.div2Like_sequenceOptional = tei_div2?
tei_model.div2Like_sequenceOptionalRepeatable = tei_div2*
tei_model.div2Like_sequenceRepeatable = tei_div2+
tei_model.div3Like = tei_div3
tei_model.div3Like_sequence = tei_div3
tei_model.div3Like_sequenceOptional = tei_div3?
tei_model.div3Like_sequenceOptionalRepeatable = tei_div3*
tei_model.div3Like_sequenceRepeatable = tei_div3+
tei_model.div4Like = tei_div4
tei_model.div4Like_sequence = tei_div4
tei_model.div4Like_sequenceOptional = tei_div4?
tei_model.div4Like_sequenceOptionalRepeatable = tei_div4*
tei_model.div4Like_sequenceRepeatable = tei_div4+
tei_model.div5Like = tei_div5
tei_model.div5Like_sequence = tei_div5
tei_model.div5Like_sequenceOptional = tei_div5?
tei_model.div5Like_sequenceOptionalRepeatable = tei_div5*
tei_model.div5Like_sequenceRepeatable = tei_div5+
tei_model.div6Like = tei_div6
tei_model.div6Like_sequence = tei_div6
tei_model.div6Like_sequenceOptional = tei_div6?
tei_model.div6Like_sequenceOptionalRepeatable = tei_div6*
tei_model.div6Like_sequenceRepeatable = tei_div6+
tei_model.div7Like = tei_div7
tei_model.div7Like_sequence = tei_div7
tei_model.div7Like_sequenceOptional = tei_div7?
tei_model.div7Like_sequenceOptionalRepeatable = tei_div7*
tei_model.div7Like_sequenceRepeatable = tei_div7+
tei_model.placeNamePart = notAllowed
tei_model.placeNamePart_sequence = empty
tei_model.placeNamePart_sequenceOptional = empty
tei_model.placeNamePart_sequenceOptionalRepeatable = empty
tei_model.placeNamePart_sequenceRepeatable = notAllowed
tei_p =
  
  ## (paragraph) marks paragraphs in prose.
  element ns1:p { tei_p.content, tei_p.attributes }
tei_p.content = tei_macro.paraContent
tei_p.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_foreign =
  
  ## (foreign) identifies a word or phrase as belonging to some language other
  ## than that of the surrounding text. 
  element ns1:foreign { tei_foreign.content, tei_foreign.attributes }
tei_foreign.content = tei_macro.phraseSeq
tei_foreign.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_emph =
  
  ## (emphasized) marks words or phrases which are stressed or emphasized for
  ## linguistic or rhetorical effect.
  element ns1:emph { tei_emph.content, tei_emph.attributes }
tei_emph.content = tei_macro.paraContent
tei_emph.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_hi =
  
  ## (highlighted) marks a word or phrase as graphically distinct from the
  ## surrounding text, for reasons concerning which no claim is
  ## made. 
  element ns1:hi { tei_hi.content, tei_hi.attributes }
tei_hi.content = tei_macro.paraContent
tei_hi.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_distinct =
  
  ## (distinct) identifies any word or phrase which is regarded as linguistically
  ## distinct, for example as archaic, technical, dialectal, non-preferred,
  ## etc., or as forming part of a sublanguage. 
  element ns1:distinct { tei_distinct.content, tei_distinct.attributes }
tei_distinct.content = tei_macro.phraseSeq
tei_distinct.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies the sublanguage or register to which the word or phrase
  ## is being assigned
  attribute type { tei_data.enumerated }?,
  
  ## specifies how the phrase is distinct diachronically
  attribute time { tei_data.code }?,
  
  ## specifies how the phrase is distinct diatopically
  attribute space { tei_data.code }?,
  
  ## specifies how the phrase is distinct diastatically
  attribute social { tei_data.code }?,
  empty
tei_q =
  
  ## (quoted speech, thought, or writing) contains material which is
  ## marked as (ostensibly) quoted from elsewhere; in narrative, this element is used to mark direct or
  ## indirect speech; in dictionaries, it ay be used to mark
  ## real or contrived examples of usage; in manuscript descriptions or
  ## other metadata, to mark extracts quoted from the source being documented.
  element ns1:q { tei_q.content, tei_q.attributes }
tei_q.content = tei_macro.specialPara
tei_q.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.ascribed.attribute.who,
  
  ## may be used to indicate whether the quoted matter is spoken
  ## or thought, or to characterize it more finely.
  ## Sample values include: 1] spoken (representation of direct speech, usually
  ## marked by quotation marks.); 2] thought (representation of thought, e.g. internal monologue.); 3] written (quotation from a written source.)
  attribute type { tei_data.enumerated }?,
  
  ## may be used to indicate whether the quoted matter is regarded
  ## as direct or indirect speech.
  [ a1:defaultValue = "unknown" ]
  attribute direct {
    
    ## (speech or thought is represented directly.) 
    "true"
    | 
      ## (speech or thought is represented indirectly,
      ## e.g. by use of a marked verbal aspect.) 
      "false"
    | 
      ## (no claim is made.) 
      "unknown"
  }?,
  empty
tei_quote =
  
  ## (quotation) contains a phrase or passage attributed by the narrator or
  ##   author to some agency external to the text.
  element ns1:quote { tei_quote.content, tei_quote.attributes }
tei_quote.content = tei_macro.specialPara
tei_quote.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_cit =
  
  ## A quotation from some other document, together with a
  ##   bibliographic reference to its source.
  element ns1:cit { tei_cit.content, tei_cit.attributes }
tei_cit.content =
  (tei_model.quoteLike
   | tei_model.biblLike
   | tei_model.ptrLike
   | tei_model.global)+
tei_cit.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_mentioned =
  
  ## marks words or phrases mentioned, not used.
  element ns1:mentioned {
    tei_mentioned.content, tei_mentioned.attributes
  }
tei_mentioned.content = tei_macro.phraseSeq
tei_mentioned.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_soCalled =
  
  ## (so called) contains a word or phrase for which the author or narrator
  ## indicates a disclaiming of responsibility, for example by the use
  ## of scare quotes or italics.
  element ns1:soCalled { tei_soCalled.content, tei_soCalled.attributes }
tei_soCalled.content = tei_macro.phraseSeq
tei_soCalled.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_altIdent =
  
  ## supplies the recommended XML name for an element, class,
  ##   attribute, etc. in some language.
  element ns1:altIdent { tei_altIdent.content, tei_altIdent.attributes }
tei_altIdent.content = tei_macro.xtext
tei_altIdent.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  empty
tei_desc =
  
  ## (description) contains a brief description of the purpose and application for
  ## an element, attribute, or attribute value.
  element ns1:desc { tei_desc.content, tei_desc.attributes }
tei_desc.content = tei_macro.paraContent
tei_desc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.translatable.attribute.version,
  empty
tei_equiv =
  
  ## specifies a component which is considered equivalent to the
  ##   parent element, either by co-reference, or by external link.
  element ns1:equiv { tei_equiv.content, tei_equiv.attributes }
tei_equiv.content = empty
tei_equiv.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## names the underlying concept of which the parent is a
  ##   representation
  attribute name { tei_data.name }?,
  
  ## references the underlying concept of which the parent is a
  ##   representation by means of some external identifier
  attribute uri { tei_data.pointer }?,
  
  ## references an external script which contains a method to
  ## transform instances of this element to canonical TEI
  ##	
  attribute filter { xsd:anyURI }?,
  
  ## MIME type of external filter script
  attribute mimeType { tei_data.word }?,
  empty
tei_gloss =
  
  ## identifies a phrase or word used to provide a gloss or
  ##   definition for some other word or phrase.
  element ns1:gloss { tei_gloss.content, tei_gloss.attributes }
tei_gloss.content = tei_macro.phraseSeq
tei_gloss.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  att.translatable.attribute.version,
  (
   ## identifies the associated term element by an
   ##       absolute or relative URI reference
   attribute target { tei_data.pointer }
   | 
     ## identifies the associated term element using a canonical
     ##       reference from a scheme defined in a refsDecl element
     ##       in the TEI header
     attribute cRef { tei_data.pointer })?,
  empty
tei_term =
  
  ## contains a single-word, multi-word, or symbolic designation
  ##   which is regarded as a technical term.
  element ns1:term { tei_term.content, tei_term.attributes }
tei_term.content = tei_macro.phraseSeq
tei_term.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  
  ## supplies the sort key for this term in an index.
  attribute sortKey { tei_data.word }?,
  (
   ## identifies the associated gloss element by an
   ##	absolute or relative URI reference
   attribute target { tei_data.pointer }
   | 
     ## identifies the associated gloss element using a
     ##	canonical reference from a scheme defined in a
     ##	refsDecl element in the TEI header
     attribute cRef { tei_data.pointer })?,
  empty
tei_sic =
  
  ## contains text reproduced although apparently incorrect or inaccurate.
  element ns1:sic { tei_sic.content, tei_sic.attributes }
tei_sic.content = tei_macro.paraContent
tei_sic.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_corr =
  
  ## (correction) contains the correct form of a passage apparently erroneous in the copy text.
  element ns1:corr { tei_corr.content, tei_corr.attributes }
tei_corr.content = tei_macro.paraContent
tei_corr.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
tei_choice =
  
  ## groups a number of alternative encodings for the same point in
  ##   a text.
  element ns1:choice { tei_choice.content, tei_choice.attributes }
tei_choice.content = (tei_model.choicePart | tei_choice)*
tei_choice.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_reg =
  
  ## (regularization) contains a reading which has been regularized or normalized
  ## in some sense.
  element ns1:reg { tei_reg.content, tei_reg.attributes }
tei_reg.content = tei_macro.paraContent
tei_reg.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
tei_orig =
  
  ## (original form) contains  a reading which is marked as following  the original,
  ## rather than being normalized or corrected.
  element ns1:orig { tei_orig.content, tei_orig.attributes }
tei_orig.content = tei_macro.paraContent
tei_orig.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_gap =
  
  ## (omitted material) indicates a point where material has been omitted in a
  ## transcription, whether for editorial reasons described in the TEI
  ## header, as part of sampling practice, or because the material is
  ## illegible or inaudible.
  element ns1:gap { tei_gap.content, tei_gap.attributes }
tei_gap.content = tei_macro.glossSeq
tei_gap.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  
  ## gives the reason for omission.  Sample values include
  ## sampling, illegible, inaudible,
  ## irrelevant, cancelled, cancelled and illegible.
  attribute reason {
    list { tei_data.word+ }
  }?,
  
  ## in the case of text omitted from the transcription because of
  ## deliberate deletion by an identifiable hand, signifies the hand which
  ## made the deletion.
  attribute hand { tei_data.pointer }?,
  
  ## In the case of text omitted because of damage, categorizes the cause of the damage, if it can be identified.
  ## Sample values include: 1] rubbing (damage results from rubbing of the
  ##   leaf edges); 2] mildew (damage results from mildew on the leaf surface); 3] smoke (damage results from smoke)
  attribute agent { tei_data.enumerated }?,
  
  ## indicates approximately how much text has been omitted from the
  ## transcription, in letters, minims, inches, or any appropriate unit,
  ## either because of editorial policy or because a deletion, damage, or
  ## other cause has rendered transcription impossible.
  attribute extent {
    list { tei_data.word+ }
  }?,
  empty
tei_add =
  
  ## (addition) contains letters, words, or phrases inserted in the text by an
  ## author, scribe, annotator, or corrector.
  element ns1:add { tei_add.content, tei_add.attributes }
tei_add.content = tei_macro.paraContent
tei_add.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.authorialIntervention.attribute.hand,
  att.authorialIntervention.attribute.status,
  att.authorialIntervention.attribute.type,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.placement.attribute.place,
  empty
tei_del =
  
  ## (deletion) contains a letter, word or passage deleted, marked as deleted,
  ## or otherwise indicated as superfluous or spurious in the copy text by an
  ## author, scribe, annotator, or corrector.
  element ns1:del { tei_del.content, tei_del.attributes }
tei_del.content = tei_macro.paraContent
tei_del.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.authorialIntervention.attribute.hand,
  att.authorialIntervention.attribute.status,
  att.authorialIntervention.attribute.type,
  empty
tei_unclear =
  
  ## contains a word, phrase, or passage which cannot be transcribed
  ## with certainty because it is illegible or inaudible in the source.
  element ns1:unclear { tei_unclear.content, tei_unclear.attributes }
tei_unclear.content = tei_macro.paraContent
tei_unclear.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  
  ## indicates why the material is hard to transcribe.
  attribute reason {
    list { tei_data.word+ }
  }?,
  
  ## Where the difficulty in transcription arises from action
  ## (partial deletion, etc.) assignable to an identifiable hand, signifies
  ## the hand responsible for the action.
  attribute hand { tei_data.pointer }?,
  
  ## Where the difficulty in transcription arises from
  ##  damage, categorizes the cause of the damage, if it can be identified.
  ## Sample values include: 1] rubbing (damage results from rubbing of the
  ##   leaf edges); 2] mildew (damage results from mildew on the leaf surface); 3] smoke (damage results from smoke)
  attribute agent { tei_data.enumerated }?,
  empty
tei_name =
  
  ## (name, proper noun) contains a proper noun or noun phrase.
  element ns1:name { tei_name.content, tei_name.attributes }
tei_name.content = tei_macro.phraseSeq
tei_name.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.naming.attribute.key,
  
  ## indicates the type of the object which is being named by the
  ##       phrase.
  attribute type { tei_data.enumerated }?,
  empty
tei_rs =
  
  ## (referencing string) contains a general purpose name or referring string.
  element ns1:rs { tei_rs.content, tei_rs.attributes }
tei_rs.content = tei_macro.phraseSeq
tei_rs.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.naming.attribute.key,
  
  ## indicates more specifically the object referred to by the
  ##       referencing string. Values might include person,
  ##       place, ship, element etc.
  attribute type { tei_data.enumerated }?,
  empty
tei_email =
  
  ## contains an e-mail address identifying a location to which
  ## e-mail messages can be delivered.
  ##		
  element ns1:email { tei_email.content, tei_email.attributes }
tei_email.content = tei_macro.phraseSeq
tei_email.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_address =
  
  ## contains a postal  address, for example of a
  ## publisher, an organization, or an individual.
  element ns1:address { tei_address.content, tei_address.attributes }
tei_address.content =
  tei_model.global*, (tei_model.addrPart, tei_model.global*)+
tei_address.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_addrLine =
  
  ## contains one line of a postal address.
  element ns1:addrLine { tei_addrLine.content, tei_addrLine.attributes }
tei_addrLine.content = tei_macro.phraseSeq
tei_addrLine.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_street =
  
  ## (street) a full street address including any name or number identifying a
  ## building as well as the name of the street or route on which it is
  ## located.
  element ns1:street { tei_street.content, tei_street.attributes }
tei_street.content = tei_macro.phraseSeq
tei_street.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_postCode =
  
  ## (postCode) contains a numerical or alphanumeric code used as part of a
  ## postal address to simplify sorting or delivery of mail. 
  element ns1:postCode { tei_postCode.content, tei_postCode.attributes }
tei_postCode.content = text
tei_postCode.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_postBox =
  
  ## (postBox) contains a number or other identifier for some postal delivery
  ## point other than a street address. 
  element ns1:postBox { tei_postBox.content, tei_postBox.attributes }
tei_postBox.content = text
tei_postBox.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_num =
  
  ## (number) contains a number, written in any form.
  element ns1:num { tei_num.content, tei_num.attributes }
tei_num.content = tei_macro.phraseSeq
tei_num.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the type of numeric value.
  ## Suggested values include: 1] cardinal (absolute number, e.g. 21, 21.5); 2] ordinal (ordinal number, e.g. 21st); 3] fraction (fraction, e.g. one half or three-quarters); 4] percentage (a percentage)
  attribute type { tei_data.enumerated }?,
  
  ## supplies the value of the number in standard form.
  attribute value { tei_data.numeric }?,
  empty
tei_measure =
  
  ## contains a word or phrase referring to some quantity of
  ## an object or commodity, usually comprising a number, a unit, and a
  ## commodity name.
  element ns1:measure { tei_measure.content, tei_measure.attributes }
tei_measure.content = tei_macro.phraseSeq
tei_measure.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.measurement.attribute.unit,
  att.measurement.attribute.quantity,
  att.measurement.attribute.commodity,
  
  ## specifies the type of measurement in any convenient typology.
  attribute type { tei_data.enumerated }?,
  empty
tei_date =
  
  ## contains a date in any format.
  element ns1:date { tei_date.content, tei_date.attributes }
tei_date.content =
  (text
   | tei_model.gLike
   | tei_model.datePart
   | tei_model.phrase
   | tei_model.global)*
tei_date.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.datePart.attribute.value,
  att.datePart.attribute.dur,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.datable.attribute.notBefore,
  att.datable.attribute.notAfter,
  att.datable.attribute.from,
  att.datable.attribute.to,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  
  ## indicates the system or calendar to which the date belongs.
  ## Suggested values include: 1] Gregorian; 2] Julian; 3] Islamic; 4] Hebrew; 5] Revolutionary; 6] Iranian; 7] Coptic; 8] Chinese
  attribute calendar { tei_data.enumerated }?,
  
  ## indicates the degree of precision associated with the date.
  attribute precision { tei_data.certainty }?,
  empty
tei_time =
  
  ## contains a phrase defining a time of day in any format.
  element ns1:time { tei_time.content, tei_time.attributes }
tei_time.content =
  (text
   | tei_model.gLike
   | tei_model.datePart
   | tei_model.phrase
   | tei_model.global)*
tei_time.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.datePart.attribute.value,
  att.datePart.attribute.dur,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  att.datable.attribute.notBefore,
  att.datable.attribute.notAfter,
  att.datable.attribute.from,
  att.datable.attribute.to,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  empty
tei_abbr =
  
  ## (abbreviation) contains an abbreviation of any sort.
  element ns1:abbr { tei_abbr.content, tei_abbr.attributes }
tei_abbr.content = tei_macro.phraseSeq
tei_abbr.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## allows the encoder to classify the abbreviation according to
  ## some convenient typology.
  ## Sample values include: 1] suspension (the abbreviation provides the first
  ##        letter(s) of the word or phrase, omitting the remainder.); 2] contraction (the abbreviation omits some letter(s) in the middle.); 3] brevigraph (the abbreviation comprises a special symbol or mark.); 4] superscription (the abbreviation includes writing above the line.); 5] acronym (the abbreviation comprises the initial letters of
  ##	  the words of a phrase.); 6] title (the abbreviation is for a title of address (Dr, Ms, Mr, )); 7] organization (the abbreviation is for the name of an organization.); 8] geographic (the abbreviation is for a geographic name.)
  attribute type { tei_data.enumerated }?,
  empty
tei_expan =
  
  ## (expansion) contains the expansion of an abbreviation.
  element ns1:expan { tei_expan.content, tei_expan.attributes }
tei_expan.content = tei_macro.phraseSeq
tei_expan.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.editLike.attribute.cert,
  att.editLike.attribute.resp,
  att.editLike.attribute.evidence,
  empty
tei_ptr =
  
  ## defines a pointer to another location.
  element ns1:ptr { tei_ptr.content, tei_ptr.attributes }
tei_ptr.content = empty
tei_ptr.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  (
   ## specifies the destination of the pointer by supplying one or
   ##       more URI References
   attribute target {
     list { tei_data.pointer+ }
   }
   | 
     ## specifies the destination of the pointer by supplying a
     ##       canonical reference from a scheme defined in a refsDecl
     ##       element in the TEI header
     attribute cRef {
       list { tei_data.word+ }
     })?,
  empty
tei_ref =
  
  ## defines a reference to another location, possibly
  ##   modified by additional text or comment.
  element ns1:ref { tei_ref.content, tei_ref.attributes }
tei_ref.content = tei_macro.paraContent
tei_ref.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  (
   ## specifies the destination of the reference by supplying one
   ##     or more URI References
   attribute target {
     list { tei_data.pointer+ }
   }
   | 
     ## specifies the destination of the reference by supplying a
     ##       canonical reference from a scheme defined in a refsDecl
     ##       element in the TEI header
     attribute cRef {
       list { tei_data.word+ }
     })?,
  empty
tei_list =
  
  ## contains any sequence of items organized as a list.
  element ns1:list { tei_list.content, tei_list.attributes }
tei_list.content =
  (tei_model.divWrapper | tei_model.global)*,
  ((tei_item, tei_model.global*)+
   | (tei_headLabel?,
      tei_headItem?,
      (tei_label, tei_model.global*, tei_item, tei_model.global*)+)),
  (tei_model.divWrapper.bottom, tei_model.global*)*
tei_list.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## describes the form of the list.
  ## Suggested values include: 1] ordered (list items are numbered or lettered.
  ##     ); 2] bulleted (list items are marked with a
  ## bullet or other typographic device.
  ##     ); 3] simple (list items are not numbered or bulleted.
  ##     ); 4] gloss (each list item glosses some term or
  ## concept, which is given by a label element preceding
  ## the list item.)
  [ a1:defaultValue = "simple" ]
  attribute type { tei_data.enumerated }?,
  empty
tei_item =
  
  ## contains one
  ## component of a list.
  element ns1:item { tei_item.content, tei_item.attributes }
tei_item.content = tei_macro.specialPara
tei_item.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_label =
  
  ## contains the label associated with an item in a list; in
  ## glossaries, marks the term being defined.
  element ns1:label { tei_label.content, tei_label.attributes }
tei_label.content = tei_macro.phraseSeq
tei_label.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_head =
  
  ## (heading) contains any type of heading, for example the title of a section,
  ## or the heading of a list, glossary, manuscript description, etc.
  element ns1:head { tei_head.content, tei_head.attributes }
tei_head.content = tei_macro.paraContent
tei_head.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## categorizes the heading in any way meaningful 
  ##          to the encoder. 
  attribute type { tei_data.enumerated }?,
  empty
tei_headLabel =
  
  ## (heading for list labels) contains the heading for the label or term column in a
  ## glossary list or similar structured list.
  element ns1:headLabel {
    tei_headLabel.content, tei_headLabel.attributes
  }
tei_headLabel.content = tei_macro.phraseSeq
tei_headLabel.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_headItem =
  
  ## (heading for list items) contains the heading for the item or gloss column in a
  ## glossary list or similar structured list.
  element ns1:headItem { tei_headItem.content, tei_headItem.attributes }
tei_headItem.content = tei_macro.phraseSeq
tei_headItem.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_note =
  
  ## contains a note or annotation.
  element ns1:note { tei_note.content, tei_note.attributes }
tei_note.content = tei_macro.specialPara
tei_note.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.placement.attribute.place,
  
  ## describes the type of note.
  attribute type { tei_data.enumerated }?,
  
  ## indicates who is responsible for the annotation: author,
  ##	editor, translator, etc.
  attribute resp { tei_data.pointer }?,
  
  ## indicates whether the copy text shows the exact place of reference
  ## for the note.
  [ a1:defaultValue = "true" ]
  attribute anchored {
    
    ## (copy text indicates the place of attachment for the note.
    ##     ) 
    "true"
    | 
      ## (copy text indicates no place of attachment for the note.) 
      "false"
  }?,
  
  ## indicates the point (or points) of attachment for a note, or the beginning of
  ## the span to which the note is attached.
  attribute target {
    list { tei_data.pointer+ }
  }?,
  
  ## points to the end of the span to which the note is attached, if
  ## the note is not embedded in the text at that point.
  attribute targetEnd {
    list { tei_data.pointer+ }
  }?,
  empty
tei_index =
  
  ## (index entry) marks a location to be indexed for whatever purpose.
  element ns1:index { tei_index.content, tei_index.attributes }
tei_index.content = (tei_term, tei_index?)*
tei_index.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.spanning.attribute.spanTo,
  
  ## supplies a name to specify which index (of several) the index entry belongs to.
  attribute indexName { tei_data.name }?,
  empty
tei_divGen =
  
  ## (automatically generated text division) indicates the location at which a textual division generated
  ## automatically by a text-processing application is to appear.
  element ns1:divGen { tei_divGen.content, tei_divGen.attributes }
tei_divGen.content = tei_model.divWrapper*
tei_divGen.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies what type of generated text division (e.g. index,
  ## table of contents, etc.) is to appear.
  ## Sample values include: 1] index (an index is to be generated and inserted at this point.); 2] toc (a table of contents); 3] figlist (a list of figures); 4] tablist (a list of tables)
  attribute type { tei_data.enumerated }?,
  empty
tei_graphic =
  
  ## indicates the location of an inline graphic, illustration, or figure.
  element ns1:graphic { tei_graphic.content, tei_graphic.attributes }
tei_graphic.content = empty
tei_graphic.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## The display width of the image
  attribute width { tei_data.outputMeasurement }?,
  
  ## The display height of the image
  attribute height { tei_data.outputMeasurement }?,
  
  ## A scale factor to be applied to the image to make it the desired display size
  attribute scale { tei_data.numeric }?,
  
  ## The target URL
  attribute url { tei_data.pointer }?,
  
  ## The MIME type
  attribute mimeType { tei_data.word }?,
  empty
tei_binaryObject =
  
  ## provides encoded binary data representing an inline graphic or other object.
  element ns1:binaryObject {
    tei_binaryObject.content, tei_binaryObject.attributes
  }
tei_binaryObject.content = text
tei_binaryObject.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## The display width of the object
  attribute width { tei_data.outputMeasurement }?,
  
  ## The display height of the object
  attribute height { tei_data.outputMeasurement }?,
  
  ## A scale factor to be applied to the object to make it the desired display size
  attribute scale { tei_data.numeric }?,
  
  ## The MIME type
  attribute mimeType { tei_data.word }?,
  
  ## The encoding used to encode the binary data. If not
  ##       specified, this is assumed to be Base64
  attribute encoding {
    list { tei_data.word+ }
  }?,
  empty
tei_milestone =
  
  ## marks a boundary point separating  any kind of section of a text, as indicated by
  ## changes in a standard reference system, where the section is not
  ## represented by a structural element.
  element ns1:milestone {
    tei_milestone.content, tei_milestone.attributes
  }
tei_milestone.content = empty
tei_milestone.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the edition or version to which the milestone applies.
  attribute ed { tei_data.code }?,
  
  ## provides a conventional name for the kind of section changing at this milestone.
  ## Suggested values include: 1] page (physical page breaks (synonymous with the pb
  ##	  element).); 2] column (column breaks.); 3] line (line breaks (synonymous with the lb element).); 4] book (any units termed book, liber, etc.); 5] poem (individual poems in a collection.); 6] canto (cantos or other major sections of a poem.); 7] stanza (stanzas within a poem, book, or canto.); 8] act (acts within a play.); 9] scene (scenes within a play or act.); 10] section (sections of any kind.); 11] absent (passages not present in the reference edition.)
  attribute unit { tei_data.enumerated },
  empty
tei_pb =
  
  ## (page break) marks the boundary between one page of a text and the next
  ## in a standard reference system.
  element ns1:pb { tei_pb.content, tei_pb.attributes }
tei_pb.content = empty
tei_pb.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the edition or version in which the page break is located
  ## at this point
  attribute ed { tei_data.code }?,
  empty
tei_lb =
  
  ## (line break) marks the start of a new (typographic) line in some
  ## edition or version of a text.
  element ns1:lb { tei_lb.content, tei_lb.attributes }
tei_lb.content = empty
tei_lb.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the edition or version in which the line break is located
  ## at this point
  attribute ed { tei_data.code }?,
  empty
tei_cb =
  
  ## (column break) marks the boundary between one column of a text and the next
  ## in a standard reference system.
  element ns1:cb { tei_cb.content, tei_cb.attributes }
tei_cb.content = empty
tei_cb.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the edition or version in which the column break is located
  ## at this point
  attribute ed { tei_data.code }?,
  empty
tei_bibl =
  
  ## (bibliographic citation) contains a loosely-structured bibliographic citation of which
  ## the sub-components may or may not be explicitly tagged. 
  element ns1:bibl { tei_bibl.content, tei_bibl.attributes }
tei_bibl.content =
  (text
   | tei_model.gLike
   | tei_model.hiLike
   | tei_model.pPart.data
   | tei_model.pPart.edit
   | tei_model.segLike
   | tei_model.ptrLike
   | tei_model.biblPart
   | tei_model.global)*
tei_bibl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_biblItem =
  
  ## (bibliographic citation) contains a bibliographic citation in which only bibliographic
  ##   subelements appear.
  element ns1:biblItem { tei_biblItem.content, tei_biblItem.attributes }
tei_biblItem.content =
  (tei_title
   | tei_biblItem
   | tei_imprint
   | tei_model.nameLike
   | tei_model.biblPart
   | tei_model.dateLike)+
tei_biblItem.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  att.typed.attribute.type,
  att.typed.attribute.subtype,
  
  ## indicates the physical form of the object of this bibliographic entry.
  ## Sample values include: 1] book.hardcover (); 2] book.paperback (); 3] video.VHS (); 4] video.DVD (); 5] audio.casette (); 6] audio.CD ()
  attribute form { tei_data.word }?,
  
  ## indicates the publication status of the object of this bibliographic entry.
  ## Sample values include: 1] manuscript (the item is a manuscript); 2] forthcoming (the item is being published, but has not been released yet); 3] inPrint (the item is currently being published)
  attribute status { text }?,
  
  ## indicates the relationship of this bibliographic entry to
  ##       that of its parent bibl or biblItem.
  ## Sample values include: 1] host (this bibliographic item has a host relationship to
  ##	  the item encoded in the parent bibl or biblItem; e.g., this item is the
  ##	  magazine in which the article described by the parent bibl or biblItem
  ##	  appeared.); 2] original (the item is original source); 3] workReviewed (this bibliographic item was reviewed in the ancestor work); 4] edition (indicates that this entry contains separate
  ##	  information for a particular edition of the parent bibl or biblItem); 5] basedOn (indicates that the parent bibl or biblItem is the base work from which this one was
  ##	  derived); 6] referencedBy (indicates that the element is a reference for the work in question); 7] copyOf (indicates that this entry is for a facsimile of that
  ##	  which is referred to by the parent bibl or biblItem)
  attribute role { text }?,
  empty
tei_biblStruct =
  
  ## (structured bibliographic citation) contains a structured bibliographic citation, in which only
  ## bibliographic subelements appear and in a specified order. 
  element ns1:biblStruct {
    tei_biblStruct.content, tei_biblStruct.attributes
  }
tei_biblStruct.content =
  tei_analytic*,
  (tei_monogr, tei_series*)+,
  (tei_model.noteLike | tei_idno)*
tei_biblStruct.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_biblFull =
  
  ## contains a fully-structured bibliographic citation, in which all
  ## components of the TEI file description
  ## are present.
  element ns1:biblFull { tei_biblFull.content, tei_biblFull.attributes }
tei_biblFull.content = tei_macro.fileDescPart, tei_sourceDesc*
tei_biblFull.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_listBibl =
  
  ## (citation list) contains a list of bibliographic citations of any kind. 
  element ns1:listBibl { tei_listBibl.content, tei_listBibl.attributes }
tei_listBibl.content =
  (tei_model.divWrapper | tei_model.global)*,
  (tei_model.biblLike, tei_model.global*)+,
  (tei_model.divWrapper.bottom, tei_model.global*)*
tei_listBibl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_analytic =
  
  ## (analytic level) contains bibliographic elements describing an item (e.g. an
  ## article or poem) published within a monograph or journal and not as an
  ## independent publication.
  element ns1:analytic { tei_analytic.content, tei_analytic.attributes }
tei_analytic.content =
  (tei_author | tei_editor | tei_respStmt | tei_title)*
tei_analytic.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_monogr =
  
  ## (monographic level) contains bibliographic elements describing an item (e.g. a book
  ## or journal) published as an independent item (i.e. as a separate
  ## physical object).
  element ns1:monogr { tei_monogr.content, tei_monogr.attributes }
tei_monogr.content =
  (((tei_author | tei_editor | tei_respStmt),
    (tei_author | tei_editor | tei_respStmt)*,
    tei_title+,
    (tei_editor | tei_respStmt)*)
   | (tei_title+, (tei_author | tei_editor | tei_respStmt)*))?,
  (tei_model.noteLike | tei_meeting)*,
  (tei_edition, (tei_editor | tei_respStmt)*)*,
  tei_imprint,
  (tei_imprint | tei_extent | tei_biblScope)*
tei_monogr.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_series =
  
  ## (series information) contains information about the series in which a book or other
  ## bibliographic item has appeared.
  element ns1:series { tei_series.content, tei_series.attributes }
tei_series.content =
  (text
   | tei_model.gLike
   | tei_title
   | tei_editor
   | tei_respStmt
   | tei_biblScope
   | tei_model.global)*
tei_series.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_author =
  
  ## in a bibliographic reference, contains the name of the author(s),
  ## personal or corporate,
  ## of a work; the primary statement of responsibility for any
  ## bibliographic item. 
  element ns1:author { tei_author.content, tei_author.attributes }
tei_author.content = tei_macro.phraseSeq
tei_author.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_editor =
  
  ## secondary statement of responsibility for a
  ## bibliographic item, for example the name of an individual, institution
  ## or organization, (or of several such) acting as editor, compiler,
  ## translator, etc. 
  element ns1:editor { tei_editor.content, tei_editor.attributes }
tei_editor.content = tei_macro.phraseSeq
tei_editor.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies the nature of the intellectual responsibility
  [ a1:defaultValue = "editor" ]
  attribute role { tei_data.enumerated }?,
  empty
tei_respStmt =
  
  ## (statement of responsibility) supplies a statement of responsibility for someone responsible
  ##   for the intellectual content of a text, edition, recording, or
  ##   series, where the specialized elements for authors, editors, etc. do
  ##   not suffice or do not apply.
  element ns1:respStmt { tei_respStmt.content, tei_respStmt.attributes }
tei_respStmt.content =
  (tei_resp+, tei_model.nameLike.agent+)
  | (tei_model.nameLike.agent+, tei_resp+)
tei_respStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_resp =
  
  ## contains a phrase describing the nature of a person's
  ##   intellectual responsibility.
  element ns1:resp { tei_resp.content, tei_resp.attributes }
tei_resp.content = tei_macro.phraseSeq
tei_resp.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_title =
  
  ## contains the full title of a work of any kind.
  element ns1:title { tei_title.content, tei_title.attributes }
tei_title.content = tei_macro.paraContent
tei_title.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the bibliographic level for a title, that is,
  ##	whether it identifies  an article, book, journal,
  ## series, or unpublished material.
  attribute level {
    
    ## (analytic title (article, poem, or other item published as
    ##           part of a larger item)
    ##     ) 
    "a"
    | 
      ## (monographic title (book, collection, or other item published
      ##           as a distinct item, including single volumes of multi-volume
      ##           works)
      ##     ) 
      "m"
    | 
      ## (journal title
      ##     ) 
      "j"
    | 
      ## (series title
      ##     ) 
      "s"
    | 
      ## (title of unpublished material (including theses and
      ##           dissertations unless published by a commercial press)) 
      "u"
  }?,
  
  ## classifies the title according to some convenient typology.
  ## Sample values include: 1] main (main title
  ##     ); 2] sub (subtitle, title of part
  ##     ); 3] alt (alternate title, often in another language,
  ##                            by which the work is also known
  ##     ); 4] short (abbreviated form of title); 5] desc (descriptive paraphrase of the work functioning as a title)
  attribute type { tei_data.enumerated }?,
  empty
tei_meeting =
  
  ## in bibliographic references,
  ## contains a description of the meeting or conference from which
  ## the bibliographic item derives.
  element ns1:meeting { tei_meeting.content, tei_meeting.attributes }
tei_meeting.content = tei_macro.paraContent
tei_meeting.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_imprint =
  
  ## groups information relating to the publication or distribution
  ##   of a bibliographic item.
  element ns1:imprint { tei_imprint.content, tei_imprint.attributes }
tei_imprint.content =
  ((tei_model.imprintPart | tei_model.dateLike), tei_model.global*)+
tei_imprint.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_publisher =
  
  ## provides the name of the organization responsible for
  ## the publication or distribution of a bibliographic item.
  element ns1:publisher {
    tei_publisher.content, tei_publisher.attributes
  }
tei_publisher.content = tei_macro.phraseSeq
tei_publisher.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_biblScope =
  
  ## (scope of citation) defines the scope of a bibliographic reference, for example as a
  ## list of pagenumbers, or a named subdivision of a larger work.
  element ns1:biblScope {
    tei_biblScope.content, tei_biblScope.attributes
  }
tei_biblScope.content = tei_macro.phraseSeq
tei_biblScope.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## identifies the type of information conveyed by the element, e.g.
  ## pages, volume.
  ## Suggested values include: 1] vol (the element contains a volume number.); 2] issue (the element contains an issue number, or volume and
  ## issue numbers.); 3] pp (the element contains a page number or page range.); 4] cap (the element contains a chapter indication (number
  ## and/or title)); 5] part (the element identifies a part of a book or collection.)
  attribute type { tei_data.enumerated }?,
  empty
tei_pubPlace =
  
  ## contains the name of the place where a bibliographic item was
  ## published.
  element ns1:pubPlace { tei_pubPlace.content, tei_pubPlace.attributes }
tei_pubPlace.content = tei_macro.phraseSeq
tei_pubPlace.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.naming.attribute.key,
  empty
tei_l =
  
  ## (verse line) contains a single, possibly incomplete, line of verse.
  element ns1:l { tei_l.content, tei_l.attributes }
tei_l.content = tei_macro.paraContent
tei_l.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies whether or not the line is metrically complete. 
  [ a1:defaultValue = "N" ]
  attribute part {
    
    ## (the line is metrically incomplete) 
    "Y"
    | 
      ## (either the line is complete, or no claim is made as to its
      ## completeness) 
      "N"
    | 
      ## (the initial part of an incomplete line) 
      "I"
    | 
      ## (a medial part of an incomplete line) 
      "M"
    | 
      ## (the final part of an incomplete line) 
      "F"
  }?,
  empty
tei_lg =
  
  ## (line group) contains a group of verse lines functioning as a formal unit,
  ## e.g. a stanza, refrain, verse paragraph, etc.
  element ns1:lg { tei_lg.content, tei_lg.attributes }
tei_lg.content =
  (tei_model.divWrapper | tei_model.global)*,
  (tei_model.lLike | tei_lg),
  (tei_model.lLike | tei_lg | tei_model.global)*,
  (tei_model.divWrapper.bottom, tei_model.global*)*
tei_lg.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  empty
tei_sp =
  
  ## (speech) An individual speech in a performance text, or a passage
  ##	  presented as such in a prose or verse text.
  element ns1:sp { tei_sp.content, tei_sp.attributes }
tei_sp.content =
  tei_model.global*,
  (tei_speaker, tei_model.global*)?,
  ((tei_model.lLike
    | tei_lg
    | tei_model.pLike
    | tei_model.blockLike
    | tei_model.stageLike),
   tei_model.global*)+
tei_sp.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.ascribed.attribute.who,
  empty
tei_speaker =
  
  ## A specialized form of heading or label, giving the name of
  ## one or more speakers in a dramatic text or fragment.
  element ns1:speaker { tei_speaker.content, tei_speaker.attributes }
tei_speaker.content = tei_macro.phraseSeq
tei_speaker.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_stage =
  
  ## (stage direction) contains any kind of stage direction within a dramatic text or
  ## fragment.
  element ns1:stage { tei_stage.content, tei_stage.attributes }
tei_stage.content = tei_macro.specialPara
tei_stage.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the kind of stage direction.
  ## Suggested values include: 1] setting (describes a setting.); 2] entrance (describes an entrance.); 3] exit (describes an exit.); 4] business (describes stage business.); 5] novelistic (is a narrative, motivating stage direction.); 6] delivery (describes how a character speaks.); 7] modifier (gives some detail about a character.); 8] location (describes a location.); 9] mixed (more than one of the above)
  attribute type { tei_data.enumerated }?,
  empty
tei_teiCorpus =
  
  ## (TEI corpus) contains the whole of a TEI encoded corpus, comprising a
  ## single corpus header and one or more TEI elements, each containing
  ## a single text header and a text.
  element ns1:teiCorpus {
    tei_teiCorpus.content, tei_teiCorpus.attributes
  }
tei_teiCorpus.content = tei_teiHeader, (tei_TEI | tei_teiCorpus)+
tei_teiCorpus.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## The version of the TEI scheme
  [ a1:defaultValue = "5.0" ] attribute version { xsd:decimal }?,
  empty
tei_teiHeader =
  
  ## (TEI Header) supplies the descriptive and declarative information making
  ##	up an electronic title page prefixed to every TEI-conformant
  ##	text.
  element ns1:teiHeader {
    tei_teiHeader.content, tei_teiHeader.attributes
  }
tei_teiHeader.content =
  tei_fileDesc, tei_model.headerPart*, tei_revisionDesc?
tei_teiHeader.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies the kind of document to which the header is attached.
  ## Sample values include: 1] text (the header is attached to a single text.); 2] corpus (the header is attached to a corpus.)
  [ a1:defaultValue = "text" ] attribute type { tei_data.enumerated }?,
  empty
tei_fileDesc =
  
  ## (File Description) contains a full bibliographic description of an electronic
  ## file.
  element ns1:fileDesc { tei_fileDesc.content, tei_fileDesc.attributes }
tei_fileDesc.content = tei_macro.fileDescPart, tei_sourceDesc+
tei_fileDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_titleStmt =
  
  ## (title statement) groups information about the title of a work and those
  ## responsible for its intellectual content.
  element ns1:titleStmt {
    tei_titleStmt.content, tei_titleStmt.attributes
  }
tei_titleStmt.content =
  tei_title+,
  (tei_author
   | tei_editor
   | tei_sponsor
   | tei_funder
   | tei_principal
   | tei_respStmt)*
tei_titleStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_sponsor =
  
  ## specifies the name of a sponsoring organization or
  ## institution.
  element ns1:sponsor { tei_sponsor.content, tei_sponsor.attributes }
tei_sponsor.content = tei_macro.phraseSeq
tei_sponsor.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_funder =
  
  ## (Funding body) specifies the name of an individual, institution, or organization
  ## responsible for the funding of a project or text.
  element ns1:funder { tei_funder.content, tei_funder.attributes }
tei_funder.content = tei_macro.phraseSeq
tei_funder.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_principal =
  
  ## (principal researcher) supplies the name of the principal researcher responsible for the
  ## creation of an electronic text.
  element ns1:principal {
    tei_principal.content, tei_principal.attributes
  }
tei_principal.content = tei_macro.phraseSeq
tei_principal.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_editionStmt =
  
  ## (edition statement) groups information relating to one edition of a text.
  element ns1:editionStmt {
    tei_editionStmt.content, tei_editionStmt.attributes
  }
tei_editionStmt.content =
  tei_model.pLike+ | (tei_edition, tei_respStmt*)
tei_editionStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_edition =
  
  ## (Edition) describes the particularities of one edition of a text.
  element ns1:edition { tei_edition.content, tei_edition.attributes }
tei_edition.content = tei_macro.phraseSeq
tei_edition.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_extent =
  
  ## describes the approximate size of a text as stored on
  ## some carrier medium, whether digital or non-digital, specified in any convenient units.
  element ns1:extent { tei_extent.content, tei_extent.attributes }
tei_extent.content = tei_macro.phraseSeq
tei_extent.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_publicationStmt =
  
  ## (publication statement) groups information concerning the publication or distribution
  ## of an electronic or other text. 
  element ns1:publicationStmt {
    tei_publicationStmt.content, tei_publicationStmt.attributes
  }
tei_publicationStmt.content =
  tei_model.pLike+ | tei_model.publicationStmtPart+
tei_publicationStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_distributor =
  
  ## supplies the name of a person or other agency responsible for the
  ## distribution of a text.
  element ns1:distributor {
    tei_distributor.content, tei_distributor.attributes
  }
tei_distributor.content = tei_macro.phraseSeq
tei_distributor.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_authority =
  
  ## (release authority) supplies the name of a person or other agency responsible for
  ##   making an electronic file available, other than a publisher or
  ##   distributor.
  element ns1:authority {
    tei_authority.content, tei_authority.attributes
  }
tei_authority.content = tei_macro.phraseSeq
tei_authority.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_idno =
  
  ## (identifying number) supplies any standard or non-standard number used to identify a
  ## bibliographic item.
  element ns1:idno { tei_idno.content, tei_idno.attributes }
tei_idno.content = text
tei_idno.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## categorizes the number, for example as an ISBN or other
  ##          standard series.
  ##    
  attribute type { tei_data.enumerated }?,
  empty
tei_availability =
  
  ## supplies information about the availability of a text, for
  ##   example any restrictions on its use or distribution, its copyright
  ##   status, etc.
  element ns1:availability {
    tei_availability.content, tei_availability.attributes
  }
tei_availability.content = tei_model.pLike+
tei_availability.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## supplies a code identifying the current availability of the
  ## text.
  ##    
  [ a1:defaultValue = "unknown" ]
  attribute status {
    
    ## (the text is freely available.
    ##     ) 
    "free"
    | 
      ## (the status of the text is unknown.
      ##     ) 
      "unknown"
    | 
      ## (the text is not freely available.
      ##    ) 
      "restricted"
  }?,
  empty
tei_seriesStmt =
  
  ## (series statement) groups information about the series, if any, to which
  ## a publication belongs.
  element ns1:seriesStmt {
    tei_seriesStmt.content, tei_seriesStmt.attributes
  }
tei_seriesStmt.content =
  tei_model.pLike+
  | (tei_title+, (tei_idno | tei_respStmt)*)
tei_seriesStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_notesStmt =
  
  ## (Notes statement) collects together any notes providing information about a text
  ## additional to that recorded in other parts of the bibliographic
  ## description.
  element ns1:notesStmt {
    tei_notesStmt.content, tei_notesStmt.attributes
  }
tei_notesStmt.content = tei_model.noteLike+
tei_notesStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_sourceDesc =
  
  ## supplies a description of the source text(s) from
  ## which an electronic text was derived or generated.
  element ns1:sourceDesc {
    tei_sourceDesc.content, tei_sourceDesc.attributes
  }
tei_sourceDesc.content =
  tei_model.pLike+
  | tei_listBibl
  | (tei_model.biblLike | tei_model.sourceDescPart)+
tei_sourceDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_scriptStmt =
  
  ## (script statement) contains a citation giving details of the script used for
  ## a spoken text.
  element ns1:scriptStmt {
    tei_scriptStmt.content, tei_scriptStmt.attributes
  }
tei_scriptStmt.content = tei_model.pLike+ | tei_model.biblLike
tei_scriptStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_recordingStmt =
  
  ## (recording statement) describes a set of recordings used in transcription of a
  ## spoken text.
  element ns1:recordingStmt {
    tei_recordingStmt.content, tei_recordingStmt.attributes
  }
tei_recordingStmt.content = tei_model.pLike+ | tei_recording+
tei_recordingStmt.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_recording =
  
  ## (recording event) details of an audio or video recording event
  ## used as the source of a spoken text, either directly or from
  ## a public broadcast. 
  element ns1:recording {
    tei_recording.content, tei_recording.attributes
  }
tei_recording.content = tei_model.pLike+ | tei_model.recordingPart*
tei_recording.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## the kind of recording.
  [ a1:defaultValue = "audio" ]
  attribute type {
    
    ## (audio recording) 
    "audio"
    | 
      ## (audio and video recording) 
      "video"
  }?,
  
  ## the original duration of the recording. 
  attribute dur { tei_data.duration }?,
  empty
tei_equipment =
  
  ## (equipment) provides technical details of the equipment and media used for
  ## an audio or video recording used as the source for a spoken text.
  element ns1:equipment {
    tei_equipment.content, tei_equipment.attributes
  }
tei_equipment.content = tei_model.pLike+
tei_equipment.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_broadcast =
  
  ## (broadcast) describes a broadcast used as the source of a spoken text.
  element ns1:broadcast {
    tei_broadcast.content, tei_broadcast.attributes
  }
tei_broadcast.content =
  tei_model.pLike+ | tei_model.biblLike | tei_recording
tei_broadcast.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_encodingDesc =
  
  ## (Encoding description) documents the relationship between an electronic text and the
  ## source or sources from which it was derived.
  element ns1:encodingDesc {
    tei_encodingDesc.content, tei_encodingDesc.attributes
  }
tei_encodingDesc.content = (tei_model.encodingPart | tei_model.pLike)+
tei_encodingDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_projectDesc =
  
  ## (project description) describes in detail the aim or purpose for which an electronic
  ## file was encoded, together with any other relevant information
  ## concerning the process by which it was assembled or collected.
  element ns1:projectDesc {
    tei_projectDesc.content, tei_projectDesc.attributes
  }
tei_projectDesc.content = tei_model.pLike+
tei_projectDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_samplingDecl =
  
  ## (sampling declaration) contains a prose description of the rationale and methods used
  ## in sampling texts in the creation of a corpus or collection.
  element ns1:samplingDecl {
    tei_samplingDecl.content, tei_samplingDecl.attributes
  }
tei_samplingDecl.content = tei_model.pLike+
tei_samplingDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_editorialDecl =
  
  ## (editorial practice declaration) provides details of editorial principles and practices applied
  ## during the encoding of a text.
  element ns1:editorialDecl {
    tei_editorialDecl.content, tei_editorialDecl.attributes
  }
tei_editorialDecl.content =
  tei_model.pLike+ | tei_model.editorialDeclPart+
tei_editorialDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_correction =
  
  ## (correction principles) states how and under what circumstances corrections have been
  ## made in the text.
  element ns1:correction {
    tei_correction.content, tei_correction.attributes
  }
tei_correction.content = tei_model.pLike+
tei_correction.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## indicates the degree of correction applied to the text.
  ##    
  [ a1:defaultValue = "unknown" ]
  attribute status {
    
    ## (the text has been thoroughly checked and
    ##                        proofread.
    ##     ) 
    "high"
    | 
      ## (the text has been checked at least once.
      ##     ) 
      "medium"
    | 
      ## (the text has not been checked.
      ##     ) 
      "low"
    | 
      ## (the correction status of the text is unknown.
      ##    ) 
      "unknown"
  }?,
  
  ## indicates the method adopted to indicate corrections within the
  ##          text.
  ##    
  [ a1:defaultValue = "silent" ]
  attribute method {
    
    ## (corrections have been made silently
    ##     ) 
    "silent"
    | 
      ## (corrections have been represented using editorial tags
      ##    ) 
      "tags"
  }?,
  empty
tei_normalization =
  
  ## indicates the extent of normalization or regularization of the
  ## original source carried out in converting it to electronic form.
  element ns1:normalization {
    tei_normalization.content, tei_normalization.attributes
  }
tei_normalization.content = tei_model.pLike+
tei_normalization.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## indicates the authority for any normalization carried out.
  ##     
  attribute source { tei_data.pointer }?,
  
  ## indicates the method adopted to indicate normalizations within
  ##          the text.
  ##    
  [ a1:defaultValue = "silent" ]
  attribute method {
    
    ## (normalization made silently
    ##   ) 
    "silent"
    | 
      ## (normalization represented using editorial tags
      ##    ) 
      "tags"
  }?,
  empty
tei_quotation =
  
  ## specifies editorial practice adopted with respect to quotation
  ##   marks in the original. 
  element ns1:quotation {
    tei_quotation.content, tei_quotation.attributes
  }
tei_quotation.content = tei_model.pLike+
tei_quotation.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## indicates whether or not quotation marks have been retained as
  ##       content within the text. 
  [ a1:defaultValue = "all" ]
  attribute marks {
    
    ## (no quotation marks have been retained ) 
    "none"
    | 
      ## (some quotation marks have been retained ) 
      "some"
    | 
      ## (all quotation marks have been retained ) 
      "all"
  }?,
  
  ## specifies how quotation marks are indicated within the
  ##       text.
  [ a1:defaultValue = "unknown" ]
  attribute form {
    
    ## (quotation marks are retained as data.) 
    "data"
    | 
      ## (the rendition attribute is consistently used to
      ##           indicate the form of quotation marks.) 
      "rend"
    | 
      ## (use of quotation marks has been standardized.) 
      "std"
    | 
      ## (quotation marks are represented inconsistently.) 
      "nonstd"
    | 
      ## (use of quotation marks is unknown.) 
      "unknown"
  }?,
  empty
tei_hyphenation =
  
  ## (Hyphenation) summarizes the way in which hyphenation in a source text has been
  ## treated in an encoded version of it.
  element ns1:hyphenation {
    tei_hyphenation.content, tei_hyphenation.attributes
  }
tei_hyphenation.content = tei_model.pLike+
tei_hyphenation.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## indicates whether or not end-of-line hyphenation has been
  ##	retained in a text.
  [ a1:defaultValue = "some" ]
  attribute eol {
    
    ## (all end-of-line hyphenation has been retained,
    ##                    even though the lineation of the original
    ##                    may not have been.
    ##    ) 
    "all"
    | 
      ## (end-of-line hyphenation has been retained in some
      ##                    cases.
      ##    ) 
      "some"
    | 
      ## (all soft end-of-line hyphenation has been removed:
      ##                    any remaining end-od-line hyphenation should be retained.
      ##   ) 
      "hard"
    | 
      ## (all end-of-line hyphenation has been removed:
      ##                   any remaining hyphenation occurred within the line.
      ##    ) 
      "none"
  }?,
  empty
tei_segmentation =
  
  ## describes the principles according to which the text has been
  ## segmented, for example into sentences, tone-units, graphemic strata,
  ## etc.
  element ns1:segmentation {
    tei_segmentation.content, tei_segmentation.attributes
  }
tei_segmentation.content = tei_model.pLike+
tei_segmentation.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_stdVals =
  
  ## (Standard values) specifies the format used when standardized date or number
  ## values are supplied.
  element ns1:stdVals { tei_stdVals.content, tei_stdVals.attributes }
tei_stdVals.content = tei_model.pLike+
tei_stdVals.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_interpretation =
  
  ## describes the scope of any analytic or interpretive information
  ## added to the text in addition to the transcription. 
  element ns1:interpretation {
    tei_interpretation.content, tei_interpretation.attributes
  }
tei_interpretation.content = tei_model.pLike+
tei_interpretation.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_tagsDecl =
  
  ## (tagging declaration) provides detailed information about the tagging applied to an SGML or XML document.
  element ns1:tagsDecl { tei_tagsDecl.content, tei_tagsDecl.attributes }
tei_tagsDecl.content = tei_rendition*, tei_namespace*
tei_tagsDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_tagUsage =
  
  ## (tag usage) supplies information about the usage of a specific element
  ## within a text. 
  element ns1:tagUsage { tei_tagUsage.content, tei_tagUsage.attributes }
tei_tagUsage.content = tei_macro.paraContent
tei_tagUsage.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## the name (generic identifier)
  ## of the element indicated by the tag.
  attribute gi { tei_data.name },
  
  ## specifies the number of occurrences of this element within the text.
  ##  
  attribute occurs { tei_data.count }?,
  
  ## specifies the number of occurrences of this element within the text
  ## which bear a distinct value for the global xml:id attribute. 
  attribute withId { tei_data.count }?,
  
  ## specifies the identifier of a rendition element which
  ## defines how this element is to be rendered.
  attribute render { tei_data.pointer }?,
  empty
tei_namespace =
  
  ## supplies the formal name of the namespace to which the elements
  ## documented by its children belong. 
  element ns1:namespace {
    tei_namespace.content, tei_namespace.attributes
  }
tei_namespace.content = tei_tagUsage+
tei_namespace.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## the full formal name of the namespace concerned.
  attribute name { tei_data.namespace },
  empty
tei_rendition =
  
  ## (rendition) supplies information about the intended rendition of one or more
  ## elements.
  element ns1:rendition {
    tei_rendition.content, tei_rendition.attributes
  }
tei_rendition.content = tei_macro.paraContent
tei_rendition.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_refsDecl =
  
  ## (references declaration) specifies how canonical references are constructed for this
  ##   text.
  element ns1:refsDecl { tei_refsDecl.content, tei_refsDecl.attributes }
tei_refsDecl.content = tei_model.pLike+ | tei_cRefPattern+ | tei_state+
tei_refsDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## identifies the document type within which
  ##       this reference declaration is used.
  [ a1:defaultValue = "TEI" ] attribute doctype { tei_data.name }?,
  empty
tei_cRefPattern =
  
  ## (defines how to convert a canonical reference into a URI) specifies an expression and replacement pattern for
  ##   tranforming a canonical reference into a URI
  element ns1:cRefPattern {
    tei_cRefPattern.content, tei_cRefPattern.attributes
  }
tei_cRefPattern.content = tei_model.pLike*
tei_cRefPattern.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies a regular expression against which the values of
  ##       cRef attributes can be matched.
  attribute matchPattern { tei_data.pattern },
  
  ## specifies a replacement pattern
  ##       which, once subpattern substitution has been performed, provides
  ##       a URI.
  attribute replacementPattern { text },
  empty
tei_state =
  
  ## specifies one component of a canonical reference defined by
  ## the milestone method.
  element ns1:state { tei_state.content, tei_state.attributes }
tei_state.content = empty
tei_state.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates which edition or version the milestone applies to.
  attribute ed { tei_data.code }?,
  
  ## indicates what kind of state is changing at this milestone.
  ## Suggested values include: 1] page (page breaks in the reference edition.
  ##     ); 2] column (column breaks.
  ##     ); 3] line (line breaks.
  ##     ); 4] book (any units termed book, liber, etc.
  ##     ); 5] poem (individual poems in a collection.
  ##     ); 6] canto (cantos or other major sections of a poem.
  ##     ); 7] stanza (stanzas within a poem, book, or canto.
  ##     ); 8] act (acts within a play.
  ##     ); 9] scene (scenes within a play or act.
  ##     ); 10] section (sections of any kind.
  ##     ); 11] absent (passages not present in the reference edition.)
  attribute unit { tei_data.enumerated },
  
  ## specifies the fixed length of the reference component.
  attribute length { tei_data.count }?,
  
  ## supplies a delimiting string following the reference
  ##           component.
  attribute delim { text }?,
  empty
tei_classDecl =
  
  ## (classification declarations) contains one or more taxonomies defining any classificatory
  ## codes used elsewhere in the text.
  element ns1:classDecl {
    tei_classDecl.content, tei_classDecl.attributes
  }
tei_classDecl.content = tei_taxonomy+
tei_classDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_taxonomy =
  
  ## (taxonomy) defines a typology used to classify texts either implicitly, by
  ## means of a bibliographic citation, or explicitly by a structured
  ## taxonomy.
  element ns1:taxonomy { tei_taxonomy.content, tei_taxonomy.attributes }
tei_taxonomy.content =
  tei_model.glossLike*
  | tei_category+
  | (tei_model.biblLike, tei_category*)
tei_taxonomy.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_category =
  
  ## (category) contains an individual descriptive category, possibly nested
  ## within a superordinate category, within a user-defined taxonomy.
  element ns1:category { tei_category.content, tei_category.attributes }
tei_category.content =
  (tei_catDesc | tei_model.glossLike), tei_category*
tei_category.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_catDesc =
  
  ## (category description) describes some category within a taxonomy
  ## or text typology, either in the form of a brief prose description
  ## or in terms of the situational parameters used by the TEI
  ## formal textDesc.
  element ns1:catDesc { tei_catDesc.content, tei_catDesc.attributes }
tei_catDesc.content = (text | tei_model.phrase | tei_model.catDescPart)*
tei_catDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_fsdDecl =
  
  ## (FSD (feature-system declaration) declaration) identifies the feature system declaration which contains
  ## definitions for a particular type of feature structure.
  element ns1:fsdDecl { tei_fsdDecl.content, tei_fsdDecl.attributes }
tei_fsdDecl.content = empty
tei_fsdDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## identifies the type of feature structure documented by the FSD;
  ## this will be the value of the type attribute on at least one
  ## feature structure.
  attribute type { tei_data.enumerated },
  
  ## supplies a link to the entity containing the feature system
  ## declaration. 
  attribute url { tei_data.pointer },
  empty
tei_metDecl =
  
  ## documents the notation employed to represent a metrical
  ##   pattern when this is specified as the value of a met,
  ##   real, or rhyme attribute on any structural
  ##   element of a metrical text (e.g. lg, l, or
  ##   seg).
  element ns1:metDecl { tei_metDecl.content, tei_metDecl.attributes }
tei_metDecl.content = tei_macro.componentSeq | tei_metSym+
tei_metDecl.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  
  ## indicates whether the notation conveys the abstract
  ##       metrical form, its actual prosodic realization, or the rhyme
  ##       scheme, or some combination thereof.
  
  ## Sorry, unable to create schema that uses actual counts minOccurs=1 and maxOccurs=3; approximating to minOccurs=1 and maxOccurs=unbounded.
  [ a1:defaultValue = "met real" ]
  attribute type {
    list { tei_data.enumerated, tei_data.enumerated* }
  }?,
  
  ## specifies a regular expression defining any value that
  ##	is legal for this notation.
  attribute pattern { tei_data.pattern }?,
  empty
tei_metSym =
  
  ## documents the intended significance of a particular character or
  ## character sequence within a metrical notation, either explicitly or in
  ## terms of other symbol elements in the same metDecl.
  element ns1:metSym { tei_metSym.content, tei_metSym.attributes }
tei_metSym.content = tei_macro.phraseSeq
tei_metSym.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies the character or character sequence being documented.
  attribute value {
    list { tei_data.word+ }
  },
  
  ## specifies whether the symbol is defined in terms of other
  ## symbols (terminal is set to false) or in prose
  ## (terminal is set to true).
  [ a1:defaultValue = "true" ]
  attribute terminal {
    
    ## (the element contains a prose definition of its meaning.) 
    "true"
    | 
      ## (the element contains a definition of its meaning given using
      ## symbols defined elsewhere in the same metDecl element.) 
      "false"
  }?,
  empty
tei_variantEncoding =
  
  ## declares the method used to encode text-critical variants.
  element ns1:variantEncoding {
    tei_variantEncoding.content, tei_variantEncoding.attributes
  }
tei_variantEncoding.content = empty
tei_variantEncoding.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates which method is used to encode the apparatus of
  ## variants.
  attribute method {
    
    ## (apparatus uses line numbers or other canonical reference scheme
    ## referenced in a base text.) 
    "location-referenced"
    | 
      ## (apparatus indicates the precise locations of the beginning and
      ## ending of each lemma relative to a base text.) 
      "double-end-point"
    | 
      ## (alternate readings of a passage are given in parallel in the
      ## text; no notion of a base text is necessary.) 
      "parallel-segmentation"
  },
  
  ## indicates whether the apparatus appears within the running text
  ## or external to it.
  attribute location {
    
    ## (apparatus appears within the running text.) 
    "internal"
    | 
      ## (apparatus appears outside the base text.) 
      "external"
  },
  empty
tei_profileDesc =
  
  ## (text-profile description) provides a detailed description of non-bibliographic aspects of a
  ## text, specifically the languages and sublanguages used, the situation in
  ## which it was produced, the participants and their setting.
  element ns1:profileDesc {
    tei_profileDesc.content, tei_profileDesc.attributes
  }
tei_profileDesc.content = tei_creation?, tei_model.profileDescPart*
tei_profileDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_creation =
  
  ## contains information about the creation of a text.
  element ns1:creation { tei_creation.content, tei_creation.attributes }
tei_creation.content = tei_macro.phraseSeq
tei_creation.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_langUsage =
  
  ## (language usage) describes the languages, sublanguages, registers, dialects etc.
  ## represented within a text.
  element ns1:langUsage {
    tei_langUsage.content, tei_langUsage.attributes
  }
tei_langUsage.content = tei_language+
tei_langUsage.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_language =
  
  ## characterizes a single language or sublanguage used within a
  ##   text.
  element ns1:language { tei_language.content, tei_language.attributes }
tei_language.content = tei_macro.phraseSeq
tei_language.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## Supplies a language code constructed as defined in RFC 3066 (or
  ##       its successor) which is used to identify the language documented
  ##       by this element, and which is referenced by the global xml:lang attribute.
  attribute ident { tei_data.language },
  
  ## specifies the approximate percentage (by volume) of the
  ##       text which uses this language.
  ##       
  attribute usage {
    xsd:nonNegativeInteger { maxInclusive = "100" }
  }?,
  empty
tei_textClass =
  
  ## (text classification) groups information which describes the nature or topic of a text
  ## in terms of a standard classification scheme, thesaurus, etc.
  element ns1:textClass {
    tei_textClass.content, tei_textClass.attributes
  }
tei_textClass.content = (tei_classCode | tei_catRef | tei_keywords)*
tei_textClass.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declarable.attribute.default,
  empty
tei_keywords =
  
  ## contains a list of keywords or phrases identifying the topic or
  ## nature of a text.
  element ns1:keywords { tei_keywords.content, tei_keywords.attributes }
tei_keywords.content = tei_term+ | tei_list
tei_keywords.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## identifies the controlled vocabulary within which the set of
  ##   keywords concerned is defined.
  ##    
  attribute scheme { tei_data.pointer },
  empty
tei_classCode =
  
  ## contains the classification code used for this text in some
  ## standard classification system.
  element ns1:classCode {
    tei_classCode.content, tei_classCode.attributes
  }
tei_classCode.content = tei_macro.phraseSeq
tei_classCode.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## identifies the classification system or taxonomy in use.
  attribute scheme { tei_data.pointer },
  empty
tei_catRef =
  
  ## (category reference) specifies one or more defined categories
  ## within some taxonomy or text typology.
  element ns1:catRef { tei_catRef.content, tei_catRef.attributes }
tei_catRef.content = empty
tei_catRef.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## identifies the categories concerned
  ##    
  attribute target {
    list { tei_data.pointer+ }
  },
  
  ## identifies the classification scheme within which the set of
  ##     categories concerned is defined
  ##    
  attribute scheme { tei_data.pointer }?,
  empty
tei_revisionDesc =
  
  ## (revision description) summarizes the revision history for a file.
  element ns1:revisionDesc {
    tei_revisionDesc.content, tei_revisionDesc.attributes
  }
tei_revisionDesc.content = tei_list | tei_change+
tei_revisionDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_change =
  
  ## summarizes a particular change or correction made
  ## to a particular version of an electronic text which is
  ## shared between several researchers.
  element ns1:change { tei_change.content, tei_change.attributes }
tei_change.content = tei_macro.specialPara
tei_change.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.ascribed.attribute.who,
  
  ## supplies the date of the change in standard form,  i.e. yyyy-mm-dd.
  attribute date { tei_data.temporal }?,
  empty
tei_model.headerPart = tei_encodingDesc | tei_profileDesc
tei_model.headerPart_sequence = tei_encodingDesc, tei_profileDesc
tei_model.headerPart_sequenceOptional =
  tei_encodingDesc?, tei_profileDesc?
tei_model.headerPart_sequenceOptionalRepeatable =
  tei_encodingDesc*, tei_profileDesc*
tei_model.headerPart_sequenceRepeatable =
  tei_encodingDesc+, tei_profileDesc+
tei_model.sourceDescPart = tei_scriptStmt | tei_recordingStmt
tei_model.sourceDescPart_sequence = tei_scriptStmt, tei_recordingStmt
tei_model.sourceDescPart_sequenceOptional =
  tei_scriptStmt?, tei_recordingStmt?
tei_model.sourceDescPart_sequenceOptionalRepeatable =
  tei_scriptStmt*, tei_recordingStmt*
tei_model.sourceDescPart_sequenceRepeatable =
  tei_scriptStmt+, tei_recordingStmt+
tei_model.encodingPart =
  tei_projectDesc
  | tei_samplingDecl
  | tei_editorialDecl
  | tei_tagsDecl
  | tei_refsDecl
  | tei_classDecl
  | tei_fsdDecl
  | tei_metDecl
  | tei_variantEncoding
tei_model.encodingPart_sequence =
  tei_projectDesc,
  tei_samplingDecl,
  tei_editorialDecl,
  tei_tagsDecl,
  tei_refsDecl,
  tei_classDecl,
  tei_fsdDecl,
  tei_metDecl,
  tei_variantEncoding
tei_model.encodingPart_sequenceOptional =
  tei_projectDesc?,
  tei_samplingDecl?,
  tei_editorialDecl?,
  tei_tagsDecl?,
  tei_refsDecl?,
  tei_classDecl?,
  tei_fsdDecl?,
  tei_metDecl?,
  tei_variantEncoding?
tei_model.encodingPart_sequenceOptionalRepeatable =
  tei_projectDesc*,
  tei_samplingDecl*,
  tei_editorialDecl*,
  tei_tagsDecl*,
  tei_refsDecl*,
  tei_classDecl*,
  tei_fsdDecl*,
  tei_metDecl*,
  tei_variantEncoding*
tei_model.encodingPart_sequenceRepeatable =
  tei_projectDesc+,
  tei_samplingDecl+,
  tei_editorialDecl+,
  tei_tagsDecl+,
  tei_refsDecl+,
  tei_classDecl+,
  tei_fsdDecl+,
  tei_metDecl+,
  tei_variantEncoding+
tei_model.editorialDeclPart =
  tei_correction
  | tei_normalization
  | tei_quotation
  | tei_hyphenation
  | tei_segmentation
  | tei_stdVals
  | tei_interpretation
tei_model.editorialDeclPart_sequence =
  tei_correction,
  tei_normalization,
  tei_quotation,
  tei_hyphenation,
  tei_segmentation,
  tei_stdVals,
  tei_interpretation
tei_model.editorialDeclPart_sequenceOptional =
  tei_correction?,
  tei_normalization?,
  tei_quotation?,
  tei_hyphenation?,
  tei_segmentation?,
  tei_stdVals?,
  tei_interpretation?
tei_model.editorialDeclPart_sequenceOptionalRepeatable =
  tei_correction*,
  tei_normalization*,
  tei_quotation*,
  tei_hyphenation*,
  tei_segmentation*,
  tei_stdVals*,
  tei_interpretation*
tei_model.editorialDeclPart_sequenceRepeatable =
  tei_correction+,
  tei_normalization+,
  tei_quotation+,
  tei_hyphenation+,
  tei_segmentation+,
  tei_stdVals+,
  tei_interpretation+
tei_model.profileDescPart = tei_langUsage | tei_textClass
tei_model.profileDescPart_sequence = tei_langUsage, tei_textClass
tei_model.profileDescPart_sequenceOptional =
  tei_langUsage?, tei_textClass?
tei_model.profileDescPart_sequenceOptionalRepeatable =
  tei_langUsage*, tei_textClass*
tei_model.profileDescPart_sequenceRepeatable =
  tei_langUsage+, tei_textClass+
tei_TEI =
  
  ## (TEI document) contains a single TEI-conformant document,
  ## comprising a TEI header and a text, either in isolation or as part of a
  ## teiCorpus element.
  element ns1:TEI { tei_TEI.content, tei_TEI.attributes }
tei_TEI.content = tei_teiHeader, tei_text
tei_TEI.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## The version of the TEI scheme
  [ a1:defaultValue = "5.0" ] attribute version { xsd:decimal }?,
  empty
tei_text =
  
  ## contains a single text of any kind, whether unitary or
  ## composite, for example a poem or drama, a collection of essays, a novel,
  ## a dictionary, or a corpus sample.
  element ns1:text { tei_text.content, tei_text.attributes }
tei_text.content =
  tei_model.global*,
  (tei_front, tei_model.global*)?,
  (tei_body | tei_group),
  tei_model.global*,
  (tei_back, tei_model.global*)?
tei_text.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  empty
tei_body =
  
  ## (text body) contains the whole body of a single unitary text, excluding any front or back matter.
  element ns1:body { tei_body.content, tei_body.attributes }
tei_body.content =
  tei_model.global*,
  (tei_model.divWrapper, (tei_model.global | tei_model.divWrapper)*)?,
  (tei_model.divGenLike, (tei_model.global | tei_model.divGenLike)*)?,
  ((tei_model.divLike, (tei_model.global | tei_model.divGenLike)*)+
   | (tei_model.div1Like, (tei_model.global | tei_model.divGenLike)*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.divLike, (tei_model.global | tei_model.divGenLike)*)+
       | (tei_model.div1Like,
          (tei_model.global | tei_model.divGenLike)*)+)?)),
  (tei_model.divWrapper.bottom, tei_model.global*)*
tei_body.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  empty
tei_group =
  
  ## contains the body of a composite text, grouping together a
  ## sequence of distinct texts (or groups of such texts) which are regarded
  ## as a unit for some purpose, for example the collected works of an
  ## author, a sequence of prose essays, etc.
  element ns1:group { tei_group.content, tei_group.attributes }
tei_group.content =
  (tei_model.divWrapper | tei_model.global)*,
  ((tei_text | tei_group), (tei_text | tei_group | tei_model.global)*),
  tei_model.divWrapper.bottom*
tei_group.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  empty
tei_div =
  
  ## (text division) contains a subdivision of the front, body, or back of a
  ## text.
  element ns1:div { tei_div.content, tei_div.attributes }
tei_div.content =
  (tei_model.divWrapper | tei_model.global)*,
  ((((tei_div | tei_divGen), tei_model.global*)+
    | ((tei_macro.component, tei_model.global*)+,
       ((tei_div | tei_divGen), tei_model.global*)*)),
   ((tei_model.divWrapper | tei_model.divWrapper.bottom),
    tei_model.global*)*)?
tei_div.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div1 =
  
  ## (level-1 text division) contains a first-level subdivision of the front, body, or back
  ## of a text.
  element ns1:div1 { tei_div1.content, tei_div1.attributes }
tei_div1.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div2Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div2Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div1.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div2 =
  
  ## (level-2 text division) contains a second-level subdivision of the front, body, or back of a
  ##  text.
  element ns1:div2 { tei_div2.content, tei_div2.attributes }
tei_div2.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div3Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div3Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div2.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div3 =
  
  ## (level-3 text division) contains a third-level subdivision of the front, body, or back of a
  ##  text.
  element ns1:div3 { tei_div3.content, tei_div3.attributes }
tei_div3.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div4Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div4Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div3.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div4 =
  
  ## (level-4 text division) contains a fourth-level subdivision of the front, body, or back of a
  ##  text.
  element ns1:div4 { tei_div4.content, tei_div4.attributes }
tei_div4.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div5Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div5Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div4.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div5 =
  
  ## (level-5 text division) contains a fifth-level subdivision of the front, body, or back of a
  ##  text.
  element ns1:div5 { tei_div5.content, tei_div5.attributes }
tei_div5.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div6Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div6Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div5.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div6 =
  
  ## (level-6 text division) contains a sixth-level subdivision of the front, body, or back of a
  ##  text.
  element ns1:div6 { tei_div6.content, tei_div6.attributes }
tei_div6.content =
  (tei_model.divWrapper | tei_model.global)*,
  (((tei_model.div7Like | tei_model.divGenLike), tei_model.global*)+
   | ((tei_macro.component, tei_model.global*)+,
      ((tei_model.div7Like | tei_model.divGenLike),
       tei_model.global*)*)),
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div6.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_div7 =
  
  ## (level-7 text division) contains the smallest possible subdivision of the front, body or
  ## back of a text, larger than a paragraph.
  element ns1:div7 { tei_div7.content, tei_div7.attributes }
tei_div7.content =
  (tei_model.divWrapper | tei_model.global)*,
  (tei_macro.component, tei_model.global*)+,
  ((tei_model.divWrapper | tei_model.divWrapper.bottom),
   tei_model.global*)*
tei_div7.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.divLike.attribute.type,
  att.divLike.attribute.org,
  att.divLike.attribute.sample,
  att.divLike.attribute.part,
  att.declaring.attribute.decls,
  empty
tei_trailer =
  
  ## (trailer) contains a closing title or footer appearing at the end of
  ## a division of a text. 
  element ns1:trailer { tei_trailer.content, tei_trailer.attributes }
tei_trailer.content = tei_macro.phraseSeq
tei_trailer.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_byline =
  
  ## contains the primary statement of responsibility given for a work
  ## on its title page or at the head or end of the work.
  element ns1:byline { tei_byline.content, tei_byline.attributes }
tei_byline.content =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_docAuthor
   | tei_model.global)*
tei_byline.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_dateline =
  
  ## contains a brief description of the place, date, time, etc. of
  ##	production of a letter, newspaper story, or other work, prefixed or
  ##	suffixed to it as a kind of heading or trailer. 
  element ns1:dateline { tei_dateline.content, tei_dateline.attributes }
tei_dateline.content = tei_macro.phraseSeq
tei_dateline.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_argument =
  
  ## A formal list or prose description of the topics addressed by
  ##	a subdivision of a text.
  element ns1:argument { tei_argument.content, tei_argument.attributes }
tei_argument.content =
  tei_model.global*,
  (tei_head, tei_model.global*)?,
  (tei_macro.component, tei_model.global*)+
tei_argument.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_epigraph =
  
  ## (epigraph) contains a quotation, anonymous or attributed, appearing at
  ## the start of a section or chapter, or on a title page. 
  element ns1:epigraph { tei_epigraph.content, tei_epigraph.attributes }
tei_epigraph.content = tei_macro.componentSeq
tei_epigraph.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_opener =
  
  ## groups together dateline, byline, salutation, and similar
  ## phrases appearing as a preliminary group at the start of a
  ## division, especially of a letter.
  element ns1:opener { tei_opener.content, tei_opener.attributes }
tei_opener.content =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_argument
   | tei_byline
   | tei_dateline
   | tei_epigraph
   | tei_salute
   | tei_signed
   | tei_model.global)*
tei_opener.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_closer =
  
  ## groups together dateline, byline, salutation, and similar
  ## phrases appearing as a final group at the end of a
  ## division, especially of a letter.
  element ns1:closer { tei_closer.content, tei_closer.attributes }
tei_closer.content =
  (text
   | tei_model.gLike
   | tei_signed
   | tei_dateline
   | tei_salute
   | tei_model.phrase
   | tei_model.global)*
tei_closer.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_salute =
  
  ## (salutation) contains a salutation or greeting prefixed to a foreword,
  ## dedicatory epistle, or other division of a text, or the
  ## salutation in the closing of a letter, preface, etc.
  element ns1:salute { tei_salute.content, tei_salute.attributes }
tei_salute.content = tei_macro.phraseSeq
tei_salute.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_signed =
  
  ## (signature) contains the closing salutation, etc., appended to a foreword,
  ## dedicatory epistle, or other division of a text. 
  element ns1:signed { tei_signed.content, tei_signed.attributes }
tei_signed.content = tei_macro.phraseSeq
tei_signed.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_titlePage =
  
  ## (title page) contains the title page of a text, appearing within the front
  ## or back matter. 
  element ns1:titlePage {
    tei_titlePage.content, tei_titlePage.attributes
  }
tei_titlePage.content =
  tei_model.global*,
  tei_model.titlepagePart,
  (tei_model.titlepagePart | tei_model.global)*
tei_titlePage.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## classifies the title page according to any convenient typology.
  attribute type { tei_data.enumerated }?,
  empty
tei_docTitle =
  
  ## (document title) contains the title of a document, including all its
  ## constituents, as given on a title page.
  element ns1:docTitle { tei_docTitle.content, tei_docTitle.attributes }
tei_docTitle.content =
  tei_model.global*, (tei_titlePart, tei_model.global*)+
tei_docTitle.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_titlePart =
  
  ## (title part) contains a subsection or division of the title of a work, as
  ## indicated on a title page.
  element ns1:titlePart {
    tei_titlePart.content, tei_titlePart.attributes
  }
tei_titlePart.content = tei_macro.paraContent
tei_titlePart.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## specifies the role of this subdivision of the title.
  ## Suggested values include: 1] main (main title of the work
  ##         ); 2] sub (subtitle  of the work
  ##         ); 3] alt (alternative title  of the work
  ##         ); 4] short (abbreviated form of title); 5] desc (descriptive paraphrase of the work 
  ##    )
  [ a1:defaultValue = "main" ] attribute type { tei_data.enumerated }?,
  empty
tei_docAuthor =
  
  ## (document author) contains the name of the author of the document, as given on the
  ## title page (often but not always contained in a byline).
  element ns1:docAuthor {
    tei_docAuthor.content, tei_docAuthor.attributes
  }
tei_docAuthor.content = tei_macro.phraseSeq
tei_docAuthor.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_imprimatur =
  
  ## contains a formal statement authorizing the publication of
  ## a work, sometimes required to appear on a title page or its verso.
  element ns1:imprimatur {
    tei_imprimatur.content, tei_imprimatur.attributes
  }
tei_imprimatur.content = tei_macro.paraContent
tei_imprimatur.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_docEdition =
  
  ## (document edition) contains an edition statement as presented on a title page of a
  ## document.
  element ns1:docEdition {
    tei_docEdition.content, tei_docEdition.attributes
  }
tei_docEdition.content = tei_macro.paraContent
tei_docEdition.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_docImprint =
  
  ## (document imprint) contains the imprint statement (place and date of publication,
  ## publisher name), as given
  ## (usually) at the foot of a title page.
  element ns1:docImprint {
    tei_docImprint.content, tei_docImprint.attributes
  }
tei_docImprint.content =
  (text
   | tei_model.gLike
   | tei_model.phrase
   | tei_pubPlace
   | tei_docDate
   | tei_publisher
   | tei_model.global)*
tei_docImprint.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_docDate =
  
  ## (document date) contains the date of a document, as given
  ## (usually) on a title page.
  element ns1:docDate { tei_docDate.content, tei_docDate.attributes }
tei_docDate.content = tei_macro.phraseSeq
tei_docDate.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## gives the value of the date in a standard form, generally YYYY-MM-DD.
  attribute value { tei_data.temporal }?,
  empty
tei_front =
  
  ## (front matter) contains any prefatory matter (headers,
  ## title page, prefaces, dedications, etc.)
  ## found  at the start of a document, before the main body.
  element ns1:front { tei_front.content, tei_front.attributes }
tei_front.content =
  (tei_model.frontPart | tei_model.pLike.front | tei_model.global)*,
  ((tei_model.div1Like,
    (tei_model.frontPart | tei_model.div1Like | tei_model.global)*)
   | (tei_model.divLike,
      (tei_model.frontPart | tei_model.divLike | tei_model.global)*))?
tei_front.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  empty
tei_back =
  
  ## (back matter) contains any appendixes, etc. following the main part of a
  ## text.
  element ns1:back { tei_back.content, tei_back.attributes }
tei_back.content =
  (tei_model.frontPart | tei_model.global | tei_model.divWrapper)*,
  ((tei_model.divLike, (tei_model.global | tei_model.frontPart)*)+
   | (tei_model.div1Like, (tei_model.global | tei_model.frontPart)*)+)?,
  tei_model.divWrapper.bottom*
tei_back.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.declaring.attribute.decls,
  empty
tei_table =
  
  ## contains text displayed in tabular form, in
  ## rows and columns.
  element ns1:table { tei_table.content, tei_table.attributes }
tei_table.content =
  (tei_head | tei_model.global)*, (tei_row, tei_model.global*)+
tei_table.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  
  ## indicates the number of rows in the table.
  attribute rows { tei_data.count }?,
  
  ## indicates the number of columns in each row of the table.
  attribute cols { tei_data.count }?,
  empty
tei_row =
  
  ## contains one row of a table. 
  element ns1:row { tei_row.content, tei_row.attributes }
tei_row.content = ((tei_cell | tei_table), tei_model.global*)+
tei_row.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.tableDecoration.attribute.role,
  att.tableDecoration.attribute.rows,
  att.tableDecoration.attribute.cols,
  empty
tei_cell =
  
  ## contains one cell of a table. 
  element ns1:cell { tei_cell.content, tei_cell.attributes }
tei_cell.content = tei_macro.paraContent
tei_cell.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  att.tableDecoration.attribute.role,
  att.tableDecoration.attribute.rows,
  att.tableDecoration.attribute.cols,
  empty
tei_formula =
  
  ## contains a mathematical or other formula.
  element ns1:formula { tei_formula.content, tei_formula.attributes }
tei_formula.content = mathml.math
tei_formula.attributes =
  
  ## supplies the name of a previously defined notation used for the
  ## content of the
  ## element.
  attribute notation { tei_data.code }?,
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_figure =
  
  ## contains a block containing graphics, illustrations, or figures.
  element ns1:figure { tei_figure.content, tei_figure.attributes }
tei_figure.content =
  (tei_model.pLike
   | tei_model.global
   | tei_figure
   | tei_figDesc
   | tei_model.graphicLike
   | tei_head)*
tei_figure.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
tei_figDesc =
  
  ## (Description of Figure) contains a brief prose description of the appearance or content
  ## of a graphic figure, for use when documenting an image without
  ## displaying it.
  element ns1:figDesc { tei_figDesc.content, tei_figDesc.attributes }
tei_figDesc.content = tei_macro.paraContent
tei_figDesc.attributes =
  att.global.attribute.xmlspace,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.rend,
  att.global.attribute.xmlbase,
  empty
start = tei_TEI
